<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[IoC容器和Dependency Injection模式]]></title>
      <url>/2017/07/26/IoC-And-DI_cn/</url>
      <content type="html"><![CDATA[<p>译者：熊节</p>
<p>英文原文：<a href="https://martinfowler.com/articles/injection.html" target="_blank" rel="external">Inversion of Control Containers and the Dependency Injection pattern</a></p>
<p><em>（最初发表于2004年1月）</em>IoC容器和Dependency Injection模式</p>
<p><em>摘要：Java社群近来掀起了一阵轻量级容器的热潮，这些容器能够帮助开发者将来自不同项目的组件组装成为一个内聚的应用程序。在它们的背后有着同一个模式，这个模式决定了这些容器进行组件装配的方式。人们用一个大而化之的名字来称呼这个模式：”控制反转”（Inversion ofControl，IoC）。在本文中，我将深入探索这个模式的工作原理，给它一个更能描述其特点的名字——”依赖注入”（Dependency Injection），并将其与”服务定位器”（Service Locator）模式作一个比较。不过，这两者之间的差异并不太重要，更重要的是：应该将组件的配置与使用分离开——两个模式的目标都是这个。</em></p>
<p>在企业级Java的世界里存在一个有趣的现象：有很多人投入很多精力来研究主流J2EE 技术的替代品——自然，这大多发生在open source社群。在很大程度上，这可以看作是开发者对主流J2EE技术的笨重和复杂作出的回应，但其中的确有很多极富创意的想法，的确提供了一些可供选择的方案。J2EE开发者常遇到的一个问题就是如何组装不同的程序元素：如果web控制器体系结构和数据库接口是由不同的团队所开发的，彼此几乎一无所知，你应该如何让它们配合工作？很多框架尝试过解决这个问题，有几个框架索性朝这个方向发展，提供了更通用的”组装各层组件”的方案。这样的框架通常被称为”轻量级容器”，PicoContainer和Spring都在此列中。</p>
<p>在这些容器背后，一些有趣的设计原则发挥着作用。这些原则已经超越了特定容器的范畴，甚至已经超越了Java平台的范畴。在本文中，我就要初步揭示这些原则。我使用的范例是Java代码，但正如我的大多数文章一样，这些原则也同样适用于别的OO环境，特别是.NET。</p>
<h3 id="组件和服务"><a href="#组件和服务" class="headerlink" title="组件和服务"></a>组件和服务</h3><p>装配程序元素，这样的话题立即将我拖进了一个棘手的术语问题：如何区分”服务”（service）和”组件”（component）？你可以毫不费力地找出关于这两个词定义的长篇大论，各种彼此矛盾的定义会让你感受到我所处的窘境。有鉴于此，对于这两个遭到了严重滥用的词汇，我将首先说明它们在本文中的用法。</p>
<p>所谓”组件”是指这样一个软件单元：它将被作者无法控制的其他应用程序使用，但后者不能对组件进行修改。也就是说，使用一个组件的应用程序不能修改组件的源代码，但可以通过作者预留的某种途径对其进行扩展，以改变组件的行为。</p>
<p>服务和组件有某种相似之处：它们都将被外部的应用程序使用。在我看来，两者之间最大的差异在于：组件是在本地使用的（例如JAR文件、程序集、DLL、或者源码导入）；而服务是要通过同步或异步的远程接口来远程使用的（例如web service、消息系统、RPC，或者socket）。</p>
<p>在本文中，我将主要使用”服务”这个词，但文中的大多数逻辑也同样适用于本地组件。实际上，为了方便地访问远程服务，你往往需要某种本地组件框架。不过，”组件或者服务”这样一个词组实在太麻烦了，而且”服务”这个词当下也很流行，所以本文将用”服务”指代这两者。</p>
<h3 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h3><p>为了更好地说明问题，我要引入一个例子。和我以前用的所有例子一样，这是一个超级简单的例子：它非常小，小得有点不够真实，但足以帮助你看清其中的道理，而不至于陷入真实例子的泥潭中无法自拔。</p>
<p>在这个例子中，我编写了一个组件，用于提供一份电影清单，清单上列出的影片都是由一位特定的导演执导的。实现这个伟大的功能只需要一个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">class MovieLister...</div><div class="line"></div><div class="line">    public Movie[] moviesDirectedBy(String arg)</div><div class="line">    &#123;</div><div class="line">        List allMovies = finder.findAll();</div><div class="line">        for (Iterator it = allMovies.iterator(); it.hasNext();)</div><div class="line">        &#123;</div><div class="line">            Movie movie = (Movie) it.next();</div><div class="line">            if (!movie.getDirector().equals(arg))</div><div class="line">            &#123;</div><div class="line">                it.remove();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">        return (Movie[]) allMovies.toArray(new Movie[allMovies.size()]);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>你可以看到，这个功能的实现极其简单：moviesDirectedBy方法首先请求finder（影片搜寻者）对象（我们稍后会谈到这个对象）返回后者所知道的所有影片，然后遍历finder对象返回的清单，并返回其中由特定的某个导演执导的影片。非常简单，不过不必担心，这只是整个例子的脚手架罢了。我们真正想要考察的是finder对象，或者说，如何将MovieLister对象与特定的finder对象连接起来。为什么我们对这个问题特别感兴趣？因为我希望上面这个漂亮的moviesDirectedBy方法完全不依赖于影片的实际存储方式。所以，这个方法只能引用一个finder对象，而finder对象则必须知道如何对findAll 方法作出回应。为了帮助读者更清楚地理解，我给finder定义了一个接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public interface MovieFinder</div><div class="line">&#123;</div><div class="line">    List findAll();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在，两个对象之间没有什么耦合关系。但是，当我要实际寻找影片时，就必须涉及到MovieFinder的某个具体子类。在这里，我把涉及具体子类的代码放在MovieLister类的构造函数中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class MovieLister...</div><div class="line">    private MovieFinder finder;</div><div class="line">    public MovieLister()</div><div class="line">    &#123;</div><div class="line">        finder = new ColonDelimitedMovieFinder(&quot;movies1.txt&quot;);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这个实现类的名字就说明：我将要从一个逗号分隔的文本文件中获得影片列表。你不必操心具体的实现细节，只要设想这样一个实现类就可以了。如果这个类只由我自己使用，一切都没问题。但是，如果我的朋友叹服于这个精彩的功能，也想使用我的程序，那又会怎么样呢？如果他们也把影片清单保存在一个逗号分隔的文本文件中，并且也把这个文件命名为” movie1.txt “，那么一切还是没问题。如果他们只是给这个文件改改名，我也可以从一个配置文件获得文件名，这也很容易。但是，如果他们用完全不同的方式——例如SQL 数据库、XML 文件、web service，或者另一种格式的文本文件——来存储影片清单呢？在这种情况下，我们需要用另一个类来获取数据。由于已经定义了MovieFinder接口，我可以不用修改moviesDirectedBy方法。但是，我仍然需要通过某种途径获得合适的MovieFinder实现类的实例。</p>
<p><img src="http://insights.thoughtworkers.org/wp-content/uploads/2017/03/injection-image-1.gif" alt="img"></p>
<p>图1：在MovieLister 类中直接创建MovieFinder 实例时的依赖关系</p>
<p>图1展现了这种情况下的依赖关系：MovieLister类既依赖于MovieFinder接口，也依赖于具体的实现类。我们当然希望MovieLister类只依赖于接口，但我们要如何获得一个MovieFinder子类的实例呢？</p>
<p>在Patterns of Enterprise Application Architecture一书中，我们把这种情况称为插件（plugin）：MovieFinder的实现类不是在编译期连入程序之中的，因为我并不知道我的朋友会使用哪个实现类。我们希望MovieLister类能够与MovieFinder的任何实现类配合工作，并且允许在运行期插入具体的实现类，插入动作完全脱离我（原作者）的控制。这里的问题就是：如何设计这个连接过程，使MovieLister类在不知道实现类细节的前提下与其实例协同工作。</p>
<p>将这个例子推而广之，在一个真实的系统中，我们可能有数十个服务和组件。在任何时候，我们总可以对使用组件的情形加以抽象，通过接口与具体的组件交流（如果组件并没有设计一个接口，也可以通过适配器与之交流）。但是，如果我们希望以不同的方式部署这个系统，就需要用插件机制来处理服务之间的交互过程，这样我们才可能在不同的部署方案中使用不同的实现。所以，现在的核心问题就是：如何将这些插件组合成一个应用程序？这正是新生的轻量级容器所面临的主要问题，而它们解决这个问题的手段无一例外地是控制反转（Inversion of Control）模式。</p>
<h3 id="控制反转"><a href="#控制反转" class="headerlink" title="控制反转"></a>控制反转</h3><p>几位轻量级容器的作者曾骄傲地对我说：这些容器非常有用，因为它们实现了控制反转。这样的说辞让我深感迷惑：控制反转是框架所共有的特征，如果仅仅因为使用了控制反转就认为这些轻量级容器与众不同，就好象在说我的轿车是与众不同的，因为它有四个轮子。</p>
<p>问题的关键在于：它们反转了哪方面的控制？我第一次接触到的控制反转针对的是用户界面的主控权。早期的用户界面是完全由应用程序来控制的，你预先设计一系列命令，例如输入姓名、输入地址等，应用程序逐条输出提示信息，并取回用户的响应。而在图形用户界面环境下，UI框架将负责执行一个主循环，你的应用程序只需为屏幕的各个区域提供事件处理函数即可。在这里，程序的主控权发生了反转：从应用程序移到了框架。对于这些新生的容器，它们反转的是如何定位插件的具体实现。在前面那个简单的例子中，MovieLister类负责定位MovieFinder的具体实现——它直接实例化后者的一个子类。这样一来，MovieFinder也就不成其为一个插件了，因为它并不是在运行期插入应用程序中的。而这些轻量级容器则使用了更为灵活的办法，只要插件遵循一定的规则，一个独立的组装模块就能够将插件的具体实现注射到应用程序中。因此，我想我们需要给这个模式起一个更能说明其特点的名字——”控制反转”这个名字太泛了，常常让人有些迷惑。与多位IoC 爱好者讨论之后，我们决定将这个模式叫做”依赖注入”（Dependency Injection）。</p>
<p>下面，我将开始介绍Dependency Injection模式的几种不同形式。不过，在此之前，我要首先指出：要消除应用程序对插件实现的依赖，依赖注入并不是唯一的选择，你也可以用ServiceLocator模式获得同样的效果。介绍完Dependency Injection模式之后，我也会谈到ServiceLocator 模式。</p>
<h3 id="依赖注入的几种形式"><a href="#依赖注入的几种形式" class="headerlink" title="依赖注入的几种形式"></a>依赖注入的几种形式</h3><p>Dependency Injection模式的基本思想是：用一个单独的对象（装配器）来获得MovieFinder的一个合适的实现，并将其实例赋给MovieLister类的一个字段。这样一来，我们就得到了图2所示的依赖图：</p>
<p><img src="http://insights.thoughtworkers.org/wp-content/uploads/2017/03/injection-image-2.gif" alt="img"></p>
<p>图2：引入依赖注入器之后的依赖关系</p>
<p>依赖注入的形式主要有三种，我分别将它们叫做构造函数注入（Constructor Injection）、设值方法注入（Setter Injection）和接口注入（Interface Injection）。如果读过最近关于IoC的一些讨论材料，你不难看出：这三种注入形式分别就是type 1 IoC（接口注入）、type 2 IoC（设值方法注入）和type 3 IoC（构造函数注入）。我发现数字编号往往比较难记，所以我使用了这里的命名方式。</p>
<h4 id="使用PicoContainer-进行构造函数注入"><a href="#使用PicoContainer-进行构造函数注入" class="headerlink" title="使用PicoContainer 进行构造函数注入"></a>使用PicoContainer 进行构造函数注入</h4><p>首先，我要向读者展示如何用一个名为PicoContainer的轻量级容器完成依赖注入。之所以从这里开始，主要是因为我在ThoughtWorks公司的几个同事在PicoContainer的开发社群中非常活跃——没错，也可以说是某种偏袒吧。</p>
<p>PicoContainer通过构造函数来判断如何将MovieFinder实例注入MovieLister 类。因此，MovieLister类必须声明一个构造函数，并在其中包含所有需要注入的元素：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class MovieLister...</div><div class="line">    public MovieLister(MovieFinder finder)</div><div class="line">    &#123;</div><div class="line">        this.finder = finder;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>MovieFinder实例本身也将由PicoContainer来管理，因此文本文件的名字也可以由容器注入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class ColonMovieFinder...</div><div class="line">    public ColonMovieFinder(String filename)</div><div class="line">    &#123;</div><div class="line">        this.filename = filename;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>随后，需要告诉PicoContainer：各个接口分别与哪个实现类关联、将哪个字符串注入MovieFinder组件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">private MutablePicoContainer configureContainer()</div><div class="line">&#123;</div><div class="line">    MutablePicoContainer pico = new DefaultPicoContainer();</div><div class="line">    Parameter[] finderParams = &#123;newConstantParameter(&quot;movies1.txt&quot;)&#125;;</div><div class="line">    pico.registerComponentImplementation(MovieFinder.class,ColonMovieFinder.class, finderParams);</div><div class="line">    pico.registerComponentImplementation(MovieLister.class);</div><div class="line">    return pico;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段配置代码通常位于另一个类。对于我们这个例子，使用我的MovieLister 类的朋友需要在自己的设置类中编写合适的配置代码。当然，还可以将这些配置信息放在一个单独的配置文件中，这也是一种常见的做法。你可以编写一个类来读取配置文件，然后对容器进行合适的设置。尽管PicoContainer本身并不包含这项功能，但另一个与它关系紧密的项目NanoContainer提供了一些包装，允许开发者使用XML配置文件保存配置信息。NanoContainer能够解析XML文件，并对底下的PicoContainer进行配置。这个项目的哲学观念就是：将配置文件的格式与底下的配置机制分离开。</p>
<p>使用这个容器，你写出的代码大概会是这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public void testWithPico()</div><div class="line">&#123;</div><div class="line">    MutablePicoContainer pico = configureContainer();</div><div class="line">    MovieLister lister = (MovieLister)pico.getComponentInstance(MovieLister.class);</div><div class="line">    Movie[] movies = lister.moviesDirectedBy(&quot;Sergio Leone&quot;);</div><div class="line">    assertEquals(&quot;Once Upon a Time in the West&quot;,movies[0].getTitle());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>尽管在这里我使用了构造函数注入，实际上PicoContainer也支持设值方法注入，不过该项目的开发者更推荐使用构造函数注入。</p>
<h4 id="使用Spring-进行设值方法注入"><a href="#使用Spring-进行设值方法注入" class="headerlink" title="使用Spring 进行设值方法注入"></a>使用Spring 进行设值方法注入</h4><p>Spring 框架是一个用途广泛的企业级Java 开发框架，其中包括了针对事务、持久化框架、web应用开发和JDBC等常用功能的抽象。和PicoContainer一样，它也同时支持构造函数注入和设值方法注入，但该项目的开发者更推荐使用设值方法注入——恰好适合这个例子。为了让MovieLister类接受注入，我需要为它定义一个设值方法，该方法接受类型为MovieFinder的参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class MovieLister...</div><div class="line">    private MovieFinder finder;</div><div class="line">    public void setFinder(MovieFinder finder)</div><div class="line">    &#123;</div><div class="line">        this.finder = finder;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>类似地，在MovieFinder的实现类中，我也定义了一个设值方法，接受类型为String 的参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class ColonMovieFinder...</div><div class="line">    public void setFilename(String filename)</div><div class="line">    &#123;</div><div class="line">        this.filename = filename;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>第三步是设定配置文件。Spring 支持多种配置方式，你可以通过XML 文件进行配置，也可以直接在代码中配置。不过，XML 文件是比较理想的配置方式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;beans&gt;</div><div class="line">    &lt;bean id=&quot;MovieLister&quot; class=&quot;spring.MovieLister&quot;&gt;</div><div class="line">        &lt;property name=&quot;finder&quot;&gt;</div><div class="line">            &lt;ref local=&quot;MovieFinder&quot;/&gt;</div><div class="line">        &lt;/property&gt;</div><div class="line">    &lt;/bean&gt;</div><div class="line">    &lt;bean id=&quot;MovieFinder&quot; class=&quot;spring.ColonMovieFinder&quot;&gt;</div><div class="line">        &lt;property name=&quot;filename&quot;&gt;</div><div class="line">            &lt;value&gt;movies1.txt&lt;/value&gt;</div><div class="line">        &lt;/property&gt;</div><div class="line">    &lt;/bean&gt;</div><div class="line">&lt;/beans&gt;</div></pre></td></tr></table></figure>
<p>于是，测试代码大概就像下面这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public void testWithSpring() throws Exception</div><div class="line">&#123;</div><div class="line">    ApplicationContext ctx = newFileSystemXmlApplicationContext(&quot;spring.xml&quot;);</div><div class="line">    MovieLister lister = (MovieLister) ctx.getBean(&quot;MovieLister&quot;);</div><div class="line">    Movie[] movies = lister.moviesDirectedBy(&quot;Sergio Leone&quot;);</div><div class="line">    assertEquals(&quot;Once Upon a Time in the West&quot;,movies[0].getTitle());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="接口注入"><a href="#接口注入" class="headerlink" title="接口注入"></a>接口注入</h4><p>除了前面两种注入技术，还可以在接口中定义需要注入的信息，并通过接口完成注入。Avalon框架就使用了类似的技术。在这里，我首先用简单的范例代码说明它的用法，后面还会有更深入的讨论。首先，我需要定义一个接口，组件的注入将通过这个接口进行。在本例中，这个接口的用途是将一个MovieFinder实例注入继承了该接口的对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public interface InjectFinder</div><div class="line">&#123;</div><div class="line">    void injectFinder(MovieFinder finder);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个接口应该由提供MovieFinder接口的人一并提供。任何想要使用MovieFinder实例的类（例如MovieLister类）都必须实现这个接口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class MovieLister implements InjectFinder...</div><div class="line">    public void injectFinder(MovieFinder finder)</div><div class="line">    &#123;</div><div class="line">        this.finder = finder;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>然后，我使用类似的方法将文件名注入MovieFinder的实现类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public interface InjectFilename</div><div class="line">&#123;</div><div class="line">    void injectFilename (String filename);</div><div class="line">&#125;</div><div class="line"></div><div class="line">class ColonMovieFinder implements MovieFinder, InjectFilename...</div><div class="line">    public void injectFilename(String filename)</div><div class="line">    &#123;</div><div class="line">        this.filename = filename;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>现在，还需要用一些配置代码将所有的组件实现装配起来。简单起见，我直接在代码中完成配置，并将配置好的MovieLister 对象保存在名为lister的字段中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">class IfaceTester...</div><div class="line">    private MovieLister lister;</div><div class="line">    private void configureLister()</div><div class="line">    &#123;</div><div class="line">        ColonMovieFinder finder = new ColonMovieFinder();</div><div class="line">        finder.injectFilename(&quot;movies1.txt&quot;);</div><div class="line">        lister = new MovieLister();</div><div class="line">        lister.injectFinder(finder);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>测试代码则可以直接使用这个字段：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">class IfaceTester...</div><div class="line">    public void testIface()</div><div class="line">    &#123;</div><div class="line">        configureLister();</div><div class="line">        Movie[] movies = lister.moviesDirectedBy(&quot;Sergio Leone&quot;);</div><div class="line">        assertEquals(&quot;Once Upon a Time in the West&quot;,movies[0].getTitle());</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="使用Service-Locator"><a href="#使用Service-Locator" class="headerlink" title="使用Service Locator"></a>使用Service Locator</h3><p>依赖注入的最大好处在于：它消除了MovieLister类对具体MovieFinder实现类的依赖。这样一来，我就可以把MovieLister类交给朋友，让他们根据自己的环境插入一个合适的MovieFinder实现即可。不过，Dependency Injection模式并不是打破这层依赖关系的唯一手段，另一种方法是使用Service Locator模式。</p>
<p>Service Locator模式背后的基本思想是：有一个对象（即服务定位器）知道如何获得一个应用程序所需的所有服务。也就是说，在我们的例子中，服务定位器应该有一个方法，用于获得一个MovieFinder实例。当然，这不过是把麻烦换了一个样子，我们仍然必须在MovieLister中获得服务定位器，最终得到的依赖关系如图3 所示：</p>
<p><img src="http://insights.thoughtworkers.org/wp-content/uploads/2017/03/injection-image-3.gif" alt="img"></p>
<p>图3：使用Service Locator 模式之后的依赖关系</p>
<p>在这里，我把ServiceLocator类实现为一个Singleton的注册表，于是MovieLister就可以在实例化时通过ServiceLocator获得一个MovieFinder实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">class MovieLister...</div><div class="line">    MovieFinder finder = ServiceLocator.movieFinder();</div><div class="line"></div><div class="line">class ServiceLocator...</div><div class="line">    public static MovieFinder movieFinder()</div><div class="line">    &#123;</div><div class="line">        return soleInstance.movieFinder;</div><div class="line">    &#125;</div><div class="line">    private static ServiceLocator soleInstance;</div><div class="line">    private MovieFinder movieFinder;</div></pre></td></tr></table></figure>
<p>和注入的方式一样，我们也必须对服务定位器加以配置。在这里，我直接在代码中进行配置，但设计一种通过配置文件获得数据的机制也并非难事。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">class Tester...</div><div class="line">    private void configure()</div><div class="line">    &#123;</div><div class="line">        ServiceLocator.load(new ServiceLocator(</div><div class="line">        newColonMovieFinder(&quot;movies1.txt&quot;)));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">class ServiceLocator...</div><div class="line">    public static void load(ServiceLocator arg)</div><div class="line">    &#123;</div><div class="line">        soleInstance = arg;</div><div class="line">    &#125;</div><div class="line">    public ServiceLocator(MovieFinder movieFinder)</div><div class="line">    &#123;</div><div class="line">    this.movieFinder = movieFinder;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>下面是测试代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">class Tester...</div><div class="line">    public void testSimple()</div><div class="line">    &#123;</div><div class="line">        configure();</div><div class="line">        MovieLister lister = new MovieLister();</div><div class="line">        Movie[] movies = lister.moviesDirectedBy(&quot;Sergio Leone&quot;);</div><div class="line">        assertEquals(&quot;Once Upon a Time in the West&quot;,movies[0].getTitle());</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>我时常听到这样的论调：这样的服务定位器不是什么好东西，因为你无法替换它返回的服务实现，从而导致无法对它们进行测试。当然，如果你的设计很糟糕，你的确会遇到这样的麻烦；但你也可以选择良好的设计。在这个例子中，ServiceLocator实例仅仅是一个简单的数据容器，只需要对它做一些简单的修改，就可以让它返回用于测试的服务实现。</p>
<p>对于更复杂的情况，我可以从ServiceLocator派生出多个子类，并将子类型的实例传递给注册表的类变量。另外，我可以修改ServiceLocator的静态方法，使其调用ServiceLocator实例的方法，而不是直接访问实例变量。我还可以使用特定于线程的存储机制，从而提供特定于线程的服务定位器。所有这一切改进都无须修改ServiceLocator的使用者。</p>
<p>一种改进的思路是：服务定位器仍然是一个注册表，但不是Singleton。Singleton的确是实现注册表的一种简单途径，但这只是一个实现时的决定，可以很轻松地改变它。</p>
<h4 id="为定位器提供分离的接口"><a href="#为定位器提供分离的接口" class="headerlink" title="为定位器提供分离的接口"></a>为定位器提供分离的接口</h4><p>上面这种简单的实现方式有一个问题：MovieLister类将依赖于整个ServiceLocator类，但它需要使用的却只是后者所提供的一项服务。我们可以针对这项服务提供一个单独的接口，减少MovieLister对ServiceLocator的依赖程度。这样一来，MovieLister就不必使用整个的ServiceLocator 接口，只需声明它想要使用的那部分接口。</p>
<p>此时，MovieLister 类的提供者也应该一并提供一个定位器接口，使用者可以通过这个接口获得MovieFinder实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface MovieFinderLocator</div><div class="line">&#123;</div><div class="line">    public MovieFinder movieFinder();</div></pre></td></tr></table></figure>
<p>真实的服务定位器需要实现上述接口，提供访问MovieFinder实例的能力：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">MovieFinderLocator locator = ServiceLocator.locator();</div><div class="line">MovieFinder finder = locator.movieFinder();</div><div class="line">public static ServiceLocator locator()</div><div class="line">&#123;</div><div class="line">return soleInstance;</div><div class="line">&#125;</div><div class="line">public MovieFinder movieFinder()</div><div class="line">&#123;</div><div class="line">    return movieFinder;</div><div class="line">&#125;</div><div class="line">private static ServiceLocator soleInstance;</div><div class="line">private MovieFinder movieFinder;</div></pre></td></tr></table></figure>
<p>你应该已经注意到了：由于想要使用接口，我们不能再通过静态方法直接访问服务——我们必须首先通过ServiceLocator类获得定位器实例，然后使用定位器实例得到我们想要的服务。</p>
<h4 id="动态服务定位器"><a href="#动态服务定位器" class="headerlink" title="动态服务定位器"></a>动态服务定位器</h4><p>上面是一个静态定位器的例子——对于你所需要的每项服务，ServiceLocator类都有对应的方法。这并不是实现服务定位器的唯一方式，你也可以创建一个动态服务定位器，你可以在其中注册需要的任何服务，并在运行期决定获得哪一项服务。</p>
<p>在本例中，ServiceLocator使用一个map来保存服务信息，而不再是将这些信息保存在字段中。此外，ServiceLocator还提供了一个通用的方法，用于获取和加载服务对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">class ServiceLocator...</div><div class="line">    private static ServiceLocator soleInstance;</div><div class="line">    public static void load(ServiceLocator arg)</div><div class="line">    &#123;</div><div class="line">        soleInstance = arg;</div><div class="line">    &#125;</div><div class="line">    private Map services = new HashMap();</div><div class="line">    public static Object getService(String key)</div><div class="line">    &#123;</div><div class="line">        return soleInstance.services.get(key);</div><div class="line">    &#125;</div><div class="line">    public void loadService (String key, Object service)</div><div class="line">    &#123;</div><div class="line">        services.put(key, service);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>同样需要对服务定位器进行配置，将服务对象与适当的关键字加载到定位器中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">class Tester...</div><div class="line">    private void configure()</div><div class="line">    &#123;</div><div class="line">        ServiceLocator locator = new ServiceLocator();</div><div class="line">        locator.loadService(&quot;MovieFinder&quot;, newColonMovieFinder(&quot;movies1.txt&quot;));</div><div class="line">        ServiceLocator.load(locator);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>我使用与服务对象类名称相同的字符串作为服务对象的关键字：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">class MovieLister...</div><div class="line">    MovieFinder finder = (MovieFinder)</div><div class="line">    ServiceLocator.getService(&quot;MovieFinder&quot;);</div></pre></td></tr></table></figure>
<p>总体而言，我不喜欢这种方式。无疑，这样实现的服务定位器具有更强的灵活性，但它的使用方式不够直观明朗。我只有通过文本形式的关键字才能找到一个服务对象。相比之下，我更欣赏通过一个方法明确获得服务对象的方式，因为这让使用者能够从接口定义中清楚地知道如何获得某项服务。</p>
<h4 id="用Avalon-兼顾服务定位器和依赖注入"><a href="#用Avalon-兼顾服务定位器和依赖注入" class="headerlink" title="用Avalon 兼顾服务定位器和依赖注入"></a>用Avalon 兼顾服务定位器和依赖注入</h4><p>Dependency Injection和Service Locator两个模式并不是互斥的，你可以同时使用它们，Avalon框架就是这样的一个例子。Avalon使用了服务定位器，但如何获得定位器的信息则是通过注入的方式告知组件的。</p>
<p>对于前面一直使用的例子，Berin Loritsch发送给了我一个简单的Avalon实现版本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class MyMovieLister implements MovieLister, Serviceable</div><div class="line">&#123;</div><div class="line">    private MovieFinder finder;</div><div class="line">    public void service( ServiceManager manager )throws ServiceException</div><div class="line">    &#123;</div><div class="line">        finder = (MovieFinder)manager.lookup(&quot;finder&quot;);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>service方法就是接口注入的例子，它使容器可以将一个ServiceManager对象注入MyMovieLister对象。ServiceManager则是一个服务定位器。在这个例子中，MyMovieLister并不把ServiceManager对象保存在字段中，而是马上借助它找到MovieFinder 实例，并将后者保存起来。</p>
<h3 id="作出一个选择"><a href="#作出一个选择" class="headerlink" title="作出一个选择"></a>作出一个选择</h3><p>到现在为止，我一直在阐述自己对这两个模式（Dependency Injection模式和ServiceLocator模式）以及它们的变化形式的看法。现在，我要开始讨论他们的优点和缺点，以便指出它们各自适用的场景。</p>
<h4 id="Service-Locator-vs-Dependency-Injection"><a href="#Service-Locator-vs-Dependency-Injection" class="headerlink" title="Service Locator vs. Dependency Injection"></a>Service Locator vs. Dependency Injection</h4><p>首先，我们面临Service Locator和Dependency Injection之间的选择。应该注意，尽管我们前面那个简单的例子不足以表现出来，实际上这两个模式都提供了基本的解耦合能力。无论使用哪个模式，应用程序代码都不依赖于服务接口的具体实现。两者之间最重要的区别在于：具体实现以什么方式提供给应用程序代码。使用Service Locator模式时，应用程序代码直接向服务定位器发送一个消息，明确要求服务的实现；使用Dependency Injection模式时，应用程序代码不发出显式的请求，服务的实现自然会出现在应用程序代码中，这也就是所谓控制反转。</p>
<p>控制反转是框架的共同特征，但它也要求你付出一定的代价：它会增加理解的难度，并且给调试带来一定的困难。所以，整体来说，除非必要，否则我会尽量避免使用它。这并不意味着控制反转不好，只是我认为在很多时候使用一个更为直观的方案（例如Service Locator模式）会比较合适。</p>
<p>一个关键的区别在于：使用Service Locator模式时，服务的使用者必须依赖于服务定位器。定位器可以隐藏使用者对服务具体实现的依赖，但你必须首先看到定位器本身。所以，问题的答案就很明朗了：选择Service Locator还是Dependency Injection，取决于对定位器的依赖是否会给你带来麻烦。</p>
<p>Dependency Injection模式可以帮助你看清组件之间的依赖关系：你只需观察依赖注入的机制（例如构造函数），就可以掌握整个依赖关系。而使用Service Locator模式时，你就必须在源代码中到处搜索对服务定位器的调用。具备全文检索能力的IDE可以略微简化这一工作，但还是不如直接观察构造函数或者设值方法来得轻松。</p>
<p>这个选择主要取决于服务使用者的性质。如果你的应用程序中有很多不同的类要使用一个服务，那么应用程序代码对服务定位器的依赖就不是什么大问题。在前面的例子中，我要把MovieLister类交给朋友去用，这种情况下使用服务定位器就很好：我的朋友们只需要对定位器做一点配置（通过配置文件或者某些配置性的代码），使其提供合适的服务实现就可以了。在这种情况下，我看不出Dependency Injection模式提供的控制反转有什么吸引人的地方。但是，如果把MovieLister 看作一个组件，要将它提供给别人写的应用程序去使用，情况就不同了。在这种时候，我无法预测使用者会使用什么样的服务定位器API，每个使用者都可能有自己的服务定位器，而且彼此之间无法兼容。一种解决办法是为每项服务提供单独的接口，使用者可以编写一个适配器，让我的接口与他们的服务定位器相配合。但即便如此，我仍然需要到第一个服务定位器中寻找我规定的接口。而且一旦用上了适配器，服务定位器所提供的简单性就被大大削弱了。</p>
<p>另一方面，如果使用Dependency Injection模式，组件与注入器之间不会有依赖关系，因此组件无法从注入器那里获得更多的服务，只能获得配置信息中所提供的那些。这也是Dependency Injection 模式的局限性之一。</p>
<p>人们倾向于使用Dependency Injection模式的一个常见理由是：它简化了测试工作。这里的关键是：出于测试的需要，你必须能够轻松地在真实的服务实现与供测试用的伪组件之间切换。但是，如果单从这个角度来考虑，Dependency Injection模式和Service Locator模式其实并没有太大区别：两者都能够很好地支持伪组件的插入。之所以很多人有Dependency Injection模式更利于测试的印象，我猜是因为他们并没有努力保证服务定位器的可替换性。这正是持续测试起作用的地方：如果你不能轻松地用一些伪组件将一个服务架起来以便测试，这就意味着你的设计出现了严重的问题。</p>
<p>当然，如果组件环境具有非常强的侵略性（就像EJB框架那样），测试的问题会更加严重。我的观点是：应该尽量减少这类框架对应用程序代码的影响，特别是不要做任何可能使编辑-执行的循环变慢的事情。用插件（plugin）机制取代重量级组件会对测试过程有很大帮助，这正是测试驱动开发（Test Driven Development，TDD）之类实践的关键所在。</p>
<p>所以，主要的问题在于：代码的作者是否希望自己编写的组件能够脱离自己的控制、被使用在另一个应用程序中。如果答案是肯定的，那么他就不能对服务定位器做任何假设——哪怕最小的假设也会给使用者带来麻烦。</p>
<h4 id="构造函数注入-vs-设值方法注入"><a href="#构造函数注入-vs-设值方法注入" class="headerlink" title="构造函数注入 vs. 设值方法注入"></a>构造函数注入 vs. 设值方法注入</h4><p>在组合服务时，你总得遵循一定的约定，才可能将所有东西拼装起来。依赖注入的优点主要在于：它只需要非常简单的约定——至少对于构造函数注入和设值方法注入来说是这样。相比于这两者，接口注入的侵略性要强得多，比起Service Locator模式的优势也不那么明显。所以，如果你想要提供一个组件给多个使用者，构造函数注入和设值方法注入看起来很有吸引力。你不必在组件中加入什么希奇古怪的东西，注入器可以相当轻松地把所有东西配置起来。</p>
<p>设值函数注入和构造函数注入之间的选择相当有趣，因为它折射出面向对象编程的一些更普遍的问题：应该在哪里填充对象的字段，构造函数还是设值方法？</p>
<p>一直以来，我首选的做法是尽量在构造阶段就创建完整、合法的对象——也就是说，在构造函数中填充对象字段。这样做的好处可以追溯到Kent Beck在Smalltalk Best Practice Patterns一书中介绍的两个模式：Constructor Method和Constructor Parameter Method。带有参数的构造函数可以明确地告诉你如何创建一个合法的对象。如果创建合法对象的方式不止一种，你还可以提供多个构造函数，以说明不同的组合方式。</p>
<p>构造函数初始化的另一个好处是：你可以隐藏任何不可变的字段——只要不为它提供设值方法就行了。我认为这很重要：如果某个字段是不应该被改变的，没有针对该字段的设值方法就很清楚地说明了这一点。如果你通过设值方法完成初始化，暴露出来的设值方法很可能成为你心头永远的痛。（实际上，在这种时候我更愿意回避通常的设值方法约定，而是使用诸如initFoo之类的方法名，以表明该方法只应该在对象创建之初调用。）</p>
<p>不过，世事总有例外。如果参数太多，构造函数会显得凌乱不堪，特别是对于不支持关键字参数的语言更是如此。的确，如果构造函数参数列表太长，通常标志着对象太过繁忙，理应将其拆分成几个对象，但有些时候也确实需要那么多的参数。如果有不止一种的方式可以构造一个合法的对象，也很难通过构造函数描述这一信息，因为构造函数之间只能通过参数的个数和类型加以区分。这就是Factory Method模式适用的场合了，工厂方法可以借助多个私有构造函数和设值方法的组合来完成自己的任务。经典Factory Method模式的问题在于：它们往往以静态方法的形式出现，你无法在接口中声明它们。你可以创建一个工厂类，但那又变成另一个服务实体了。工厂服务是一种不错的技巧，但你仍然需要以某种方式实例化这个工厂对象，问题仍然没有解决。</p>
<p>如果要传入的参数是像字符串这样的简单类型，构造函数注入也会带来一些麻烦。使用设值方法注入时，你可以在每个设值方法的名字中说明参数的用途；而使用构造函数注入时，你只能靠参数的位置来决定每个参数的作用，而记住参数的正确位置显然要困难得多。</p>
<p>如果对象有多个构造函数，对象之间又存在继承关系，事情就会变得特别讨厌。为了让所有东西都正确地初始化，你必须将对子类构造函数的调用转发给超类的构造函数，然后处理自己的参数。这可能造成构造函数规模的进一步膨胀。</p>
<p>尽管有这些缺陷，但我仍然建议你首先考虑构造函数注入。不过，一旦前面提到的问题真的成了问题，你就应该准备转为使用设值方法注入。</p>
<p>在将Dependecy Injection 模式作为框架的核心部分的几支团队之间，构造函数注入还是设值方法注入引发了很多的争论。不过，现在看来，开发这些框架的大多数人都已经意识到：不管更喜欢哪种注入机制，同时为两者提供支持都是有必要的。</p>
<h4 id="代码配置-vs-配置文件"><a href="#代码配置-vs-配置文件" class="headerlink" title="代码配置 vs. 配置文件"></a>代码配置 vs. 配置文件</h4><p>另一个问题相对独立，但也经常与其他问题牵涉在一起：如何配置服务的组装，通过配置文件还是直接编码组装？对于大多数需要在多处部署的应用程序来说，一个单独的配置文件会更合适。配置文件几乎都是XML 文件，XML 也的确很适合这一用途。不过，有些时候直接在程序代码中实现装配会更简单。譬如一个简单的应用程序，也没有很多部署上的变化，这时用几句代码来配置就比XML 文件要清晰得多。</p>
<p>与之相对的，有时应用程序的组装非常复杂，涉及大量的条件步骤。一旦编程语言中的配置逻辑开始变得复杂，你就应该用一种合适的语言来描述配置信息，使程序逻辑变得更清晰。然后，你可以编写一个构造器（builder）类来完成装配工作。如果使用构造器的情景不止一种，你可以提供多个构造器类，然后通过一个简单的配置文件在它们之间选择。</p>
<p>我常常发现，人们太急于定义配置文件。编程语言通常会提供简捷而强大的配置管理机制，现代编程语言也可以将程序编译成小的模块，并将其插入大型系统中。如果编译过程会很费力，脚本语言也可以在这方面提供帮助。通常认为，配置文件不应该用编程语言来编写，因为它们需要能够被不懂编程的系统管理人员编辑。但是，这种情况出现的几率有多大呢？我们真的希望不懂编程的系统管理人员来改变一个复杂的服务器端应用程序的事务隔离等级吗？只有在非常简单的时候，非编程语言的配置文件才有最好的效果。如果配置信息开始变得复杂，就应该考虑选择一种合适的编程语言来编写配置文件。</p>
<p>在Java 世界里，我们听到了来自配置文件的不和谐音——每个组件都有它自己的配置文件，而且格式还各不相同。如果你要使用一打这样的组件，你就得维护一打的配置文件，那会很快让你烦死。</p>
<p>在这里，我的建议是：始终提供一种标准的配置方式，使程序员能够通过同一个编程接口轻松地完成配置工作。至于其他的配置文件，仅仅把它们当作一种可选的功能。借助这个编程接口，开发者可以轻松地管理配置文件。如果你编写了一个组件，则可以由组件的使用者来选择如何管理配置信息：使用你的编程接口、直接操作配置文件格式，或者定义他们自己的配置文件格式，并将其与你的编程接口相结合。</p>
<h4 id="分离配置与使用"><a href="#分离配置与使用" class="headerlink" title="分离配置与使用"></a>分离配置与使用</h4><p>所有这一切的关键在于：服务的配置应该与使用分开。实际上，这是一个基本的设计原则——分离接口与实现。在面向对象程序里，我们在一个地方用条件逻辑来决定具体实例化哪一个类，以后的条件分支都由多态来实现，而不是继续重复前面的条件逻辑，这就是分离接口与实现的原则。</p>
<p>如果对于一段代码而言，接口与实现的分离还只是有用的话，那么当你需要使用外部元素（例如组件和服务）时，它就是生死攸关的大事。这里的第一个问题是：你是否希望将选择具体实现类的决策推迟到部署阶段。如果是，那么你需要使用插入技术。使用了插入技术之后，插件的装配原则上是与应用程序的其余部分分开的，这样你就可以轻松地针对不同的部署替换不同的配置。这种配置机制可以通过服务定位器来实现（Service Locator模式），也可以借助依赖注入直接完成（Dependency Injection 模式）。</p>
<h3 id="更多的问题"><a href="#更多的问题" class="headerlink" title="更多的问题"></a>更多的问题</h3><p>在本文中，我关注的焦点是使用Dependency Injection模式和Service Locator模式进行服务配置的基本问题。还有一些与之相关的话题值得关注，但我已经没有时间继续深入下去了。特别值得注意的是生命周期行为的问题：某些组件具有特定的生命周期事件，例如停止、开始等等。另一个值得注意的问题是：越来越多的人对如何在这些容器中运用面向方面（aspectoriented）的思想产生了兴趣。尽管目前还没有认真准备过这方面的材料，但我也很希望以后能在这个话题上写一些东西。</p>
<p>关于这些问题，你在专注于轻量级容器的网站上可以找到很多资料。浏览PicoContainer（ <a href="http://www.picocontainer.org/" target="_blank" rel="external">http://www.picocontainer.org</a>）或者Spring（ <a href="http://www.springframework.org/" target="_blank" rel="external">http://www.springframework.org</a>）的网站，你可以找到大量相关的讨论，并由此引申出更多的话题。</p>
<h3 id="结论和思考"><a href="#结论和思考" class="headerlink" title="结论和思考"></a>结论和思考</h3><p>在时下流行的轻量级容器都使用了一个共同的模式来组装应用程序所需的服务，我把这个模式称为Dependency Injection，它可以有效地替代Service Locator模式。在开发应用程序时，两者不相上下，但我认为Service Locator模式略有优势，因为它的行为方式更为直观。但是，如果你开发的组件要交给多个应用程序去使用，那么Dependency Injection模式会是更好的选择。</p>
<p>如果你决定使用Dependency Injection模式，这里还有几种不同的风格可供选择。我建议你首先考虑构造函数注入；如果遇到了某些特定的问题，再改用设值方法注入。如果你要选择一个容器，在其之上进行开发，我建议你选择同时支持这两种注入方式的容器。</p>
<p>Service Locator 模式和Dependency Injection 模式之间的选择并是最重要的，更重要的是：应该将服务的配置和应用程序内部对服务的使用分离开。</p>
<h3 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h3><p>在此，我要向帮助我理解本文中所提到的问题、并对本文提出宝贵意见的几个人表示感谢，他们是Rod Johnson、Paul Hammant、Joe Walnes、Aslak Hellesoy、Jon Tirsen和Bill Caputo。另外，Berin Loritsch和Hamilton Verissimo de Oliveira在Avalon方面给了我非常有用的建议，一并向他们表示感谢。</p>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> Spring </tag>
            
            <tag> 框架 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Inversion of Control Containers and the Dependency Injection pattern]]></title>
      <url>/2017/07/26/IoC-And-DI/</url>
      <content type="html"><![CDATA[<p># </p>
<p>In the <a href="http://lib.csdn.net/base/java" target="_blank" rel="external">Java </a>community there’s been a rush of lightweight containers that help to assemble components from different projects into a cohesive application. Underlying these containers is a common pattern to how they perform the wiring, a concept they refer under the very generic name of “Inversion of Control”. In this article I dig into how this pattern works, under the more specific name of “Dependency Injection”, and contrast it with the Service Locator alternative. The choice between them is less important than the principle of separating configuration from use.</p>
<p>One of the entertaining things about the enterprise Java world is the huge amount of activity in building alternatives to the mainstream J2EE technologies, much of it happening in open source. A lot of this is a reaction to the heavyweight complexity in the mainstream J2EE world, but much of it is also exploring alternatives and coming up with creative ideas. A common issue to deal with is how to wire together different elements: how do you fit together this web controller architecture with that database interface backing when they were built by different teams with little knowledge of each other.A number of frameworks have taken a stab at this problem, and several are branching out to provide a general capability to assemble components from different layers. These are often referred to as lightweight containers, examples include <a href="http://picocontainer.com/" target="_blank" rel="external">PicoContainer</a>, and <a href="http://www.springsource.org/" target="_blank" rel="external">Spring</a>.</p>
<p>Underlying these containers are a number of interesting design principles, things that <a href="http://lib.csdn.net/base/go" target="_blank" rel="external">Go</a> beyond both these specific containers and indeed the <a href="http://lib.csdn.net/base/java" target="_blank" rel="external">java </a>platform. Here I want to start exploring some of these principles. The examples I use are in <a href="http://lib.csdn.net/base/java" target="_blank" rel="external">Java</a>, but like most of my writing the principles are equally applicable to other OO environments, particularly .NET.</p>
<hr>
<h2 id="Components-and-Services"><a href="#Components-and-Services" class="headerlink" title="Components and Services"></a>Components and Services</h2><p>The topic of wiring elements together drags me almost immediately into the knotty terminology problems that surround the terms service and component. You find long and contradictory articles on the definition of these things with ease. For my purposes here are my current uses of these overloaded terms.</p>
<p>I use component to mean a glob of software that’s intended to be used, without change, by an application that is out of the control of the writers of the component. By ‘without change’ I mean that the using application doesn’t change the source code of the components, although they may alter the component’s behavior by extending it in ways allowed by the component writers.</p>
<p>A service is similar to a component in that it’s used by foreign applications. The main difference is that I expect a component to be used locally (think jar file, assembly, dll, or a source import). A service will be used remotely through some remote interface, either synchronous or asynchronous (eg web service, messaging system, RPC, or socket.)</p>
<p>I mostly use service in this article, but much of the same logic can be applied to local components too. Indeed often you need some kind of local component framework to easily access a remote service. But writing “component or service” is tiring to read and write, and services are much more fashionable at the moment.</p>
<hr>
<h2 id="A-Naive-Example"><a href="#A-Naive-Example" class="headerlink" title="A Naive Example"></a>A Naive Example</h2><p>To help make all of this more concrete I’ll use a running example to talk about all of this. Like all of my examples it’s one of those super-simple examples; small enough to be unreal, but hopefully enough for you to visualize what’s going on without falling into the bog of a real example.</p>
<p>In this example I’m writing a component that provides a list of movies directed by a particular director. This stunningly useful function is implemented by a single method.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">class MovieLister...</div><div class="line">    public Movie[] moviesDirectedBy(String arg) &#123;</div><div class="line">        List allMovies = finder.findAll();</div><div class="line">        for (Iterator it = allMovies.iterator(); it.hasNext();) &#123;</div><div class="line">            Movie movie = (Movie) it.next();</div><div class="line">            if (!movie.getDirector().equals(arg)) it.remove();</div><div class="line">        &#125;</div><div class="line">        return (Movie[]) allMovies.toArray(new Movie[allMovies.size()]);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>The implementation of this function is naive in the extreme, it asks a finder object (which we’ll get to in a moment) to return every film it knows about. Then it just hunts through this list to return those directed by a particular director. This particular piece of naivety I’m not going to fix, since it’s just the scaffolding for the real point of this article.</p>
<p>The real point of this article is this finder object, or particularly how we connect the lister object with a particular finder object. The reason why this is interesting is that I want my wonderful <code>moviesDirectedBy</code> method to be completely independent of how all the movies are being stored. So all the method does is refer to a finder, and all that finder does is know how to respond to the <code>findAll</code> method. I can bring this out by defining an interface for the finder.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface MovieFinder &#123;</div><div class="line">    List findAll();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Now all of this is very well decoupled, but at some point I have to come up with a concrete class to actually come up with the movies. In this case I put the code for this in the constructor of my lister class.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class MovieLister...</div><div class="line">  private MovieFinder finder;</div><div class="line">  public MovieLister() &#123;</div><div class="line">    finder = new ColonDelimitedMovieFinder(&quot;movies1.txt&quot;);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>The name of the implementation class comes from the fact that I’m getting my list from a colon delimited text file. I’ll spare you the details, after all the point is just that there’s some implementation.</p>
<p>Now if I’m using this class for just myself, this is all fine and dandy. But what happens when my friends are overwhelmed by a desire for this wonderful functionality and would like a copy of my program? If they also store their movie listings in a colon delimited text file called “movies1.txt” then everything is wonderful. If they have a different name for their movies file, then it’s easy to put the name of the file in a properties file. But what if they have a completely different form of storing their movie listing: a SQL database, an XML file, a web service, or just another format of text file? In this case we need a different class to grab that data. Now because I’ve defined a <code>MovieFinder</code> interface, this won’t alter my <code>moviesDirectedBy</code> method. But I still need to have some way to get an instance of the right finder implementation into place.</p>
<p><img src="http://martinfowler.com/articles/naive.gif" alt="Figure 1"></p>
<p>Figure 1: The dependencies using a simple creation in the lister class</p>
<p><a href="http://martinfowler.com/articles/injection.html#naive.gif" target="_blank" rel="external">Figure 1</a> shows the dependencies for this situation. The <code>MovieLister</code> class is dependent on both the <code>MovieFinder</code> interface and upon the implementation. We would prefer it if it were only dependent on the interface, but then how do we make an instance to work with?</p>
<p>In my book <a href="http://martinfowler.com/books/eaa.html" target="_blank" rel="external">P of EAA</a>, we described this situation as a <a href="http://martinfowler.com/eaaCatalog/plugin.html" target="_blank" rel="external">Plugin</a>. The implementation class for the finder isn’t linked into the program at compile time, since I don’t know what my friends are going to use. Instead we want my lister to work with any implementation, and for that implementation to be plugged in at some later point, out of my hands. The problem is how can I make that link so that my lister class is ignorant of the implementation class, but can still talk to an instance to do its work.</p>
<p>Expanding this into a real system, we might have dozens of such services and components. In each case we can abstract our use of these components by talking to them through an interface (and using an adapter if the component isn’t designed with an interface in mind). But if we wish to deploy this system in different ways, we need to use plugins to handle the interaction with these services so we can use different implementations in different deployments.</p>
<p>So the core problem is how do we assemble these plugins into an application? This is one of the main problems that this new breed of lightweight containers face, and universally they all do it using Inversion of Control.</p>
<hr>
<h2 id="Inversion-of-Control"><a href="#Inversion-of-Control" class="headerlink" title="Inversion of Control"></a>Inversion of Control</h2><p>When these containers talk about how they are so useful because they implement “Inversion of Control” I end up very puzzled. <a href="http://martinfowler.com/bliki/InversionOfControl.html" target="_blank" rel="external">Inversion of control</a> is a common characteristic of frameworks, so saying that these lightweight containers are special because they use inversion of control is like saying my car is special because it has wheels.</p>
<p>The question, is what aspect of control are they inverting? When I first ran into inversion of control, it was in the main control of a user interface. Early user interfaces were controlled by the application program. You would have a sequence of commands like “Enter name”, “enter address”; your program would drive the prompts and pick up a response to each one. With graphical (or even screen based) UIs the UI framework would contain this main loop and your program instead provided event handlers for the various fields on the screen. The main control of the program was inverted, moved away from you to the framework.</p>
<p>For this new breed of containers the inversion is about how they lookup a plugin implementation. In my naive example the lister looked up the finder implementation by directly instantiating it. This stops the finder from being a plugin. The approach that these containers use is to ensure that any user of a plugin follows some convention that allows a separate assembler module to inject the implementation into the lister.</p>
<p>As a result I think we need a more specific name for this pattern. Inversion of Control is too generic a term, and thus people find it confusing. As a result with a lot of discussion with various IoC advocates we settled on the nameDependency Injection.</p>
<p>I’m going to start by talking about the various forms of dependency injection, but I’ll point out now that that’s not the only way of removing the dependency from the application class to the plugin implementation. The other pattern you can use to do this is Service Locator, and I’ll discuss that after I’m done with explaining Dependency Injection.</p>
<hr>
<h2 id="Forms-of-Dependency-Injection"><a href="#Forms-of-Dependency-Injection" class="headerlink" title="Forms of Dependency Injection"></a>Forms of Dependency Injection</h2><p>The basic idea of the Dependency Injection is to have a separate object, an assembler, that populates a field in the lister class with an appropriate implementation for the finder interface, resulting in a dependency diagram along the lines of <a href="http://martinfowler.com/articles/injection.html#injector.gif" target="_blank" rel="external">Figure 2</a></p>
<p><img src="http://martinfowler.com/articles/injector.gif" alt="Figure 2"></p>
<p>Figure 2: The dependencies for a Dependency Injector</p>
<p>There are three main styles of dependency injection. The names I’m using for them are Constructor Injection, Setter Injection, and Interface Injection. If you read about this stuff in the current discussions about Inversion of Control you’ll hear these referred to as type 1 IoC (interface injection), type 2 IoC (setter injection) and type 3 IoC (constructor injection). I find numeric names rather hard to remember, which is why I’ve used the names I have here.</p>
<h3 id="Constructor-Injection-with-PicoContainer"><a href="#Constructor-Injection-with-PicoContainer" class="headerlink" title="Constructor Injection with PicoContainer"></a>Constructor Injection with PicoContainer</h3><p>I’ll start with showing how this injection is done using a lightweight <a href="http://lib.csdn.net/base/docker" target="_blank" rel="external">Container</a> called <a href="http://picocontainer.com/" target="_blank" rel="external">PicoContainer</a>. I’m starting here primarily because several of my colleagues at ThoughtWorks are very active in the development of PicoContainer (yes, it’s a sort of corporate nepotism.)</p>
<p>PicoContainer uses a constructor to decide how to inject a finder implementation into the lister class. For this to work, the movie lister class needs to declare a constructor that includes everything it needs injected.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">class MovieLister...</div><div class="line">    public MovieLister(MovieFinder finder) &#123;</div><div class="line">        this.finder = finder;       </div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>The finder itself will also be managed by the pico container, and as such will have the filename of the text file injected into it by the container.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">class ColonMovieFinder...</div><div class="line">    public ColonMovieFinder(String filename) &#123;</div><div class="line">        this.filename = filename;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>The pico container then needs to be told which implementation class to associate with each interface, and which string to inject into the finder.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">private MutablePicoContainer configureContainer() &#123;</div><div class="line">    MutablePicoContainer pico = new DefaultPicoContainer();</div><div class="line">    Parameter[] finderParams =  &#123;new ConstantParameter(&quot;movies1.txt&quot;)&#125;;</div><div class="line">    pico.registerComponentImplementation(MovieFinder.class, ColonMovieFinder.class, finderParams);</div><div class="line">    pico.registerComponentImplementation(MovieLister.class);</div><div class="line">    return pico;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>This configuration code is typically set up in a different class. For our example, each friend who uses my lister might write the appropriate configuration code in some setup class of their own. Of course it’s common to hold this kind of configuration information in separate config files. You can write a class to read a config file and set up the container appropriately. Although PicoContainer doesn’t contain this functionality itself, there is a closely related project called NanoContainer that provides the appropriate wrappers to allow you to have XML configuration files. Such a nano container will parse the XML and then configure an underlying pico container. The philosophy of the project is to separate the config file format from the underlying mechanism.</p>
<p>To use the container you write code something like this.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public void testWithPico() &#123;</div><div class="line">    MutablePicoContainer pico = configureContainer();</div><div class="line">    MovieLister lister = (MovieLister) pico.getComponentInstance(MovieLister.class);</div><div class="line">    Movie[] movies = lister.moviesDirectedBy(&quot;Sergio Leone&quot;);</div><div class="line">    assertEquals(&quot;Once Upon a Time in the West&quot;, movies[0].getTitle());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Although in this example I’ve used constructor injection, PicoContainer also supports setter injection, although its developers do prefer constructor injection.</p>
<h3 id="Setter-Injection-with-Spring"><a href="#Setter-Injection-with-Spring" class="headerlink" title="Setter Injection with Spring"></a>Setter Injection with Spring</h3><p>The <a href="http://www.springsource.org/" target="_blank" rel="external">Spring framework</a> is a wide ranging framework for enterprise Java development. It includes abstraction layers for transactions, persistence frameworks, web application development and JDBC. Like PicoContainer it supports both constructor and setter injection, but its developers tend to prefer setter injection - which makes it an appropriate choice for this example.</p>
<p>To get my movie lister to accept the injection I define a setting method for that service</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class MovieLister...</div><div class="line">    private MovieFinder finder;</div><div class="line">  public void setFinder(MovieFinder finder) &#123;</div><div class="line">    this.finder = finder;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>Similarly I define a setter for the filename.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">class ColonMovieFinder...</div><div class="line">    public void setFilename(String filename) &#123;</div><div class="line">        this.filename = filename;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>The third step is to set up the configuration for the files. <a href="http://lib.csdn.net/base/javaee" target="_blank" rel="external">spring</a> supports configuration through XML files and also through code, but XML is the expected way to do it.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;beans&gt;</div><div class="line">    &lt;bean id=&quot;MovieLister&quot; class=&quot;spring.MovieLister&quot;&gt;</div><div class="line">        &lt;property name=&quot;finder&quot;&gt;</div><div class="line">            &lt;ref local=&quot;MovieFinder&quot;/&gt;</div><div class="line">        &lt;/property&gt;</div><div class="line">    &lt;/bean&gt;</div><div class="line">    &lt;bean id=&quot;MovieFinder&quot; class=&quot;spring.ColonMovieFinder&quot;&gt;</div><div class="line">        &lt;property name=&quot;filename&quot;&gt;</div><div class="line">            &lt;value&gt;movies1.txt&lt;/value&gt;</div><div class="line">        &lt;/property&gt;</div><div class="line">    &lt;/bean&gt;</div><div class="line">&lt;/beans&gt;</div></pre></td></tr></table></figure>
<p>The test then looks like this.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public void testWithSpring() throws Exception &#123;</div><div class="line">    ApplicationContext ctx = new FileSystemXmlApplicationContext(&quot;spring.xml&quot;);</div><div class="line">    MovieLister lister = (MovieLister) ctx.getBean(&quot;MovieLister&quot;);</div><div class="line">    Movie[] movies = lister.moviesDirectedBy(&quot;Sergio Leone&quot;);</div><div class="line">    assertEquals(&quot;Once Upon a Time in the West&quot;, movies[0].getTitle());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Interface-Injection"><a href="#Interface-Injection" class="headerlink" title="Interface Injection"></a>Interface Injection</h3><p>The third injection technique is to define and use interfaces for the injection.<a href="http://avalon.apache.org/" target="_blank" rel="external">Avalon</a> is an example of a framework that uses this technique in places. I’ll talk a bit more about that later, but in this case I’m going to use it with some simple sample code.</p>
<p>With this technique I begin by defining an interface that I’ll use to perform the injection through. Here’s the interface for injecting a movie finder into an object.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface InjectFinder &#123;</div><div class="line">    void injectFinder(MovieFinder finder);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>This interface would be defined by whoever provides the MovieFinder interface. It needs to be implemented by any class that wants to use a finder, such as the lister.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">class MovieLister implements InjectFinder...</div><div class="line">    public void injectFinder(MovieFinder finder) &#123;</div><div class="line">        this.finder = finder;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>I use a similar approach to inject the filename into the finder implementation.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface InjectFinderFilename &#123;</div><div class="line">    void injectFilename (String filename);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">class ColonMovieFinder implements MovieFinder, InjectFinderFilename......</div><div class="line">    public void injectFilename(String filename) &#123;</div><div class="line">        this.filename = filename;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>Then, as usual, I need some configuration code to wire up the implementations. For simplicity’s sake I’ll do it in code.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">class Tester...</div><div class="line">    private Container container;</div><div class="line"></div><div class="line">     private void configureContainer() &#123;</div><div class="line">       container = new Container();</div><div class="line">       registerComponents();</div><div class="line">       registerInjectors();</div><div class="line">       container.start();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>This configuration has two stages, registering components through lookup keys is pretty similar to the other examples.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class Tester...</div><div class="line">  private void registerComponents() &#123;</div><div class="line">    container.registerComponent(&quot;MovieLister&quot;, MovieLister.class);</div><div class="line">    container.registerComponent(&quot;MovieFinder&quot;, ColonMovieFinder.class);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>A new step is to register the injectors that will inject the dependent components. Each injection interface needs some code to inject the dependent object. Here I do this by registering injector objects with the container. Each injector object implements the injector interface.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class Tester...</div><div class="line">  private void registerInjectors() &#123;</div><div class="line">    container.registerInjector(InjectFinder.class, container.lookup(&quot;MovieFinder&quot;));</div><div class="line">    container.registerInjector(InjectFinderFilename.class, new FinderFilenameInjector());</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public interface Injector &#123;</div><div class="line">  public void inject(Object target);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>When the dependent is a class written for this container, it makes sense for the component to implement the injector interface itself, as I do here with the movie finder. For generic classes, such as the string, I use an inner class within the configuration code.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">class ColonMovieFinder implements Injector......</div><div class="line">  public void inject(Object target) &#123;</div><div class="line">    ((InjectFinder) target).injectFinder(this);        </div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class Tester...</div><div class="line">  public static class FinderFilenameInjector implements Injector &#123;</div><div class="line">    public void inject(Object target) &#123;</div><div class="line">      ((InjectFinderFilename)target).injectFilename(&quot;movies1.txt&quot;);      </div><div class="line">    &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>The tests then use the container.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">class IfaceTester...</div><div class="line">    public void testIface() &#123;</div><div class="line">      configureContainer();</div><div class="line">      MovieLister lister = (MovieLister)container.lookup(&quot;MovieLister&quot;);</div><div class="line">      Movie[] movies = lister.moviesDirectedBy(&quot;Sergio Leone&quot;);</div><div class="line">      assertEquals(&quot;Once Upon a Time in the West&quot;, movies[0].getTitle());</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>The container uses the declared injection interfaces to figure out the dependencies and the injectors to inject the correct dependents. (The specific container implementation I did here isn’t important to the technique, and I won’t show it because you’d only laugh.)</p>
<hr>
<h2 id="Using-a-Service-Locator"><a href="#Using-a-Service-Locator" class="headerlink" title="Using a Service Locator"></a>Using a Service Locator</h2><p>The key benefit of a Dependency Injector is that it removes the dependency that the <code>MovieLister</code> class has on the concrete <code>MovieFinder</code> implementation. This allows me to give listers to friends and for them to plug in a suitable implementation for their own environment. Injection isn’t the only way to break this dependency, another is to use a <a href="http://java.sun.com/blueprints/corej2eepatterns/Patterns/ServiceLocator.html" target="_blank" rel="external">service locator</a>.</p>
<p>The basic idea behind a service locator is to have an object that knows how to get hold of all of the services that an application might need. So a service locator for this application would have a method that returns a movie finder when one is needed. Of course this just shifts the burden a tad, we still have to get the locator into the lister, resulting in the dependencies of <a href="http://martinfowler.com/articles/injection.html#locator.gif" target="_blank" rel="external">Figure 3</a></p>
<p><img src="http://martinfowler.com/articles/locator.gif" alt="Figure 3"></p>
<p>Figure 3: The dependencies for a Service Locator</p>
<p>In this case I’ll use the ServiceLocator as a singleton <a href="http://martinfowler.com/eaaCatalog/registry.html" target="_blank" rel="external">Registry</a>. The lister can then use that to get the finder when it’s instantiated.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">class MovieLister...</div><div class="line">    MovieFinder finder = ServiceLocator.movieFinder();</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class ServiceLocator...</div><div class="line">    public static MovieFinder movieFinder() &#123;</div><div class="line">        return soleInstance.movieFinder;</div><div class="line">    &#125;</div><div class="line">    private static ServiceLocator soleInstance;</div><div class="line">    private MovieFinder movieFinder;</div></pre></td></tr></table></figure>
<p>As with the injection approach, we have to configure the service locator. Here I’m doing it in code, but it’s not hard to use a mechanism that would read the appropriate data from a configuration file.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">class Tester...</div><div class="line">    private void configure() &#123;</div><div class="line">        ServiceLocator.load(new ServiceLocator(new ColonMovieFinder(&quot;movies1.txt&quot;)));</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">class ServiceLocator...</div><div class="line">    public static void load(ServiceLocator arg) &#123;</div><div class="line">        soleInstance = arg;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public ServiceLocator(MovieFinder movieFinder) &#123;</div><div class="line">        this.movieFinder = movieFinder;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>Here’s the test code.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">class Tester...</div><div class="line">    public void testSimple() &#123;</div><div class="line">        configure();</div><div class="line">        MovieLister lister = new MovieLister();</div><div class="line">        Movie[] movies = lister.moviesDirectedBy(&quot;Sergio Leone&quot;);</div><div class="line">        assertEquals(&quot;Once Upon a Time in the West&quot;, movies[0].getTitle());</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>I’ve often heard the complaint that these kinds of service locators are a bad thing because they aren’t testable because you can’t substitute implementations for them. Certainly you can design them badly to get into this kind of trouble, but you don’t have to. In this case the service locator instance is just a simple data holder. I can easily create the locator with test implementations of my services.</p>
<p>For a more sophisticated locator I can subclass service locator and pass that subclass into the registry’s class variable. I can change the static methods to call a method on the instance rather accessing instance variables directly. I can provide thread specific locators by using thread specific storage. All of this can be done without changing clients of service locator.</p>
<p>A way to think of this is that service locator is a registry not a singleton. A singleton provides a simple way of implementing a registry, but that implementation decision is easily changed.</p>
<h3 id="Using-a-Segregated-Interface-for-the-Locator"><a href="#Using-a-Segregated-Interface-for-the-Locator" class="headerlink" title="Using a Segregated Interface for the Locator"></a>Using a Segregated Interface for the Locator</h3><p>One of the issues with the simple approach above, is that the MovieLister is dependent on the full service locator class, even though it only uses one service. We can reduce this by using a <a href="http://martinfowler.com/bliki/RoleInterface.html" target="_blank" rel="external">role interface</a>. That way, instead of using the full service locator interface, the lister can declare just the bit of interface it needs.</p>
<p>In this situation the provider of the lister would also provide a locator interface which it needs to get hold of the finder.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public interface MovieFinderLocator &#123;</div><div class="line">    public MovieFinder movieFinder();</div></pre></td></tr></table></figure>
<p>The locator then needs to implement this interface to provide access to a finder.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">MovieFinderLocator locator = ServiceLocator.locator();</div><div class="line">MovieFinder finder = locator.movieFinder();</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public static ServiceLocator locator() &#123;</div><div class="line">     return soleInstance;</div><div class="line"> &#125;</div><div class="line"> public MovieFinder movieFinder() &#123;</div><div class="line">     return movieFinder;</div><div class="line"> &#125;</div><div class="line"> private static ServiceLocator soleInstance;</div><div class="line"> private MovieFinder movieFinder;</div></pre></td></tr></table></figure>
<p>You’ll notice that since we want to use an interface, we can’t just access the services through static methods any more. We have to use the class to get a locator instance and then use that to get what we need.</p>
<h3 id="A-Dynamic-Service-Locator"><a href="#A-Dynamic-Service-Locator" class="headerlink" title="A Dynamic Service Locator"></a>A Dynamic Service Locator</h3><p>The above example was static, in that the service locator class has methods for each of the services that you need. This isn’t the only way of doing it, you can also make a dynamic service locator that allows you to stash any service you need into it and make your choices at runtime.</p>
<p>In this case, the service locator uses a map instead of fields for each of the services, and provides generic methods to get and load services.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">class ServiceLocator...</div><div class="line">    private static ServiceLocator soleInstance;</div><div class="line">    public static void load(ServiceLocator arg) &#123;</div><div class="line">        soleInstance = arg;</div><div class="line">    &#125;</div><div class="line">    private Map services = new HashMap();</div><div class="line">    public static Object getService(String key)&#123;</div><div class="line">        return soleInstance.services.get(key);</div><div class="line">    &#125;</div><div class="line">    public void loadService (String key, Object service) &#123;</div><div class="line">        services.put(key, service);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>Configuring involves loading a service with an appropriate key.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class Tester...</div><div class="line">    private void configure() &#123;</div><div class="line">        ServiceLocator locator = new ServiceLocator();</div><div class="line">        locator.loadService(&quot;MovieFinder&quot;, new ColonMovieFinder(&quot;movies1.txt&quot;));</div><div class="line">        ServiceLocator.load(locator);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>I use the service by using the same key string.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">class MovieLister...</div><div class="line">    MovieFinder finder = (MovieFinder) ServiceLocator.getService(&quot;MovieFinder&quot;);</div></pre></td></tr></table></figure>
<p>On the whole I dislike this approach. Although it’s certainly flexible, it’s not very explicit. The only way I can find out how to reach a service is through textual keys. I prefer explicit methods because it’s easier to find where they are by looking at the interface definitions.</p>
<h3 id="Using-both-a-locator-and-injection-with-Avalon"><a href="#Using-both-a-locator-and-injection-with-Avalon" class="headerlink" title="Using both a locator and injection with Avalon"></a>Using both a locator and injection with Avalon</h3><p>Dependency injection and a service locator aren’t necessarily mutually exclusive concepts. A good example of using both together is the Avalon framework. Avalon uses a service locator, but uses injection to tell components where to find the locator.</p>
<p>Berin Loritsch sent me this simple version of my running example using Avalon.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public class MyMovieLister implements MovieLister, Serviceable &#123;</div><div class="line">    private MovieFinder finder;</div><div class="line"></div><div class="line">    public void service( ServiceManager manager ) throws ServiceException &#123;</div><div class="line">        finder = (MovieFinder)manager.lookup(&quot;finder&quot;);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>The service method is an example of interface injection, allowing the container to inject a service manager into MyMovieLister. The service manager is an example of a service locator. In this example the lister doesn’t store the manager in a field, instead it immediately uses it to lookup the finder, which it does store.</p>
<hr>
<h2 id="Deciding-which-option-to-use"><a href="#Deciding-which-option-to-use" class="headerlink" title="Deciding which option to use"></a>Deciding which option to use</h2><p>So far I’ve concentrated on explaining how I see these patterns and their variations. Now I can start talking about their pros and cons to help figure out which ones to use and when.</p>
<h3 id="Service-Locator-vs-Dependency-Injection"><a href="#Service-Locator-vs-Dependency-Injection" class="headerlink" title="Service Locator vs Dependency Injection"></a>Service Locator vs Dependency Injection</h3><p>The fundamental choice is between Service Locator and Dependency Injection. The first point is that both implementations provide the fundamental decoupling that’s missing in the naive example - in both cases application code is independent of the concrete implementation of the service interface. The important difference between the two patterns is about how that implementation is provided to the application class. With service locator the application class asks for it explicitly by a message to the locator. With injection there is no explicit request, the service appears in the application class - hence the inversion of control.</p>
<p>Inversion of control is a common feature of frameworks, but it’s something that comes at a price. It tends to be hard to understand and leads to problems when you are trying to debug. So on the whole I prefer to avoid it unless I need it. This isn’t to say it’s a bad thing, just that I think it needs to justify itself over the more straightforward alternative.</p>
<p>The key difference is that with a Service Locator every user of a service has a dependency to the locator. The locator can hide dependencies to other implementations, but you do need to see the locator. So the decision between locator and injector depends on whether that dependency is a problem.</p>
<p>Using dependency injection can help make it easier to see what the component dependencies are. With dependency injector you can just look at the injection mechanism, such as the constructor, and see the dependencies. With the service locator you have to search the source code for calls to the locator. Modern IDEs with a find references feature make this easier, but it’s still not as easy as looking at the constructor or setting methods.</p>
<p>A lot of this depends on the nature of the user of the service. If you are building an application with various classes that use a service, then a dependency from the application classes to the locator isn’t a big deal. In my example of giving a Movie Lister to my friends, then using a service locator works quite well. All they need to do is to configure the locator to hook in the right service implementations, either through some configuration code or through a configuration file. In this kind of scenario I don’t see the injector’s inversion as providing anything compelling.</p>
<p>The difference comes if the lister is a component that I’m providing to an application that other people are writing. In this case I don’t know much about the APIs of the service locators that my customers are going to use. Each customer might have their own incompatible service locators. I can get around some of this by using the segregated interface. Each customer can write an adapter that matches my interface to their locator, but in any case I still need to see the first locator to lookup my specific interface. And once the adapter appears then the simplicity of the direct connection to a locator is beginning to slip.</p>
<p>Since with an injector you don’t have a dependency from a component to the injector, the component cannot obtain further services from the injector once it’s been configured.</p>
<p>A common reason people give for preferring dependency injection is that it makes testing easier. The point here is that to do testing, you need to easily replace real service implementations with stubs or mocks. However there is really no difference here between dependency injection and service locator: both are very amenable to stubbing. I suspect this observation comes from projects where people don’t make the effort to ensure that their service locator can be easily substituted. This is where continual testing helps, if you can’t easily stub services for testing, then this implies a serious problem with your design.</p>
<p>Of course the testing problem is exacerbated by component environments that are very intrusive, such as Java’s EJB framework. My view is that these kinds of frameworks should minimize their impact upon application code, and particularly should not do things that slow down the edit-execute cycle. Using plugins to substitute heavyweight components does a lot to help this process, which is vital for practices such as Test Driven Development.</p>
<p>So the primary issue is for people who are writing code that expects to be used in applications outside of the control of the writer. In these cases even a minimal assumption about a Service Locator is a problem.</p>
<h3 id="Constructor-versus-Setter-Injection"><a href="#Constructor-versus-Setter-Injection" class="headerlink" title="Constructor versus Setter Injection"></a>Constructor versus Setter Injection</h3><p>For service combination, you always have to have some convention in order to wire things together. The advantage of injection is primarily that it requires very simple conventions - at least for the constructor and setter injections. You don’t have to do anything odd in your component and it’s fairly straightforward for an injector to get everything configured.</p>
<p>Interface injection is more invasive since you have to write a lot of interfaces to get things all sorted out. For a small set of interfaces required by the container, such as in Avalon’s approach, this isn’t too bad. But it’s a lot of work for assembling components and dependencies, which is why the current crop of lightweight containers <a href="http://lib.csdn.net/base/go" target="_blank" rel="external">go</a> with setter and constructor injection.</p>
<p>The choice between setter and constructor injection is interesting as it mirrors a more general issue with object-oriented programming - should you fill fields in a constructor or with setters.</p>
<p>My long running default with objects is as much as possible, to create valid objects at construction time. This advice goes back to Kent Beck’s <a href="http://www.amazon.com/gp/product/013476904X?ie=UTF8&amp;tag=martinfowlerc-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=013476904X" target="_blank" rel="external">Smalltalk Best Practice Patterns</a>: Constructor Method and Constructor Parameter Method. Constructors with parameters give you a clear statement of what it means to create a valid object in an obvious place. If there’s more than one way to do it, create multiple constructors that show the different combinations.</p>
<p>Another advantage with constructor initialization is that it allows you to clearly hide any fields that are immutable by simply not providing a setter. I think this is important - if something shouldn’t change then the lack of a setter communicates this very well. If you use setters for initialization, then this can become a pain. (Indeed in these situations I prefer to avoid the usual setting convention, I’d prefer a method like <code>initFoo</code>, to stress that it’s something you should only do at birth.)</p>
<p>But with any situation there are exceptions. If you have a lot of constructor parameters things can look messy, particularly in languages without keyword parameters. It’s true that a long constructor is often a sign of an over-busy object that should be split, but there are cases when that’s what you need.</p>
<p>If you have multiple ways to construct a valid object, it can be hard to show this through constructors, since constructors can only vary on the number and type of parameters. This is when Factory Methods come into play, these can use a combination of private constructors and setters to implement their work. The problem with classic Factory Methods for components assembly is that they are usually seen as static methods, and you can’t have those on interfaces. You can make a factory class, but then that just becomes another service instance. A factory service is often a good tactic, but you still have to instantiate the factory using one of the techniques here.</p>
<p>Constructors also suffer if you have simple parameters such as strings. With setter injection you can give each setter a name to indicate what the string is supposed to do. With constructors you are just relying on the position, which is harder to follow.</p>
<p>If you have multiple constructors and inheritance, then things can get particularly awkward. In order to initialize everything you have to provide constructors to forward to each superclass constructor, while also adding you own arguments. This can lead to an even bigger explosion of constructors.</p>
<p>Despite the disadvantages my preference is to start with constructor injection, but be ready to switch to setter injection as soon as the problems I’ve outlined above start to become a problem.</p>
<p>This issue has led to a lot of debate between the various teams who provide dependency injectors as part of their frameworks. However it seems that most people who build these frameworks have realized that it’s important to support both mechanisms, even if there’s a preference for one of them.</p>
<h3 id="Code-or-configuration-files"><a href="#Code-or-configuration-files" class="headerlink" title="Code or configuration files"></a>Code or configuration files</h3><p>A separate but often conflated issue is whether to use configuration files or code on an API to wire up services. For most applications that are likely to be deployed in many places, a separate configuration file usually makes most sense. Almost all the time this will be an XML file, and this makes sense. However there are cases where it’s easier to use program code to do the assembly. One case is where you have a simple application that’s not got a lot of deployment variation. In this case a bit of code can be clearer than a separate XML file.</p>
<p>A contrasting case is where the assembly is quite complex, involving conditional steps. Once you start getting close to programming language then XML starts breaking down and it’s better to use a real language that has all the syntax to write a clear program. You then write a builder class that does the assembly. If you have distinct builder scenarios you can provide several builder classes and use a simple configuration file to select between them.</p>
<p>I often think that people are over-eager to define configuration files. Often a programming language makes a straightforward and powerful configuration mechanism. Modern languages can easily compile small assemblers that can be used to assemble plugins for larger systems. If compilation is a pain, then there are scripting languages that can work well also.</p>
<p>It’s often said that configuration files shouldn’t use a programing language because they need to be edited by non-programmers. But how often is this the case? Do people really expect non-programmers to alter the transaction isolation levels of a complex server-side application? Non-language configuration files work well only to the extent they are simple. If they become complex then it’s time to think about using a proper programming language.</p>
<p>One thing we’re seeing in the Java world at the moment is a cacophony of configuration files, where every component has its own configuration files which are different to everyone else’s. If you use a dozen of these components, you can easily end up with a dozen configuration files to keep in sync.</p>
<p>My advice here is to always provide a way to do all configuration easily with a programmatic interface, and then treat a separate configuration file as an optional feature. You can easily build configuration file handling to use the programmatic interface. If you are writing a component you then leave it up to your user whether to use the programmatic interface, your configuration file format, or to write their own custom configuration file format and tie it into the programmatic interface</p>
<h3 id="Separating-Configuration-from-Use"><a href="#Separating-Configuration-from-Use" class="headerlink" title="Separating Configuration from Use"></a>Separating Configuration from Use</h3><p>The important issue in all of this is to ensure that the configuration of services is separated from their use. Indeed this is a fundamental design principle that sits with the separation of interfaces from implementation. It’s something we see within an object-oriented program when conditional logic decides which class to instantiate, and then future evaluations of that conditional are done through polymorphism rather than through duplicated conditional code.</p>
<p>If this separation is useful within a single code base, it’s especially vital when you’re using foreign elements such as components and services. The first question is whether you wish to defer the choice of implementation class to particular deployments. If so you need to use some implementation of plugin. Once you are using plugins then it’s essential that the assembly of the plugins is done separately from the rest of the application so that you can substitute different configurations easily for different deployments. How you achieve this is secondary. This configuration mechanism can either configure a service locator, or use injection to configure objects directly.</p>
<hr>
<h2 id="Some-further-issues"><a href="#Some-further-issues" class="headerlink" title="Some further issues"></a>Some further issues</h2><p>In this article, I’ve concentrated on the basic issues of service configuration using Dependency Injection and Service Locator. There are some more topics that play into this which also deserve attention, but I haven’t had time yet to dig into. In particular there is the issue of life-cycle behavior. Some components have distinct life-cycle events: stop and starts for instance. Another issue is the growing interest in using aspect oriented ideas with these containers. Although I haven’t considered this material in the article at the moment, I do hope to write more about this either by extending this article or by writing another.</p>
<p>You can find out a lot more about these ideas by looking at the web sites devoted to the lightweight containers. Surfing from the <a href="http://picocontainer.com/" target="_blank" rel="external">picocontainer</a> and <a href="http://www.springsource.org/" target="_blank" rel="external">spring</a>web sites will lead to you into much more discussion of these issues and a start on some of the further issues.</p>
<hr>
<h2 id="Concluding-Thoughts"><a href="#Concluding-Thoughts" class="headerlink" title="Concluding Thoughts"></a>Concluding Thoughts</h2><p>The current rush of lightweight containers all have a common underlying pattern to how they do service assembly - the dependency injector pattern. Dependency Injection is a useful alternative to Service Locator. When building application classes the two are roughly equivalent, but I think Service Locator has a slight edge due to its more straightforward behavior. However if you are building classes to be used in multiple applications then Dependency Injection is a better choice.</p>
<p>If you use Dependency Injection there are a number of styles to choose between. I would suggest you follow constructor injection unless you run into one of the specific problems with that approach, in which case switch to setter injection. If you are choosing to build or obtain a container, look for one that supports both constructor and setter injection.</p>
<p>The choice between Service Locator and Dependency Injection is less important than the principle of separating service configuration from the use of services within an application.</p>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> Spring </tag>
            
            <tag> 框架 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ProcessOn with me]]></title>
      <url>/2017/07/26/processon/</url>
      <content type="html"><![CDATA[<h1 id="ProcessOn简介"><a href="#ProcessOn简介" class="headerlink" title="ProcessOn简介"></a>ProcessOn简介</h1><p><img src="\imgs\processon\processon.png" alt="processon"><br><a href="https://www.processon.com" target="_blank" rel="external"><br><img src="https://www.processon.com/assets/imgs/logo_small.png" style="zoom:20%"><br></a><strong>是一个在线作图工具的聚合平台，它可以在线画流程图、思维导图、UI原型图、UML、网络拓扑图、组织结构图等等，您无需担心下载和更新的问题，不管Mac还是Windows，一个浏览器就可以随时随地的发挥创意，规划工作.</strong> </p>
<h1 id="个人经历"><a href="#个人经历" class="headerlink" title="个人经历"></a>个人经历</h1><p>​    从最早接触思维导图算起, 应该是在大二那时. 那时的我, 发现无论是知识总结还是演讲提纲前期的准备, 利用作图的方式, 学习效率将会极大地提高. 因为思维导图是从问题的本质, 本原为起点和终点进行思考. 思维可视化的形式依不同问题的性质而自由变化和创造, 不必拘泥于思维导图的结构和风格. </p>
<p>​    这一点极大地激发了我对其兴趣, 便开始找相关的工具. 期间用过Mindjet MindManager, XMind, 以及亿图图示. 然而虽然自身是计算机专业出生, 但我并不在意作图工具的专业性. 思维导图也好, 逻辑图也罢, 都是帮助我们从抽象中来, 到具象中去的方法, 因此我反而追求简洁与高效. 而当时我用的那几款软件却十分地专业与复杂, 仅仅针对于某一方面作图, 且跨平台性也很差. 总之, 想要做好优秀的图示, 必须对软件运用得非常熟悉才行, 这便导致我的需求不能得到满足.</p>
<p>​    大三时由于课程, 项目的需要, 需要制作各种类型的图示. 而这时, 偶然间在知乎上发现有人推荐<code>ProcessOn</code>, 号称是一个在线作图工具的聚合平台. 果然是”好奇心害死猫”, 当我打开官网浏览简介时, 查看的过程中便有种相见恨晚的感觉, 于是毫不犹豫地暗道: “就它了”.</p>
<p>​    接下来的时间段里用它制作过网络拓扑图, 软件开发用例图, 数据流图, 数据库设计ER图等等. <code>ProcessOn</code>的易用性也是不言而喻的, 在作图的过程中, 逐渐了解各种操作, 使得作图的效率得到了很大的提高. 而令人更赞的是, ProcessOn支持在线多人协作, 且支持多种文件导出方式, 我便毫不犹豫地便拉小伙伴来到了这里……</p>
<p><strong><em>部分个人作图展示</em></strong><img src="\imgs\processon\production.png" alt="production"></p>
<p>本计划通过制作<code>GIF</code> 来展示ProcessOn其惊艳的各种高效操作, 特性的. 但由于在写作该文章时处于无网络环境, 外加白天实习没有多余的时间去制作, 构思, 且前段时间已经看到有其他作者总结的非常优秀的文章, 故此作罢. </p>
<p>接下来便开始大致介绍一下ProcessOn的几大特性, 也欢迎大家的加入~</p>
<h1 id="ProcessOn特性"><a href="#ProcessOn特性" class="headerlink" title="ProcessOn特性"></a>ProcessOn特性</h1><h2 id="1-高效易用、轻松绘制"><a href="#1-高效易用、轻松绘制" class="headerlink" title="1.高效易用、轻松绘制"></a>1.高效易用、轻松绘制</h2><p>简易的操作, 使致不需要掌握什么帮组文档, 使用教程等, 只需打开浏览器, 便可以轻松作图, 享受绘制的过程</p>
<p><img src="\imgs\processon\图形管理.png" alt="图形管理"></p>
<h2 id="2-团队协作、头脑风暴"><a href="#2-团队协作、头脑风暴" class="headerlink" title="2.团队协作、头脑风暴"></a>2.团队协作、头脑风暴</h2><p><code>ProcessOn</code>提供团队协作的方式, 允许创建小组, 进行团队分工与合作. 在编辑的同时, 可以查看他人作图的进展状况, 并随时可以进行评论及修改 </p>
<p> <img src="\imgs\processon\小组动态.png" alt="小组动态"></p>
<h2 id="3-海量图库，知识分享"><a href="#3-海量图库，知识分享" class="headerlink" title="3.海量图库，知识分享"></a>3.海量图库，知识分享</h2><p><code>ProcessOn</code>提供丰富的图库以及各种模板, 总有某一个方面能够给予你创作灵感. 与此同时, 你也可以分享你的优质作图, 还可以赚取文件数哦</p>
<p><img src="\imgs\processon\模板.png" alt="模板"></p>
<h2 id="4-跨平台性-一处创建-随处编辑"><a href="#4-跨平台性-一处创建-随处编辑" class="headerlink" title="4.跨平台性, 一处创建, 随处编辑"></a>4.跨平台性, 一处创建, 随处编辑</h2><p>由于是基于Web端的, 这便使<code>ProcessOn</code>具有良好的跨平台性, 一切已作修改的数据即刻同步在云服务器, 不必担心数据的丢失, 且可以在不同的平台上随时浏览, 编辑. 如下便是手机端的截图</p>
<p><img src="\imgs\processon\Screenshot_2017-07-26-21-57-04.png" alt="Screenshot_2017-07-26-21-57-04"></p>
<h1 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h1><p>由于其易用性很好, 就不必再细致说明各种便捷的操作技巧及使用教程, 当然, 若是需要的话, 可以查看官方的 <strong><a href="https://www.processon.com/support" target="_blank" rel="external">帮助文档</a>.</strong>(各种操作编写得很细致), 相信你也会对其一见倾心的~ .</p>
<p>官网地址:<a href="https://www.processon.com" target="_blank" rel="external"><br><img src="https://www.processon.com/assets/imgs/logo_small.png" style="zoom:20%"><br></a></p>
<p><img src="\imgs\processon\帮助文档.png" alt="帮助文档"></p>
<p>最后, 附加一个活动(有截止时间, 学生党快来参加吧~):</p>
<p> <img src="\imgs\processon\action.png" alt="action"></p>
]]></content>
      
        <categories>
            
            <category> 生活 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 体验 </tag>
            
            <tag> 生活 </tag>
            
            <tag> 产品 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[IntelliJIDEA Getting+Started+with+Spring+MVC,+Hibernate+and+JSON]]></title>
      <url>/2017/07/25/Getting-Started-with-Spring-MVC-Hibernate-and-JSON/</url>
      <content type="html"><![CDATA[<h1 id="IntelliJIDEA-Getting-Started-with-Spring-MVC-Hibernate-and-JSON"><a href="#IntelliJIDEA-Getting-Started-with-Spring-MVC-Hibernate-and-JSON" class="headerlink" title="IntelliJIDEA Getting+Started+with+Spring+MVC,+Hibernate+and+JSON"></a>IntelliJIDEA Getting+Started+with+Spring+MVC,+Hibernate+and+JSON</h1><p>作者:  HackerVirus </p>
<p>发布时间:2015-07-08 18:37:49                         </p>
<p><a href="https://confluence.jetbrains.com/display/IntelliJIDEA/Getting+Started+with+Spring+MVC,+Hibernate+and+JSON" target="_blank" rel="external">https://confluence.jetbrains.com/display/IntelliJIDEA/Getting+Started+with+Spring+MVC,+Hibernate+and+JSON</a></p>
<p>In this tutorial we will create a simple web application using <strong>Spring MVC</strong>, <strong>Hibernate</strong> and <strong>JSON</strong>. We will use Maven to manage dependencies and <strong>IntelliJ IDEA</strong> to create, run and debug an application on local <strong>Tomcat</strong> application server.</p>
<h3 id="1-Create-a-project"><a href="#1-Create-a-project" class="headerlink" title="1. Create a project"></a>1. Create a project</h3><p>Open Project Wizard and select Spring MVC in Spring section. If you have already configured the application server, you can select it in theApplication Server field. With <strong>IntelliJ IDEA</strong> you can deploy applications to <strong>Tomcat</strong>, <strong>TomEE</strong>, <strong>Glassfish</strong>, <strong>JBoss</strong>, <strong>WebSphere</strong>, <strong>Jetty</strong>,<strong>Geronimo</strong>, <strong>Resin</strong>, <strong>Cloud Foundry</strong> and <strong>CloudBees</strong>.</p>
<p><img src="https://confluence.jetbrains.com/download/attachments/51186020/mvc_new.png?version=1&amp;modificationDate=1364888534000" alt="img"></p>
<p>Change Project name, Project location and Base package if necessary. The IDE will create a “Hello world” project with a simple controller and view.</p>
<p><img src="https://confluence.jetbrains.com/download/attachments/51186020/mvc_project.png?version=1&amp;modificationDate=1364888547000" alt="img"></p>
<p>The new project comes with <strong>Maven</strong>‘s pom.xml file. You can manage project dependencies through this file or through the dedicated Maventool window.</p>
<p><img src="https://confluence.jetbrains.com/download/attachments/51186020/mvc_maven.png?version=1&amp;modificationDate=1364888534000" alt="img"></p>
<p>When you change <strong>Maven</strong>‘s dependencies, <strong>IntelliJ IDEA</strong> applies the corresponding changes to the project automatically. You can check it in the<br>Project Structure → Modules dialog.</p>
<p><img src="https://confluence.jetbrains.com/download/attachments/51186020/mvc_module.png?version=1&amp;modificationDate=1364888534000" alt="img"></p>
<p>Besides dependencies, <strong>IntelliJ IDEA</strong> also imports the artifacts definition from pom.xml. You can check the artifacts settings in the<br>Project Structure → Artifacts dialog.</p>
<p><img src="https://confluence.jetbrains.com/download/attachments/51186020/mvc_artifacts.png?version=1&amp;modificationDate=1364888515000" alt="img"></p>
<p>The artifacts define the structure of what will be deployed to the application server when you click Run → Run ‘Tomcat 7.0’.</p>
<h3 id="2-Create-run-configuration"><a href="#2-Create-run-configuration" class="headerlink" title="2. Create run configuration"></a>2. Create run configuration</h3><p>If you haven’t specified Application server in Project Wizard you can do it now via Run → Edit Configurations….</p>
<p><img src="https://confluence.jetbrains.com/download/attachments/51186020/mvc_run_configuration.png?version=1&amp;modificationDate=1364888547000" alt="img"></p>
<p>Don’t forget to specify the artifacts to deploy for this run configuration via the<br>Deployment tab.</p>
<p><img src="https://confluence.jetbrains.com/download/attachments/51186020/mvc_run_configuration_deployment.png?version=1&amp;modificationDate=1364888547000" alt="img"></p>
<p>If you have configured at least one run configuration for an application server, <strong>IntelliJ IDEA</strong> shows the Application Servers tool window to manage the application state on the application server. You can see the list of application servers, start or stop servers, see deployed applications, manage artifacts to deploy, and manage the application state.</p>
<p><img src="https://confluence.jetbrains.com/download/attachments/51186020/mvc_application_servers.png?version=1&amp;modificationDate=1364888515000" alt="img"></p>
<h3 id="3-Run-the-application"><a href="#3-Run-the-application" class="headerlink" title="3. Run the application"></a>3. Run the application</h3><p>After the artifacts and run configurations are defined, you can deploy the application by simply running your configuration or via a shortcut right from the Application Servers tool window.</p>
<p><img src="https://confluence.jetbrains.com/download/attachments/51186020/mvc_hello_world.png?version=1&amp;modificationDate=1364888515000" alt="img"></p>
<h3 id="4-Add-dependencies"><a href="#4-Add-dependencies" class="headerlink" title="4. Add dependencies"></a>4. Add dependencies</h3><p>Since we are going to create a database for our application, we need <strong>Spring Data</strong>, <strong>Hibernate</strong> and <strong>HSQLDB</strong> libraries. In order to implement JSON API for our application we need <strong>JSON</strong> library. Finally, we will need <strong>JSTL</strong> library to use in application’s view.</p>
<p>We have to define all these dependencies in our pom.xml file. The IDE will automatically download the corresponding libraries and add to the artifact.</p>
<h3 id="5-Create-persistence-xml"><a href="#5-Create-persistence-xml" class="headerlink" title="5. Create persistence.xml"></a>5. Create persistence.xml</h3><p>Now let’s define resources/META-INF/persistence.xml file to initialize <strong>Hibernate</strong>‘s entity manager over <strong>JPA</strong>.</p>
<h3 id="6-Define-model-classes"><a href="#6-Define-model-classes" class="headerlink" title="6. Define model classes"></a>6. Define model classes</h3><p>Define a model class for user entity using <strong>JPA</strong> annotations.</p>
<p>Define a <strong>Spring</strong> repository for the user entity.</p>
<h3 id="7-Register-repository-entity-manager-factory-and-transaction-manager"><a href="#7-Register-repository-entity-manager-factory-and-transaction-manager" class="headerlink" title="7. Register repository, entity manager factory and transaction manager"></a>7. Register repository, entity manager factory and transaction manager</h3><p>Now we have to register the user repository, an entity manager factory and a transaction manager in webapp/WEB-INF/mvc-dispatcher-servlet.xmlfile.</p>
<p>The model for our application is ready, so we can implement the controller.</p>
<h3 id="8-Define-controller"><a href="#8-Define-controller" class="headerlink" title="8. Define controller"></a>8. Define controller</h3><p>Let’s rename HelloController to UserController and add the following code:</p>
<p>As you can see, we have defined three methods for listing, adding and deleting user entities. The methods are mapped to the corresponding URLs.</p>
<h3 id="9-Define-view"><a href="#9-Define-view" class="headerlink" title="9. Define view"></a>9. Define view</h3><p>Let’s rename hello view (and corresponding hello.jsp file) to users (and users.jsp , respectively). If you rename the view name from usage,<strong>IntelliJ IDEA</strong> applies the corresponding changes to JSP files automatically.</p>
<h3 id="10-Run-the-application"><a href="#10-Run-the-application" class="headerlink" title="10. Run the application"></a>10. Run the application</h3><p>The application should be ready now.</p>
<p><img src="https://confluence.jetbrains.com/download/attachments/51186020/mvc_application.png?version=1&amp;modificationDate=1364888515000" alt="img"></p>
<h3 id="11-Debug-application"><a href="#11-Debug-application" class="headerlink" title="11. Debug application"></a>11. Debug application</h3><p>If you need to debug your application, just add a breakpoint and re-run the application in debug mode via Run → Debug ‘Tomcat 7.0’….</p>
<p><img src="https://confluence.jetbrains.com/download/attachments/51186020/mvc_debug.png?version=1&amp;modificationDate=1364888515000" alt="img"></p>
<h3 id="12-Add-JSON-API"><a href="#12-Add-JSON-API" class="headerlink" title="12. Add JSON API"></a>12. Add JSON API</h3><p>Finally, let’s output the created users via JSON by implementing this simple Controller’s method:</p>
<p>Run the application and open <a href="undefined">http://localhost:8080/api/users</a>.</p>
<p><img src="https://confluence.jetbrains.com/download/attachments/51186020/mvc_json.png?version=1&amp;modificationDate=1364888534000" alt="img">                                   </p>
<p>​     </p>
<p>​                     </p>
<p>Download the final code and <strong>IntelliJ IDEA</strong>‘s project files from <a href="undefined">GitHub</a>.</p>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> Spring </tag>
            
            <tag> 框架 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[关于Spring中的<context:annotation-config/>配置(开启注解)]]></title>
      <url>/2017/07/25/about-spring-annotation-config/</url>
      <content type="html"><![CDATA[<p>当我们需要使用BeanPostProcessor时，直接在Spring配置文件中定义这些Bean显得比较笨拙，例如：</p>
<ul>
<li>使用<code>@Autowired</code>注解，必须事先在Spring容器中声明AutowiredAnnotationBeanPostProcessor的Bean：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;bean class=&quot;org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor &quot;/&gt;</div></pre></td></tr></table></figure>
<ul>
<li>使用 <code>@Required</code>注解，就必须声明RequiredAnnotationBeanPostProcessor的Bean：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;bean class=&quot;org.springframework.beans.factory.annotation.RequiredAnnotationBeanPostProcessor&quot;/&gt;</div></pre></td></tr></table></figure>
<p>类似地，使用<code>@Resource</code>、<code>@PostConstruct</code>、<code>@PreDestroy</code>等注解就必须声明CommonAnnotationBeanPostProcessor；使用<code>@PersistenceContext</code>注解，就必须声明PersistenceAnnotationBeanPostProcessor的Bean。</p>
<p>　　</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>这样的声明未免太不优雅，而Spring为我们提供了一种极为方便注册这些BeanPostProcessor的方式，即:</p>
<p>使用<code>&lt;context:annotation- config/&gt;</code>隐式地向 Spring容器注册AutowiredAnnotationBeanPostProcessor、RequiredAnnotationBeanPostProcessor、CommonAnnotationBeanPostProcessor以及PersistenceAnnotationBeanPostProcessor这4个BeanPostProcessor。如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;context:annotation-config/&gt;</div></pre></td></tr></table></figure>
<p>　　另，在我们使用注解时一般都会配置扫描包路径选项：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;context:component-scan base-package=&quot;pack.pack&quot;/&gt;</div></pre></td></tr></table></figure>
<p>　　该配置项其实也包含了自动注入上述processor的功能，因此当使用<context:component-scan>后，即可将<context:annotation-config>省去。</context:annotation-config></context:component-scan></p>
<h2 id="备注："><a href="#备注：" class="headerlink" title="备注："></a><strong>备注：</strong></h2><p>在配置文件中使用 context 命名空间之前，必须在 <beans> 元素中声明 context 命名空间，用来开启注解。 </beans></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;  </div><div class="line">    &lt;beans xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</div><div class="line">        xmlns=&quot;http://www.springframework.org/schema/beans&quot;</div><div class="line">        xmlns:context=&quot;http://www.springframework.org/schema/context&quot;  </div><div class="line">    ...</div><div class="line">        xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans  </div><div class="line">               http://www.springframework.org/schema/beans/spring-beans-3.0.xsd  </div><div class="line">               http://www.springframework.org/schema/context  </div><div class="line">               http://www.springframework.org/schema/context/spring-context-3.0.xsd  </div><div class="line">    ...</div><div class="line">        &lt;context:annotation-config/&gt;</div><div class="line">    &lt;/beans&gt;</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> Spring </tag>
            
            <tag> 框架，笔记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Spring IoC]]></title>
      <url>/2017/07/12/Spring-IoC/</url>
      <content type="html"><![CDATA[<h2 id="IoC-容器"><a href="#IoC-容器" class="headerlink" title="IoC 容器"></a>IoC 容器</h2><p>Spring 容器是 Spring 框架的核心。容器将创建对象，把它们连接在一起，配置它们，并管理他们的整个生命周期从创建到销毁。Spring 容器使用依赖注入（DI）来管理组成一个应用程序的组件。这些对象被称为 Spring Beans，我们将在下一章中进行讨论。</p>
<p>通过阅读配置元数据提供的指令，容器知道对哪些对象进行实例化，配置和组装。配置元数据可以通过 XML，Java 注释或 Java 代码来表示。 Spring IoC 容器利用 Java 的 POJO 类和配置元数据来生成完全配置和可执行的系统或应用程序。</p>
<p>Spring 提供了以下两种不同类型的容器。</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>容器 &amp; 描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td><a href="">Spring BeanFactory 容器</a>它是最简单的容器，给 DI 提供了基本的支持，它用 org.springframework.beans.factory.BeanFactory 接口来定义。BeanFactory 或者相关的接口，如 BeanFactoryAware，InitializingBean，DisposableBean，在 Spring 中仍然存在具有大量的与 Spring 整合的第三方框架的反向兼容性的目的。</td>
</tr>
<tr>
<td>2</td>
<td><a href="">Spring ApplicationContext 容器</a>该容器添加了更多的企业特定的功能，例如从一个属性文件中解析文本信息的能力，发布应用程序事件给感兴趣的事件监听器的能力。该容器是由 org.springframework.context.ApplicationContext 接口定义。</td>
</tr>
</tbody>
</table>
<h2 id="相关Java知识"><a href="#相关Java知识" class="headerlink" title="相关Java知识"></a>相关Java知识</h2><p>ApplicationContext 容器包括 BeanFactory 容器的所有功能，所以通常建议超过 BeanFactory。BeanFactory 仍然可以用于轻量级的应用程序，如移动设备或基于 applet 的应用程序，其中它的数据量和速度是显著。</p>
<p>Java语言允许通过程序化的方式间接对Class进行操作，Class文件由类装载器装载后，在JVM中将形成一份描述Class结构的元信息对象，通过该元信息对象可以获知Class的结构信息：如构造函数、属性和方法等。Java允许用户借由这个Class相关的元信息对象间接调用Class对象的功能，这就为使用程序化方式操作Class对象开辟了途径。 </p>
<h2 id="简单实例"><a href="#简单实例" class="headerlink" title="简单实例"></a><strong>简单实例</strong></h2><p>我们将从一个简单例子开始探访Java反射机制的征程，下面的Car类拥有两个构造函数、两个方法以及三个属性，如代码清单3-9所示：  </p>
<p>代码清单3-9  Car </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.baobaotao.reflect;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> String brand;</div><div class="line">	<span class="keyword">private</span> String color;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> maxSpeed;</div><div class="line">    </div><div class="line">     <span class="comment">//①默认构造函数</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">()</span></span>&#123;&#125;</div><div class="line">     </div><div class="line">     <span class="comment">//②带参构造函数</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">(String brand,String color,<span class="keyword">int</span> maxSpeed)</span></span>&#123; </div><div class="line">		<span class="keyword">this</span>.brand = brand;</div><div class="line">		<span class="keyword">this</span>.color = color;</div><div class="line">		<span class="keyword">this</span>.maxSpeed = maxSpeed;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">     <span class="comment">//③未带参的方法</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">introduce</span><span class="params">()</span> </span>&#123; </div><div class="line">       System.out.println(<span class="string">"brand:"</span>+brand+<span class="string">";color:"</span>+color+<span class="string">";maxSpeed:"</span> +maxSpeed);</div><div class="line">	&#125;</div><div class="line">     <span class="comment">//省略参数的getter/Setter方法</span></div><div class="line">     …</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一般情况下，我们会使用如下的代码创建Car的实例：<br>Java代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Car car = <span class="keyword">new</span> Car();</div><div class="line">car.setBrand(<span class="string">"红旗CA72"</span>);</div></pre></td></tr></table></figure>
<p>或者：<br>Java代码 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Car car = <span class="keyword">new</span> Car(<span class="string">"红旗CA72"</span>,<span class="string">"黑色"</span>);</div></pre></td></tr></table></figure>
<p>以上两种方法都采用传统方式的直接调用目标类的方法，下面我们通过Java反射机制以一种更加通用的方式间接地操作目标类： </p>
<p>代码清单3-10  ReflectTest </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.baobaotao. reflect;</div><div class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</div><div class="line"><span class="keyword">import</span> java.lang.reflect.Field;</div><div class="line"><span class="keyword">import</span> java.lang.reflect.Method;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectTest</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Car  <span class="title">initByDefaultConst</span><span class="params">()</span> <span class="keyword">throws</span> Throwable</span></div><div class="line">	&#123;</div><div class="line">		<span class="comment">//①通过类装载器获取Car类对象</span></div><div class="line">		ClassLoader loader = Thread.currentThread().getContextClassLoader(); </div><div class="line">		Class clazz = loader.loadClass(<span class="string">"com.baobaotao.reflect.Car"</span>); </div><div class="line">		</div><div class="line">          <span class="comment">//②获取类的默认构造器对象并通过它实例化Car</span></div><div class="line">		Constructor cons = clazz.getDeclaredConstructor((Class[])<span class="keyword">null</span>); </div><div class="line">		Car car = (Car)cons.newInstance();</div><div class="line">		</div><div class="line">         </div><div class="line">          <span class="comment">//③通过反射方法设置属性</span></div><div class="line">		Method setBrand = clazz.getMethod(<span class="string">"setBrand"</span>,String.class);	       </div><div class="line">		setBrand.invoke(car,<span class="string">"红旗CA72"</span>);		</div><div class="line">		Method setColor = clazz.getMethod(<span class="string">"setColor"</span>,String.class);</div><div class="line">		setColor.invoke(car,<span class="string">"黑色"</span>);		</div><div class="line">		Method setMaxSpeed = clazz.getMethod(<span class="string">"setMaxSpeed"</span>,<span class="keyword">int</span>.class);</div><div class="line">		setMaxSpeed.invoke(car,<span class="number">200</span>);		</div><div class="line">		<span class="keyword">return</span> car;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">		Car car = initByDefaultConst();</div><div class="line">		car.introduce();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行以上程序，在控制台上将打印出以下信息： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brand:红旗CA72;color:黑色;maxSpeed:<span class="number">200</span></div></pre></td></tr></table></figure>
<p>这说明我们完全可以通过编程方式调用Class的各项功能，这和直接通过构造函数和方法调用类功能的效果是一致的，只不过前者是间接调用，后者是直接调用罢了。 </p>
<p>在ReflectTest中，使用了几个重要的反射类，分别是ClassLoader、Class、Constructor和Method，通过这些反射类就可以间接调用目标Class的各项功能了。</p>
<p>在①处，我们获取当前线程的ClassLoader，然后通过指定的全限定类“com.baobaotao.beans.Car”装载Car类对应的反射实例。</p>
<p>在②处，我们通过Car的反射类对象获取Car的构造函数对象cons，通过构造函数对象的newInstrance()方法实例化Car对象，其效果等同于new Car()。</p>
<p>在③处，我们又通过Car的反射类对象的getMethod（String methodName,Class paramClass）获取属性的Setter方法对象，第一个参数是目标Class的方法名；第二个参数是方法入参的对象类型。获取方法反射对象后，即可通过invoke（Object obj,Object param）方法调用目标类的方法，该方法的第一个参数是操作的目标类对象实例；第二个参数是目标方法的入参。 </p>
<p>在代码清单3 10中，粗体所示部分的信息即是通过反射方法操控目标类的元信息，如果我们将这些信息以一个配置文件的方式提供，就可以使用Java语言的反射功能编写一段通用的代码对类似于Car的类进行实例化及功能调用操作了。 </p>
<h2 id="类装载器ClassLoader"><a href="#类装载器ClassLoader" class="headerlink" title="类装载器ClassLoader"></a><strong>类装载器ClassLoader</strong></h2><h3 id="类装载器工作机制"><a href="#类装载器工作机制" class="headerlink" title="类装载器工作机制"></a><strong>类装载器工作机制</strong></h3><p>类装载器就是寻找类的节码文件并构造出类在JVM内部表示对象的组件。在Java中，类装载器把一个类装入JVM中，要经过以下步骤： </p>
<p>[1]装载：查找和导入Class文件；<br>[2]链接：执行校验、准备和解析步骤，其中解析步骤是可以选择的：<br>    [2.1]校验：检查载入Class文件数据的正确性；<br>    [2.2]准备：给类的静态变量分配存储空间；<br>    [2.3]解析：将符号引用转成直接引用；<br>[3]初始化：对类的静态变量、静态代码块执行初始化工作。 </p>
<p>类装载工作由ClassLoader及其子类负责，ClassLoader是一个重要的Java运行时系统组件，它负责在运行时查找和装入Class字节码文件。JVM在运行时会产生三个ClassLoader：根装载器、ExtClassLoader（扩展类装载器）和AppClassLoader（系统类装载器）。</p>
<p>其中，根装载器不是ClassLoader的子类，它使用C++编写，因此我们在Java中看不到它，根装载器负责装载JRE的核心类库，如JRE目标下的rt.jar、charsets.jar等。</p>
<p>ExtClassLoader和AppClassLoader都是ClassLoader的子类。其中ExtClassLoader负责装载JRE扩展目录ext中的JAR类包；AppClassLoader负责装载Classpath路径下的类包。 </p>
<p>这三个类装载器之间存在父子层级关系，即根装载器是ExtClassLoader的父装载器，ExtClassLoader是AppClassLoader的父装载器。默认情况下，使用AppClassLoader装载应用程序的类，我们可以做一个实验： </p>
<p>代码清单3-11  ClassLoaderTest </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		ClassLoader loader = Thread.currentThread().getContextClassLoader();</div><div class="line">		System.out.println(<span class="string">"current loader:"</span>+loader);</div><div class="line">		System.out.println(<span class="string">"parent loader:"</span>+loader.getParent());</div><div class="line">		System.out.println(<span class="string">"grandparent loader:"</span>+loader.getParent(). getParent());</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行以上代码，在控制台上将打出以下信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">current loader:sun.misc.Launcher$AppClassLoader@<span class="number">131f</span>71a </div><div class="line">parent loader:sun.misc.Launcher$ExtClassLoader@<span class="number">15601</span>ea </div><div class="line">     <span class="comment">//①根装载器在Java中访问不到，所以返回null </span></div><div class="line">grandparent loader:<span class="keyword">null</span></div></pre></td></tr></table></figure>
<p>通过以上的输出信息，我们知道当前的ClassLoader是AppClassLoader，父ClassLoader是ExtClassLoader，祖父ClassLoader是根类装载器，因为在Java中无法获得它的句柄，所以仅返回null。 </p>
<p>JVM装载类时使用“全盘负责委托机制”，“全盘负责”是指当一个ClassLoader装载一个类的时，除非显式地使用另一个ClassLoader，该类所依赖及引用的类也由这个ClassLoader载入；“委托机制”是指先委托父装载器寻找目标类，只有在找不到的情况下才从自己的类路径中查找并装载目标类。这一点是从安全角度考虑的，试想如果有人编写了一个恶意的基础类（如java.lang.String）并装载到JVM中将会引起多么可怕的后果。但是由于有了“全盘负责委托机制”，java.lang.String永远是由根装载器来装载的，这样就避免了上述事件的发生。 </p>
<h3 id="ClassLoader重要方法"><a href="#ClassLoader重要方法" class="headerlink" title="ClassLoader重要方法"></a><strong>ClassLoader重要方法</strong></h3><p>在Java中，ClassLoader是一个抽象类，位于java.lang包中。下面对该类的一些重要接口方法进行介绍： </p>
<ul>
<li><p>Class loadClass(String name)     </p>
<p>name参数指定类装载器需要装载类的名字，必须使用全限定类名，如com.baobaotao. beans.Car。该方法有一个重载方法loadClass(String name ,boolean resolve)，resolve参数告诉类装载器是否需要解析该类。在初始化类之前，应考虑进行类解析的工作，但并不是所有的类都需要解析，如果JVM只需要知道该类是否存在或找出该类的超类，那么就不需要进行解析。 </p>
</li>
</ul>
<ul>
<li><p>Class defineClass(String name, byte[] b, int off, int len)<br>将类文件的字节数组转换成JVM内部的java.lang.Class对象。字节数组可以从本地文件系统、远程网络获取。name为字节数组对应的全限定类名。 </p>
</li>
<li><p>Class findSystemClass(String name)<br>从本地文件系统载入Class文件，如果本地文件系统不存在该Class文件，将抛出ClassNotFoundException异常。该方法是JVM默认使用的装载机制。 </p>
</li>
<li><p>Class findLoadedClass(String name)<br>调用该方法来查看ClassLoader是否已装入某个类。如果已装入，那么返回java.lang.Class对象，否则返回null。如果强行装载已存在的类，将会抛出链接错误。 </p>
</li>
<li><p>ClassLoader getParent()<br>获取类装载器的父装载器，除根装载器外，所有的类装载器都有且仅有一个父装载器，ExtClassLoader的父装载器是根装载器，因为根装载器非Java编写，所以无法获得，将返回null。 </p>
</li>
</ul>
<p>除JVM默认的三个ClassLoader以外，可以编写自己的第三方类装载器，以实现一些特殊的需求。类文件被装载并解析后，在JVM内将拥有一个对应的java.lang.Class类描述对象，该类的实例都拥有指向这个类描述对象的引用，而类描述对象又拥有指向关联ClassLoader的引用，如图3-4所示。 </p>
<p><img src="http://dl.iteye.com/upload/attachment/0067/1256/ef8d6a8b-8aee-3348-aa76-66804aaa3473.jpg" alt="img"> </p>
<p>每一个类在JVM中都拥有一个对应的java.lang.Class对象，它提供了类结构信息的描述。数组、枚举、注解以及基本Java类型（如int、double等），甚至void都拥有对应的Class对象。Class没有public的构造方法。Class对象是在装载类时由JVM通过调用类装载器中的defineClass()方法自动构造的。 </p>
<h2 id="Java反射机制"><a href="#Java反射机制" class="headerlink" title="Java反射机制"></a><strong>Java反射机制</strong></h2><p>Class反射对象描述类语义结构，可以从Class对象中获取构造函数、成员变量、方法类等类元素的反射对象，并以编程的方式通过这些反射对象对目标类对象进行操作。这些反射对象类在java.reflect包中定义，下面是最主要的三个反射类： </p>
<ul>
<li><p>Constructor：<br>类的构造函数反射类，通过Class#getConstructors()方法可以获得类的所有构造函数反射对象数组。在JDK5.0中，还可以通过getConstructor(Class… parameterTypes)获取拥有特定入参的构造函数反射对象。Constructor的一个主要方法是newInstance(Object[] initargs)，通过该方法可以创建一个对象类的实例，相当于new关键字。在JDK5.0中该方法演化为更为灵活的形式：newInstance (Object… initargs)。</p>
</li>
<li><p>Method：<br>类方法的反射类，通过Class#getDeclaredMethods()方法可以获取类的所有方法反射类对象数组Method[]。在JDK5.0中可以通过getDeclaredMethod(String name, Class… parameterTypes)获取特定签名的方法，name为方法名；Class…为方法入参类型列表。Method最主要的方法是invoke(Object obj, Object[] args)，obj表示操作的目标对象；args为方法入参，代码清单3 10③处演示了这个反射类的使用方法。在JDK 5.0中，该方法的形式调整为invoke(Object obj, Object… args)。此外，Method还有很多用于获取类方法更多信息的方法：       </p>
<p>1）Class getReturnType()：获取方法的返回值类型； </p>
<p>2）Class[] getParameterTypes()：获取方法的入参类型数组； </p>
<p>3）Class[] getExceptionTypes()：获取方法的异常类型数组； </p>
<p>4）Annotation[][] getParameterAnnotations()：获取方法的注解信息，JDK 5.0中的新方法；</p>
</li>
<li><p>Field：<br>类的成员变量的反射类，通过Class#getDeclaredFields()方法可以获取类的成员变量反射对象数组，通过Class#getDeclaredField(String name)则可获取某个特定名称的成员变量反射对象。Field类最主要的方法是set(Object obj, Object value)，obj表示操作的目标对象，通过value为目标对象的成员变量设置值。如果成员变量为基础类型，用户可以使用Field类中提供的带类型名的值设置方法，如setBoolean(Object obj, boolean value)、setInt(Object obj, int value)等。 </p>
</li>
</ul>
<p>此外，Java还为包提供了Package反射类，在JDK 5.0中还为注解提供了AnnotatedElement反射类。总之，Java的反射体系保证了可以通过程序化的方式访问目标类中所有的元素，对于private或protected的成员变量和方法，只要JVM的安全机制允许，也可以通过反射进行调用，请看下面的例子： </p>
<p>代码清单3-12  PrivateCarReflect </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.baobaotao.reflect;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrivateCar</span> </span>&#123;</div><div class="line">       <span class="comment">//①private成员变量：使用传统的类实例调用方式，只能在本类中访问</span></div><div class="line">   <span class="keyword">private</span> String color; </div><div class="line">        <span class="comment">//②protected方法：使用传统的类实例调用方式，只能在子类和本包中访问</span></div><div class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">drive</span><span class="params">()</span></span>&#123;</div><div class="line">	   </div><div class="line">System.out.println(<span class="string">"drive private car! the color is:"</span>+color);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>color变量和drive()方法都是私有的，通过类实例变量无法在外部访问私有变量、调用私有方法的，但通过反射机制却可以绕过这个限制： </p>
<p>代码清单3-13  PrivateCarReflect </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">…</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrivateCarReflect</span> </span>&#123;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable</span>&#123;</div><div class="line">	   ClassLoader loader = Thread.currentThread().getContextClassLoader();</div><div class="line">	   Class clazz = loader.loadClass(<span class="string">"com.baobaotao.reflect.PrivateCar"</span>);</div><div class="line">	   PrivateCar pcar = (PrivateCar)clazz.newInstance();</div><div class="line">	   </div><div class="line">	   Field colorFld = clazz.getDeclaredField(<span class="string">"color"</span>);</div><div class="line">        <span class="comment">//①取消Java语言访问检查以访问private变量</span></div><div class="line">	   colorFld.setAccessible(<span class="keyword">true</span>); </div><div class="line">	   colorFld.set(pcar,<span class="string">"红色"</span>);</div><div class="line">	   </div><div class="line">	   Method driveMtd = clazz.getDeclaredMethod(<span class="string">"drive"</span>,(Class[])<span class="keyword">null</span>);</div><div class="line">        <span class="comment">//Method driveMtd = clazz.getDeclaredMethod("drive"); JDK5.0下使用</span></div><div class="line">       </div><div class="line">        <span class="comment">//②取消Java语言访问检查以访问protected方法</span></div><div class="line">	   driveMtd.setAccessible(<span class="keyword">true</span>); </div><div class="line">        driveMtd.invoke(pcar,(Object[])<span class="keyword">null</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行该类，打印出以下信息： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">drive <span class="keyword">private</span> car! the color is:红色</div></pre></td></tr></table></figure>
<p>在访问private、protected成员变量和方法时必须通过setAccessible(boolean access)方法取消Java语言检查，否则将抛出IllegalAccessException。如果JVM的安全管理器设置了相应的安全机制，调用该方法将抛出SecurityException。 </p>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> Spring </tag>
            
            <tag> 框架 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Spring Hello World 实例]]></title>
      <url>/2017/07/12/Spring-Hello-World-%E5%AE%9E%E4%BE%8B/</url>
      <content type="html"><![CDATA[<h2 id="Hello-World-实例"><a href="#Hello-World-实例" class="headerlink" title="Hello World 实例"></a>Hello World 实例</h2><p>让我们使用 Spring 框架开始实际的编程。在你开始使用 Spring 框架编写第一个例子之前，你必须确保已经正确地设置了 Spring 环境，正如在 <strong>Spring——环境设置</strong>教程中如所说的。假设你有了解一些有关 Intellij IDEA工作的知识。</p>
<p>因此，让我们继续编写一个简单的 Spring 应用程序，它将根据在 Spring Beans 配置文件中配置的信息输出 “Hello World！” 或其他信息。</p>
<h2 id="第-1-步：创建-Java-项目"><a href="#第-1-步：创建-Java-项目" class="headerlink" title="第 1 步：创建 Java 项目"></a>第 1 步：创建 Java 项目</h2><p>第一步是使用 Eclipse IDE 创建一个简单的 Java 项目。按照选项 <strong>Create New Project -&gt; Spring-&gt; Libraries选择Use Library: (点击Create…找到Spring框架的解压位置) -&gt; Next</strong>，从向导列表中输入项目名称<strong>Project name</strong>: HelloSpring, 最后Finished便创建完成.</p>
<h2 id="第-2-步：添加必需的库"><a href="#第-2-步：添加必需的库" class="headerlink" title="第 2 步：添加必需的库"></a>第 2 步：添加必需的库</h2><p>第一步若在Libraries中已选择Use Library, 并导入相关的包, 则可以忽略此步骤.否则如下</p>
<p>第二步让我们添加 Spring 框架和通用的日志 API 库到我们的项目中。为了做到这个，选择菜单栏 <strong>File</strong> ，然后在菜单上按照下面可用的选项：<strong>Project  Structure…-&gt; Libraries</strong> </p>
<p>现在，在 <strong>Libraries</strong> 标签中使用可用的+ 按钮，添加从 Spring 框架和通用日志安装目录下面的核心 JAR 文件：</p>
<ul>
<li>commons-logging-1.1.1</li>
<li>spring-aop-4.1.6.RELEASE</li>
<li>spring-aspects-4.1.6.RELEASE</li>
<li>spring-beans-4.1.6.RELEASE</li>
<li>spring-context-4.1.6.RELEASE</li>
<li>spring-context-support-4.1.6.RELEASE</li>
<li>spring-core-4.1.6.RELEASE</li>
<li>spring-expression-4.1.6.RELEASE</li>
<li>spring-instrument-4.1.6.RELEASE</li>
<li>spring-instrument-tomcat-4.1.6.RELEASE</li>
<li>spring-jdbc-4.1.6.RELEASE</li>
<li>spring-jms-4.1.6.RELEASE</li>
<li>spring-messaging-4.1.6.RELEASE</li>
<li>spring-orm-4.1.6.RELEASE</li>
<li>spring-oxm-4.1.6.RELEASE</li>
<li>spring-test-4.1.6.RELEASE</li>
<li>spring-tx-4.1.6.RELEASE</li>
<li>spring-web-4.1.6.RELEASE</li>
<li>spring-webmvc-4.1.6.RELEASE</li>
<li>spring-webmvc-portlet-4.1.6.RELEASE</li>
<li>spring-websocket-4.1.6.RELEASE</li>
</ul>
<h2 id="第-3-步：创建源文件"><a href="#第-3-步：创建源文件" class="headerlink" title="第 3 步：创建源文件"></a>第 3 步：创建源文件</h2><p>现在让我们在 <strong>HelloSpring</strong> 项目下创建实际的源文件。首先，我们需要创建一个名为 <strong>com.tutorialspoint</strong> 的包。为了做到这个，在 package explore 区域中的 <strong>src</strong> 上点击右键，并按照选项：<strong>New -&gt; Package</strong>。</p>
<p>接下来，我们在包 com.tutorialspoint 下创建 <strong>HelloWorld.java</strong> 和 <strong>MainApp.java</strong> 文件。</p>
<p>这里是 <strong>HelloWorld.java</strong> 文件的内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">package com.tutorialspoint;</div><div class="line">public class HelloWorld &#123;</div><div class="line">   private String message;</div><div class="line">   public void setMessage(String message)&#123;</div><div class="line">      this.message  = message;</div><div class="line">   &#125;</div><div class="line">   public void getMessage()&#123;</div><div class="line">      System.out.println(&quot;Your Message : &quot; + message);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面是第二个文件 <strong>MainApp.java</strong> 的内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">package com.tutorialspoint;</div><div class="line">import org.springframework.context.ApplicationContext;</div><div class="line">import org.springframework.context.support.ClassPathXmlApplicationContext;</div><div class="line">public class MainApp &#123;</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line">      ApplicationContext context = </div><div class="line">             new ClassPathXmlApplicationContext(&quot;Beans.xml&quot;);</div><div class="line">      HelloWorld obj = (HelloWorld) context.getBean(&quot;helloWorld&quot;);</div><div class="line">      obj.getMessage();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>关于主要程序有以下两个要点需要注意：</p>
<ul>
<li>第一步是我们使用框架 API <strong>ClassPathXmlApplicationContext()</strong> 来创建应用程序的上下文。这个 API 加载 beans 的配置文件并最终基于所提供的 API，它处理创建并初始化所有的对象，即在配置文件中提到的 beans。</li>
<li>第二步是使用已创建的上下文的 <strong>getBean() </strong>方法来获得所需的 bean。这个方法使用 bean 的 ID 返回一个最终可以转换为实际对象的通用对象。一旦有了对象，你就可以使用这个对象调用任何类的方法。</li>
</ul>
<h2 id="第-4-步：创建-bean-的配置文件"><a href="#第-4-步：创建-bean-的配置文件" class="headerlink" title="第 4 步：创建 bean 的配置文件"></a>第 4 步：创建 bean 的配置文件</h2><p>你需要创建一个 Bean 的配置文件，该文件是一个 XML 文件，并且作为粘合 bean 的粘合剂即类。这个文件需要在 <strong>src</strong> 目录下创建.</p>
<p>通常开发人员保存该文件的名称为 <strong>Beans.xml</strong> 文件，但是你可以单独选择你喜欢的任何名称。你必须确保这个文件在 CLASSPATH 中是可用的，并在主应用程序中使用相同的名称，而在 MainApp.java 文件中创建应用程序的上下文。</p>
<p>Beans.xml 用于给不同的 bean 分配唯一的 ID，并且控制不同值的对象的创建，而不会影响 Spring 的任何源文件。例如，使用下面的文件，你可以为 “message” 变量传递任何值，因此你就可以输出信息的不同值，而不会影响的 HelloWorld.java和MainApp.java 文件。让我们来看看它是如何工作的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</div><div class="line"></div><div class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</div><div class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</div><div class="line">    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</div><div class="line">    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd&quot;&gt;</div><div class="line"></div><div class="line">   &lt;bean id=&quot;helloWorld&quot; class=&quot;com.tutorialspoint.HelloWorld&quot;&gt;</div><div class="line">       &lt;property name=&quot;message&quot; value=&quot;Hello World!&quot;/&gt;</div><div class="line">   &lt;/bean&gt;</div><div class="line"></div><div class="line">&lt;/beans&gt;</div></pre></td></tr></table></figure>
<p>当 Spring 应用程序被加载到内存中时，框架利用了上面的配置文件来创建所有已经定义的 beans，并且按照标签的定义为它们分配一个唯一的 ID。你可以使用标签来传递在创建对象时使用不同变量的值。</p>
<h2 id="第-5-步：运行程序"><a href="#第-5-步：运行程序" class="headerlink" title="第 5 步：运行程序"></a>第 5 步：运行程序</h2><p>一旦你完成了创建源代码和 bean 的配置文件后，准备好下一步编译和运行你的程序。为了做到这个，请保持 MainApp.Java 文件标签是<strong>有效</strong>的，并且在 Intellij IDEA 中使用可用的 Run 选项，或使用 <strong>Ctrl + F11</strong> 编译并运行你的应用程序 <strong>MainApp</strong>。如果你的应用程序一切都正常，将在 Eclipse IDE 控制台打印以下信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Your Message : Hello World!</div></pre></td></tr></table></figure>
<p>祝贺，你已经成功地创建了你的第一个 Spring 应用程序。通过更改 “message” 属性的值并且保持两个源文件不变，你可以看到上述 Spring 应用程序的灵活性。下一步，我们开始在接下来的几个章节中做一些更有趣的事情。</p>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> Spring </tag>
            
            <tag> 框架 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Spring 环境配置]]></title>
      <url>/2017/07/12/Spring-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<h2 id="环境设置"><a href="#环境设置" class="headerlink" title="环境设置"></a>环境设置</h2><h2 id="第-1-步：安装-Java-开发工具包（JDK）"><a href="#第-1-步：安装-Java-开发工具包（JDK）" class="headerlink" title="第 1 步：安装 Java 开发工具包（JDK）"></a>第 1 步：安装 Java 开发工具包（JDK）</h2><p>你可以从 Oracle 的 Java 网站 <a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html" target="_blank" rel="external"><strong>Java SE Downloads</strong></a> 下载 SDK 的最新版本。你会在下载的文件中找到教你如何安装 JDK 的说明，按照给出的说明安装和配置 JDK 的设置。最后，设置 PATH 和 JAVA<em>HOME 环境变量，引入包含 java 和 javac 的目录，通常分别为 java install dir/bin 和 java install </em> dir。</p>
<p>如果你运行的是Windows，并在C:\jdk*.*.*_**上安装了JDK，你就可以把下面这行写入C:\autoexec.bat文件中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">set PATH=C:\jdk*.*.*_**\bin;%PATH%</div><div class="line">set JAVA_HOME=C:\jdk*.*.*_**</div></pre></td></tr></table></figure>
<p>或者，在 Windows XP/7/8 中，你也可以右键单击“我的电脑”，选择“属性”，然后是“高级”，然后是“环境变量”。接下来，你将更新 PATH 值，并且按下 OK 按钮。</p>
<p>在 Unix(Solaris、Linux 等等)上，如果在 /usr/local/jdk<em>.</em>.<em>_*</em> 上安装 SDK，并且使用 C shell 命令，你将把下面的内容添加到 .cshrc 文件中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">setenv PATH /usr/local/jdk*.*.*_**/bin:$PATH</div><div class="line">setenv JAVA_HOME /usr/local/jdk*.*.*_**</div></pre></td></tr></table></figure>
<p>或者，如果你使用集成开发环境（IDE），如 IntelliJ IDEA ,Eclipse或者 Sun ONE Studio，编译和运行一个简单的程序，用来确认 IDE 知道你安装了 Java，否则应该根据 IDE 给定的文档做正确的设置。</p>
<h2 id="第-2-步：安装-Apache-Commons-Logging-API"><a href="#第-2-步：安装-Apache-Commons-Logging-API" class="headerlink" title="第 2 步：安装 Apache Commons Logging API"></a>第 2 步：安装 Apache Commons Logging API</h2><p>你可以从 <a href="http://commons.apache.org/logging/download_logging.cgi" target="_blank" rel="external"></a><strong><a href="http://commons.apache.org/logging/" target="_blank" rel="external">http://commons.apache.org/logging/</a></strong> 下载 Apache Commons Logging API 的最新版本。一旦你下载完安装包，并且解压二进制的发行版本到一个方便的位置。例如在 windows 上的 C:\commons-logging-1.1.1 中，或在 Linux/Unix 上的 /usr/local/commons-logging-1.1.1 中。该目录将有如下的 jar 文件和其他支持的文件等。</p>
<p><img src="w3cnote://file/getImage?fileId=imgw3cschoolcnattachmentsimagewkwkspringenvironment1jpg" alt="img"></p>
<p>确保你在这个目录上正确的设置 CLASSPATH 变量，否则你将会在运行应用程序时遇到问题。</p>
<h2 id="第-3-步：安装-Intellij-IEDA"><a href="#第-3-步：安装-Intellij-IEDA" class="headerlink" title="第 3 步：安装 Intellij  IEDA"></a>第 3 步：安装 Intellij  IEDA</h2><p>从 官网上下载最新的 Intellij IEDA 二进制文件, 进行安装。</p>
<h2 id="第-4-步：安装-Spring-框架库"><a href="#第-4-步：安装-Spring-框架库" class="headerlink" title="第 4 步：安装 Spring 框架库"></a>第 4 步：安装 Spring 框架库</h2><p>现在如果一切正常，你就可以继续设置你的 Spring 框架。下面是在你的机器上下载并安装框架的简单步骤。</p>
<ul>
<li>选择是要在 Windows 还是在 UNIX 上安装 Spring，然后继续进行下一个步骤，在 Windows 上下载 .zip 文件,而在 Unix 上下载 .tz 文件。</li>
<li>从 <a href="http://repo.spring.io/release/org/springframework/spring" target="_blank" rel="external"><strong>http://repo.spring.io/release/org/springframework/spring</strong></a> 下载最新版本的 Spring 框架的二进制文件。</li>
<li>当你解压缩下载的文件时，它内置的目录结构为 E:\spring，如下所示。</li>
</ul>
<p><img src="w3cnote://file/getImage?fileId=imgw3cschoolcnattachmentsimagewkwkspringenvironment3jpg" alt="img"></p>
<p>你会在目录 <strong>E:\spring\libs</strong> 中发现所有的 Spring 库。确保你在这个目录上正确的设置 CLASSPATH 变量，否则你将会在运行应用程序时遇到问题。如果使用的是 Intellij IDEA，就不需要设置 CLASSPATH，因为所有的设置将可以通过IntellIJ DEA内部项目包导入完成。</p>
<p>一旦你完成了最后一步后，你就可以继续你的第一个 Spring 例子，你将会在下一章中看到。</p>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> Spring </tag>
            
            <tag> 框架 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Spring 体系结构]]></title>
      <url>/2017/07/12/Spring-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</url>
      <content type="html"><![CDATA[<h2 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h2><p>Spring 有可能成为所有企业应用程序的一站式服务点，然而，Spring 是模块化的，允许你挑选和选择适用于你的模块，不必要把剩余部分也引入。下面的部分对在 Spring 框架中所有可用的模块给出了详细的介绍。</p>
<p>Spring 框架提供约 20 个模块，可以根据应用程序的要求来使用。</p>
<p>的要求来使用。</p>
<p><img src="w3cnote://file/getImage?fileId=imgw3cschoolcnattachmentsimagewkwkspringarch1png" alt="img"></p>
<h2 id="核心容器"><a href="#核心容器" class="headerlink" title="核心容器"></a>核心容器</h2><p>核心容器由核心，Bean，上下文和表达式语言模块组成，它们的细节如下：</p>
<ul>
<li><strong>核心</strong>模块提供了框架的基本组成部分，包括 IoC 和依赖注入功能。</li>
<li><strong>Bean</strong> 模块提供 BeanFactory，它是一个工厂模式的复杂实现。</li>
<li><strong>上下文</strong>模块建立在由核心和 Bean 模块提供的坚实基础上，它是访问定义和配置的任何对象的媒介。ApplicationContext 接口是上下文模块的重点。</li>
<li><strong>表达式语言</strong>模块在运行时提供了查询和操作一个对象图的强大的表达式语言。</li>
</ul>
<h2 id="数据访问-集成"><a href="#数据访问-集成" class="headerlink" title="数据访问/集成"></a>数据访问/集成</h2><p>数据访问/集成层包括 JDBC，ORM，OXM，JMS 和事务处理模块，它们的细节如下：</p>
<ul>
<li><strong>JDBC</strong> 模块提供了删除冗余的 JDBC 相关编码的 JDBC 抽象层。</li>
<li><strong>ORM</strong> 模块为流行的对象关系映射 API，包括 JPA，JDO，Hibernate 和 iBatis，提供了集成层。</li>
<li><strong>OXM</strong> 模块提供了抽象层，它支持对 JAXB，Castor，XMLBeans，JiBX 和 XStream 的对象/XML 映射实现。</li>
<li>Java 消息服务 <strong>JMS</strong> 模块包含生产和消费的信息的功能。</li>
<li><strong>事务</strong>模块为实现特殊接口的类及所有的 POJO 支持编程式和声明式事务管理。</li>
</ul>
<h2 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h2><p>Web 层由 Web，Web-MVC，Web-Socket 和 Web-Portlet 组成，它们的细节如下：</p>
<ul>
<li><strong>Web</strong> 模块提供了基本的面向 web 的集成功能，例如多个文件上传的功能和使用 servlet 监听器和面向 web 应用程序的上下文来初始化 IoC 容器。</li>
<li><strong>Web-MVC</strong> 模块包含 Spring 的模型-视图-控制器（MVC），实现了 web 应用程序。</li>
<li><strong>Web-Socket</strong> 模块为 WebSocket-based 提供了支持，而且在 web 应用程序中提供了客户端和服务器端之间通信的两种方式。</li>
<li><strong>Web-Portlet</strong> 模块提供了在 portlet 环境中实现 MVC，并且反映了 Web-Servlet 模块的功能。</li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>还有其他一些重要的模块，像 AOP，Aspects，Instrumentation，Web 和测试模块，它们的细节如下：</p>
<ul>
<li><strong>AOP</strong> 模块提供了面向方面的编程实现，允许你定义方法拦截器和切入点对代码进行干净地解耦，它实现了应该分离的功能。</li>
<li><strong>Aspects</strong> 模块提供了与 <strong>AspectJ</strong> 的集成，这是一个功能强大且成熟的面向切面编程（AOP）框架。</li>
<li><strong>Instrumentation</strong> 模块在一定的应用服务器中提供了类 instrumentation 的支持和类加载器的实现。</li>
<li><strong>Messaging</strong> 模块为 STOMP 提供了支持作为在应用程序中 WebSocket 子协议的使用。它也支持一个注解编程模型，它是为了选路和处理来自 WebSocket 客户端的 STOMP 信息。</li>
<li><strong>测试</strong>模块支持对具有 JUnit 或 TestNG 框架的 Spring 组件的测试。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> Spring </tag>
            
            <tag> 框架 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Spring 概述]]></title>
      <url>/2017/07/12/Spring-%E6%A6%82%E8%BF%B0/</url>
      <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Spring 是最受欢迎的企业级 Java 应用程序开发框架。数以百万的来自世界各地的开发人员使用 Spring 框架来创建好性能、易于测试、可重用的代码。</p>
<p>Spring 框架是一个开源的 Java 平台，它最初是由 Rod Johnson 编写的，并且 2003 年 6 月首次在 Apache 2.0 许可下发布。</p>
<p>当谈论到大小和透明度时， Spring 是轻量级的。 Spring 框架的基础版本是在 2 MB 左右的。</p>
<p>Spring 框架的核心特性可以用于开发任何 Java 应用程序，但是在 Java EE 平台上构建 web 应用程序是需要扩展的。 Spring 框架的目标是使 J2EE 开发变得更容易使用，通过启用基于 POJO 编程模型来促进良好的编程实践。</p>
<h2 id="使用-Spring-框架的好处"><a href="#使用-Spring-框架的好处" class="headerlink" title="使用 Spring 框架的好处"></a>使用 Spring 框架的好处</h2><p>下面列出的是使用 Spring 框架主要的好处：</p>
<ul>
<li>Spring 可以使开发人员使用 POJOs 开发企业级的应用程序。只使用 POJOs 的好处是你不需要一个 EJB 容器产品，比如一个应用程序服务器，但是你可以选择使用一个健壮的 servlet 容器，比如 Tomcat 或者一些商业产品。</li>
<li>Spring 在一个单元模式中是有组织的。即使包和类的数量非常大，你必须并且只需要但是你需要的，而忽略剩余的那部分。</li>
<li>Spring 不会让你白费力气做重复工作，它真正的利用了一些现有的技术，像几个 ORM 框架、日志框架、JEE、Quartz 和 JDK 计时器，其他视图技术。</li>
<li>测试一个用 Spring 编写的应用程序很容易，因为 environment-dependent 代码被放进了这个框架中。此外，通过使用 JavaBean-style POJOs，它在使用依赖注入注入测试数据时变得更容易。</li>
<li>Spring 的 web 框架是一个设计良好的 web MVC 框架，它为 web 框架，比如 Structs 或者其他工程上的或者很少受欢迎的 web 框架，提供了一个很好的供替代的选择。</li>
<li>为将特定技术的异常（例如，由 JDBC、Hibernate，或者 JDO 抛出的异常）翻译成一致的， Spring 提供了一个方便的 API，而这些都是未经检验的异常。</li>
<li>轻量级的 IOC 容器往往是轻量级的，例如，特别是当与 EJB 容器相比的时候。这有利于在内存和 CPU 资源有限的计算机上开发和部署应用程序。</li>
<li>Spring 提供了一个一致的事务管理界面，该界面可以缩小成一个本地事务（例如，使用一个单一的数据库）和扩展成一个全局事务（例如，使用 JTA）。</li>
</ul>
<h2 id="依赖注入（DI）"><a href="#依赖注入（DI）" class="headerlink" title="依赖注入（DI）"></a>依赖注入（DI）</h2><p>Spring 最认同的技术是控制反转的<strong>依赖注入（DI）</strong>模式。控制反转（IoC）是一个通用的概念，它可以用许多不同的方式去表达，依赖注入仅仅是控制反转的一个具体的例子。</p>
<p>当编写一个复杂的 Java 应用程序时，应用程序类应该尽可能的独立于其他的 Java 类来增加这些类可重用可能性，当进行单元测试时，可以使它们独立于其他类进行测试。依赖注入（或者有时被称为配线）有助于将这些类粘合在一起，并且在同一时间让它们保持独立。</p>
<p>到底什么是依赖注入？让我们将这两个词分开来看一看。这里将依赖关系部分转化为两个类之间的关联。例如，类 A 依赖于类 B。现在，让我们看一看第二部分，注入。所有这一切都意味着类 B 将通过 IoC 被注入到类 A 中。</p>
<p>依赖注入可以以向构造函数传递参数的方式发生，或者通过使用 setter 方法 post-construction。由于依赖注入是 Spring 框架的核心部分，所以我将在一个单独的章节中利用很好的例子去解释这一概念。</p>
<h2 id="面向方面的程序设计（AOP）："><a href="#面向方面的程序设计（AOP）：" class="headerlink" title="面向方面的程序设计（AOP）："></a>面向方面的程序设计（AOP）：</h2><p>Spring 框架的一个关键组件是<strong>面向方面的程序设计（AOP）</strong>框架。一个程序中跨越多个点的功能被称为<strong>横切关注点</strong>，这些横切关注点在概念上独立于应用程序的业务逻辑。有各种各样常见的很好的关于方面的例子，比如日志记录、声明性事务、安全性，和缓存等等。</p>
<p>在 OOP 中模块化的关键单元是类，而在 AOP 中模块化的关键单元是方面。AOP 帮助你将横切关注点从它们所影响的对象中分离出来，然而依赖注入帮助你将你的应用程序对象从彼此中分离出来。</p>
<p>Spring 框架的 AOP 模块提供了面向方面的程序设计实现，允许你定义拦截器方法和切入点，可以实现将应该被分开的代码干净的分开功能。我将在一个独立的章节中讨论更多关于 Spring AOP 的概念。</p>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> Spring </tag>
            
            <tag> 框架 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Dijkstra 算法]]></title>
      <url>/2017/06/08/Dijkstra-Algorithms/</url>
      <content type="html"><![CDATA[<h2 id="1-Dijkstra算法概述"><a href="#1-Dijkstra算法概述" class="headerlink" title="1.Dijkstra算法概述"></a>1.Dijkstra算法概述</h2><p>　　<strong><code>Dijkstra算法</code></strong>是由荷兰计算机科学家狄克斯特拉（Dijkstra）于1959 年提出的，因此又叫<code>狄克斯特拉算法</code>。是从一个顶点到其余各顶点的最短路径算法，解决的是有向图中最短路径问题。</p>
<p><img src="http://shentar.qiniudn.com/wp-content/uploads/2014/07/Dijkstra_Animation.gif" alt=""></p>
<p>　　其基本原理是：每次新扩展一个距离最短的点，更新与其相邻的点的距离。当所有边权都为正时，由于不会存在一个距离更短的没扩展过的点，所以这个点的距离永远不会再被改变，因而保证了算法的正确性。不过根据这个原理，<strong><u>用Dijkstra求最短路的图不能有负权边</u></strong>，因为扩展到负权边的时候会产生更短的距离，有可能就破坏了已经更新的点距离不会改变的性质。</p>
<p>　　举例来说，如果图中的顶点表示城市，而边上的权重表示著城市间开车行经的距离。 Dijkstra算法可以用来找到两个城市之间的最短路径。</p>
<p>　　Dijkstra算法的输入包含了一个有权重的有向图G，以及G中的一个来源顶点S。 我们以V表示G中所有顶点的集合。 每一个图中的边，都是两个顶点所形成的有序元素对。(u,v)表示从顶点u到v有路径相连。 我们以E所有边的集合，而边的权重则由权重函数w: E → [0, ∞]定义。 因此，w(u,v)就是从顶点u到顶点v的非负花费值(cost)。 边的花费可以想像成两个顶点之间的距离。任两点间路径的花费值，就是该路径上所有边的花费值总和。 已知有V中有顶点s及t，Dijkstra算法可以找到s到t的最低花费路径(i.e. 最短路径)。 这个算法也可以在一个图中，找到从一个顶点s到任何其他顶点的最短路径。</p>
<p>　　<a href="http://wiki.mbalib.com/wiki/Image:Dijkstra%E7%AE%97%E6%B3%95%E5%9B%BE.jpg" target="_blank" rel="external"><img src="http://wiki.mbalib.com/w/images/6/65/Dijkstra%E7%AE%97%E6%B3%95%E5%9B%BE.jpg" alt="Image:Dijkstra算法图.jpg"></a></p>
<h2 id="2-Dijkstra算法基本思想"><a href="#2-Dijkstra算法基本思想" class="headerlink" title="2.Dijkstra算法基本思想"></a>2.Dijkstra算法基本思想</h2><p>迪杰斯特拉(Dijkstra)算法是典型最短路径算法，用于计算一个节点到其他节点的最短路径。<br>它的主要特点是以起始点为中心向外层层扩展(广度优先搜索思想)，直到扩展到终点为止。</p>
<h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>在每个阶段，Dijkstra算法选择一个顶点<code>v</code>,它在所有未知顶点中具有最小的<code>dv</code>，同时声明从<code>s</code>到<code>v</code>的最短路径是已知的。阶段的其余部分由<code>dw</code>值的更新工作组成。</p>
<p>这里先明确两个集合：所有顶点集V和已选中顶点集S。</p>
<ul>
<li>找到当前未选中点（V - S）中距离源点最近的点</li>
<li>更新未选中点到源点的距离</li>
</ul>
<p><img src="http://hi.csdn.net/attachment/201107/22/0_13113298712dnT.gif" alt="img"></p>
<p>  通过Dijkstra计算图G中的最短路径时，需要指定起点s(即从顶点s开始计算)。</p>
<p>​     此外，引进两个集合S和U。S的作用是记录已求出最短路径的顶点(以及相应的最短路径长度)，而U则是记录还未求出最短路径的顶点(以及该顶点到起点s的距离)。</p>
<p>​     初始时，S中只有起点s；U中是除s之外的顶点，并且U中顶点的路径是”起点s到该顶点的路径”。然后，从U中找出路径最短的顶点，并将其加入到S中；接着，更新U中的顶点和顶点对应的路径。 然后，再从U中找出路径最短的顶点，并将其加入到S中；接着，更新U中的顶点和顶点对应的路径。 … 重复该操作，直到遍历完所有顶点。</p>
<h3 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h3><p><strong>(1)</strong> 初始时，S只包含起点s；U包含除s外的其他顶点，且U中顶点的距离为”起点s到该顶点的距离”[例如，U中顶点v的距离为(s,v)的长度，然后s和v不相邻，则v的距离为∞]。</p>
<p><strong>(2)</strong> 从U中选出”距离最短的顶点k”，并将顶点k加入到S中；同时，从U中移除顶点k。</p>
<p><strong>(3)</strong> 更新U中各个顶点到起点s的距离。之所以更新U中顶点的距离，是由于上一步中确定了k是求出最短路径的顶点，从而可以利用k来更新其它顶点的距离；例如，(s,v)的距离可能大于(s,k)+(k,v)的距离。</p>
<p><strong>(4)</strong> 重复步骤(2)和(3)，直到遍历完所有顶点。</p>
<p>单纯的看上面的理论可能比较难以理解，下面通过实例来对该算法进行说明。</p>
<h3 id="迪杰斯特拉算法图解"><a href="#迪杰斯特拉算法图解" class="headerlink" title="迪杰斯特拉算法图解"></a>迪杰斯特拉算法图解</h3><p><img src="https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/dijkstra/01.jpg?raw=true&amp;_=3711516" alt=""></p>
<p>以上图G4为例，来对迪杰斯特拉进行算法演示(以第4个顶点D为起点)。</p>
<p><img src="https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/dijkstra/02.jpg?raw=true&amp;_=3711516" alt=""></p>
<p><strong>初始状态</strong>：S是已计算出最短路径的顶点集合，U是未计算除最短路径的顶点的集合！<br><strong>第1步</strong>：将顶点D加入到S中。<br>​    此时，S={D(0)}, U={A(∞),B(∞),C(3),E(4),F(∞),G(∞)}。     注:C(3)表示C到起点D的距离是3。</p>
<p><strong>第2步</strong>：将顶点C加入到S中。<br>​    上一步操作之后，U中顶点C到起点D的距离最短；因此，将C加入到S中，同时更新U中顶点的距离。以顶点F为例，之前F到D的距离为∞；但是将C加入到S之后，F到D的距离为9=(F,C)+(C,D)。<br>​    此时，S={D(0),C(3)}, U={A(∞),B(23),E(4),F(9),G(∞)}。</p>
<p><strong>第3步</strong>：将顶点E加入到S中。<br>​    上一步操作之后，U中顶点E到起点D的距离最短；因此，将E加入到S中，同时更新U中顶点的距离。还是以顶点F为例，之前F到D的距离为9；但是将E加入到S之后，F到D的距离为6=(F,E)+(E,D)。<br>​    此时，S={D(0),C(3),E(4)}, U={A(∞),B(23),F(6),G(12)}。</p>
<p><strong>第4步</strong>：将顶点F加入到S中。<br>​    此时，S={D(0),C(3),E(4),F(6)}, U={A(22),B(13),G(12)}。</p>
<p><strong>第5步</strong>：将顶点G加入到S中。<br>​    此时，S={D(0),C(3),E(4),F(6),G(12)}, U={A(22),B(13)}。</p>
<p><strong>第6步</strong>：将顶点B加入到S中。<br>​    此时，S={D(0),C(3),E(4),F(6),G(12),B(13)}, U={A(22)}。</p>
<p><strong>第7步</strong>：将顶点A加入到S中。<br>​    此时，S={D(0),C(3),E(4),F(6),G(12),B(13),A(22)}。</p>
<p>此时，起点D到各个顶点的最短距离就计算出来了：<strong>A(22) B(13) C(3) D(0) E(4) F(6) G(12)</strong>。</p>
<h2 id="3-核心代码"><a href="#3-核心代码" class="headerlink" title="3.核心代码"></a>3.核心代码</h2><h3 id="迪杰斯特拉算法的代码说明-c"><a href="#迪杰斯特拉算法的代码说明-c" class="headerlink" title="迪杰斯特拉算法的代码说明(c)"></a>迪杰斯特拉算法的代码说明(c)</h3><h4 id="Dijkstra算法的声明"><a href="#Dijkstra算法的声明" class="headerlink" title="Dijkstra算法的声明"></a>Dijkstra算法的声明</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Vertex;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TableEntery</span></span></div><div class="line">&#123;</div><div class="line">    List Header;    <span class="comment">// Adjacency list</span></div><div class="line">    <span class="keyword">int</span> Known;</div><div class="line">    DisType Dist;</div><div class="line">    Vertex Path;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// Vertices are numbered from 0</span></div><div class="line"><span class="meta"># <span class="meta-keyword">define</span> NotAVertex (-1)</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TableEntery</span> <span class="title">Table</span>[<span class="title">NumVertex</span>];</span></div></pre></td></tr></table></figure>
<h4 id="表初始化"><a href="#表初始化" class="headerlink" title="表初始化"></a>表初始化</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitTable</span><span class="params">(Vertex Start, Graph G, Table T)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line"></div><div class="line">    ReadGrap(G, T);    <span class="comment">// Read graph somehow</span></div><div class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; NumVertex; i++)</div><div class="line">    &#123;</div><div class="line">        T[i].Known = False;</div><div class="line">        T[i].Dist = Infinity;</div><div class="line">        T[i].Path = NotAVertex;</div><div class="line">    &#125;</div><div class="line">    T[Start].Dist = <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="显示实际最短路径"><a href="#显示实际最短路径" class="headerlink" title="显示实际最短路径"></a>显示实际最短路径</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// print shorting path to V after Dijkstra has run</span></div><div class="line"><span class="comment">// Assume that the path exists</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintPath</span><span class="params">(Vertex V, Table T)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>(T[V].Path != NotAVertex)</div><div class="line">    &#123;</div><div class="line">        PrintPath(T[V].Path, T);</div><div class="line">        <span class="built_in">printf</span>(<span class="string">" to "</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%v"</span>, V);    <span class="comment">// %v is pseudocode</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="Dijkstra算法的伪代码"><a href="#Dijkstra算法的伪代码" class="headerlink" title="Dijkstra算法的伪代码"></a>Dijkstra算法的伪代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(Table T)</span></span></div><div class="line">&#123;</div><div class="line">    Vertex V, W;</div><div class="line">    <span class="keyword">for</span>(;;)</div><div class="line">    &#123;</div><div class="line">        V = smallest unknown distance vertex;</div><div class="line">        <span class="keyword">if</span>(V == NotAVertex)</div><div class="line">            <span class="keyword">break</span>;</div><div class="line"></div><div class="line">        T[V].Known = True;</div><div class="line">        <span class="function"><span class="keyword">for</span> each W adjacent to V</span></div><div class="line">            <span class="title">if</span><span class="params">(!T[W].Known)</span></div><div class="line">                <span class="title">if</span><span class="params">(T[V].Dist + Cvw &lt; T[W].Dist)</span></div><div class="line">                &#123;        <span class="comment">// Update W</span></div><div class="line">                    Decrease(T[W].Dist to T[V].Dist + Cvw);</div><div class="line">                    T[W].Path =  V;</div><div class="line">                &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="迪杰斯特拉算法的代码说明-java"><a href="#迪杰斯特拉算法的代码说明-java" class="headerlink" title="迪杰斯特拉算法的代码说明(java)"></a><strong>迪杰斯特拉算法的代码说明(java)</strong></h3><p>以”邻接矩阵”为例对迪杰斯特拉算法进行说明，对于”邻接表”实现的图在后面会给出相应的源码。</p>
<p><strong>1. 基本定义</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MatrixUDG</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mEdgNum;        <span class="comment">// 边的数量</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">char</span>[] mVexs;       <span class="comment">// 顶点集合</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] mMatrix;    <span class="comment">// 邻接矩阵</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INF = Integer.MAX_VALUE;   <span class="comment">// 最大值</span></div><div class="line"></div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>MatrixUDG是邻接矩阵对应的结构体。mVexs用于保存顶点，mEdgNum用于保存边数，mMatrix则是用于保存矩阵信息的二维数组。例如，mMatrix[i][j]=1，则表示”顶点i(即mVexs[i])”和”顶点j(即mVexs[j])”是邻接点；mMatrix[i][j]=0，则表示它们不是邻接点。</p>
<p><strong>2. 迪杰斯特拉算法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * Dijkstra最短路径。</div><div class="line"> * 即，统计图中"顶点vs"到其它各个顶点的最短路径。</div><div class="line"> *</div><div class="line"> * 参数说明：</div><div class="line"> *       vs -- 起始顶点(start vertex)。即计算"顶点vs"到其它顶点的最短路径。</div><div class="line"> *     prev -- 前驱顶点数组。即，prev[i]的值是"顶点vs"到"顶点i"的最短路径所经历的全部顶点中，位于"顶点i"之前的那个顶点。</div><div class="line"> *     dist -- 长度数组。即，dist[i]是"顶点vs"到"顶点i"的最短路径的长度。</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> vs, <span class="keyword">int</span>[] prev, <span class="keyword">int</span>[] dist)</span> </span>&#123;</div><div class="line">    <span class="comment">// flag[i]=true表示"顶点vs"到"顶点i"的最短路径已成功获取</span></div><div class="line">    <span class="keyword">boolean</span>[] flag = <span class="keyword">new</span> <span class="keyword">boolean</span>[mVexs.length];</div><div class="line"></div><div class="line">    <span class="comment">// 初始化</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mVexs.length; i++) &#123;</div><div class="line">        flag[i] = <span class="keyword">false</span>;          <span class="comment">// 顶点i的最短路径还没获取到。</span></div><div class="line">        prev[i] = <span class="number">0</span>;              <span class="comment">// 顶点i的前驱顶点为0。</span></div><div class="line">        dist[i] = mMatrix[vs][i];  <span class="comment">// 顶点i的最短路径为"顶点vs"到"顶点i"的权。</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 对"顶点vs"自身进行初始化</span></div><div class="line">    flag[vs] = <span class="keyword">true</span>;</div><div class="line">    dist[vs] = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 遍历mVexs.length-1次；每次找出一个顶点的最短路径。</span></div><div class="line">    <span class="keyword">int</span> k=<span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; mVexs.length; i++) &#123;</div><div class="line">        <span class="comment">// 寻找当前最小的路径；</span></div><div class="line">        <span class="comment">// 即，在未获取最短路径的顶点中，找到离vs最近的顶点(k)。</span></div><div class="line">        <span class="keyword">int</span> min = INF;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; mVexs.length; j++) &#123;</div><div class="line">            <span class="keyword">if</span> (flag[j]==<span class="keyword">false</span> &amp;&amp; dist[j]&lt;min) &#123;</div><div class="line">                min = dist[j];</div><div class="line">                k = j;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 标记"顶点k"为已经获取到最短路径</span></div><div class="line">        flag[k] = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">        <span class="comment">// 修正当前最短路径和前驱顶点</span></div><div class="line">        <span class="comment">// 即，当已经"顶点k的最短路径"之后，更新"未获取最短路径的顶点的最短路径和前驱顶点"。</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; mVexs.length; j++) &#123;</div><div class="line">            <span class="keyword">int</span> tmp = (mMatrix[k][j]==INF ? INF : (min + mMatrix[k][j]));</div><div class="line">            <span class="keyword">if</span> (flag[j]==<span class="keyword">false</span> &amp;&amp; (tmp&lt;dist[j]) ) &#123;</div><div class="line">                dist[j] = tmp;</div><div class="line">                prev[j] = k;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 打印dijkstra最短路径的结果</span></div><div class="line">    System.out.printf(<span class="string">"dijkstra(%c): \n"</span>, mVexs[vs]);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; mVexs.length; i++)</div><div class="line">        System.out.printf(<span class="string">"  shortest(%c, %c)=%d\n"</span>, mVexs[vs], mVexs[i], dist[i]);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="4-时间复杂度"><a href="#4-时间复杂度" class="headerlink" title="4.时间复杂度"></a>4.时间复杂度</h2><p>　　我们可以用大O符号将Dijkstra算法的运行时间表示为边数m和顶点数n的函数。</p>
<p>　　Dijkstra算法最简单的实现方法是用一个链表或者数组来存储所有顶点的集合Q,所以搜索Q中最小元素的运算(Extract-Min(Q))只需要线性搜索Q中的所有元素。这样的话算法的运行时间是O(n2)。</p>
<p>　　对于边数少于n2稀疏图来说，我们可以用邻接表来更有效的实现Dijkstra算法。同时需要将一个二叉堆或者斐波纳契堆用作优先队列来寻找最小的顶点(Extract-Min)。当用到二叉堆的时候，算法所需的时间为O((m+n)log n)，斐波纳契堆能稍微提高一些性能，让算法运行时间达到O(m + n log n)。 相关问题和算法</p>
<p>　　在Dijkstra算法的基础上作一些改动，可以扩展其功能。例如，有时希望在求得最短路径的基础上再列出一些次短的路径。为此，可先在原图上计算出最短路径，然后从图中删去该路径中的某一条边，在余下的子图中重新计算最短路径。对于原最短路径中的每一条边，均可求得一条删去该边后子图的最短路径，这些路径经排序后即为原图的一系列次短路径。</p>
<p>　　<code>OSPF</code>（[open shortest path first-<strong>开放最短路径优先</strong>）算法是Dijkstra算法在网络路由中的一个具体实现。</p>
<p>　　与Dijkstra算法不同，Bellman-Ford算法可用于具有负花费边的图，只要图中不存在总花费为负值且从源点 s 可达的环路（如果有这样的环路，则最短路径不存在，因为沿环路循环多次即可无限制的降低总花费）。</p>
<p>　　与最短路径问题有关的一个问题是<strong>旅行商问题</strong>，它要求找出通过所有顶点恰好一次且最终回到源点的最短路径。该问题是NP难的；换言之，与最短路径问题不同，旅行商问题不太可能具有多项式时间算法。</p>
<p>　　如果有已知信息可用来估计某一点到目标点的距离，则可改用<code>A*算法</code>，以减小最短路径的搜索范围。</p>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[rip协议配置]]></title>
      <url>/2017/03/28/rip_config_experiment/</url>
      <content type="html"><![CDATA[<p><strong>课题: </strong> 实验1__rip2协议配置</p>
<p><strong>Group7 </strong></p>
<p><strong>环境:</strong> eNSP</p>
<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><h3 id="路由-routing"><a href="#路由-routing" class="headerlink" title="路由(routing)"></a>路由(routing)</h3><p>​    就是通过互联的网络把信息从源地址传输到目的地址的活动。 <strong>路由</strong>发生在OSI网络参考模型中的第三层即网路层。 <strong>路由</strong>引导分组转送，经过一些中间的节点后，到它们最后的目的地。 作成硬件的话，则称为路由器。</p>
<ul>
<li><p>路由是指导IP报文发送的路径信息</p>
</li>
<li><p>路由的来源（Protocol）</p>
<p>(1). 链路层协议发现的路由</p>
<p>​    开销小，配置简单，无需人工维护。只能发现本接口所属网段的路由。</p>
<p>(2). 手工配置静态路由</p>
<p>​    无开销，配置简单，需人工维护，适合简单拓朴结构的网络。</p>
<p>(3). 动态路由协议发现的路由</p>
<p>​    开销大，配置复杂，无需人工维护，适合复杂拓朴结构的网络。</p>
</li>
<li><p>从优先级最高的协议获取的路由最先被优先选择加入路由表中。</p>
</li>
<li><p>路由的花费表示到达这条路由所指的目的地址的代价，通常以下因素会影响到路由的花费值。</p>
<p>​    线路延迟、带宽、线路占有率、线路可信度、跳数、最大传输单元</p>
</li>
<li><p>静态路由的花费值为0。不同的动态路由协议会选择以上的一种或几种因素来计算花费值。该花费值只在同一种路由协议内有比较意义。不同的路由协议之间的路由花费值没有可比性，也不存在换算关系.</p>
</li>
<li><p>动态路由协议是做什么的</p>
<p>​    计算路由的．计算本地路由器到网络中其它网段的路由．</p>
</li>
<li><p>如何做到这一点</p>
<p>​    每台路由器将自己已知的路由相关信息发给相邻的路由器，由于大家都这样做，最终每台路由器都会收到网络中所有的路由信息．然后运行某种算法，计算出最终的路由来．（实际上需要计算的是该条路由的下一跳和花费）</p>
</li>
<li><p>由同一机构管理，使用同一组选路策略的路由器的集合</p>
</li>
</ul>
<h3 id="RIP路由协议"><a href="#RIP路由协议" class="headerlink" title="RIP路由协议"></a>RIP路由协议</h3><p>​    RIP(Routing information Protocol)是应用较早、使用较普遍的内部网关协议(Interior Gateway Protocol,简称IGP)，适用于小型同类网络，是典型的距离向量(distance-vector)协议。文档见RFC1058、RFC1723。    RIP 通过广播UDP报文来交换路由信息，每30秒发送一次路由信息更新。RIP提供跳跃计数(hop count)作为尺度来衡量路由距离，跳跃计数是一个包到达目标所必须经过的路由器的数目。如果到相同目标有二个不等速或不同带宽的路由器，但跳跃计数相 同，则RIP认为两个路由是等距离的。RIP最多支持的跳数为15，即在源和目的网间所要经过的最多路由器的数目为15，跳数16表示不可达。</p>
<ul>
<li>RIP是Routing Information Protocol（路由信息协议）的简称</li>
<li>RIP路由协议是距离矢量路由协议的一个具体实现</li>
<li>RIP协议适用于中小型网络，有RIP-1和RIP-2</li>
<li>RIP-2使用组播（224.0.0.9）发送，支持验证和VLSM</li>
</ul>
<p><strong>RIP1和RIP2的区别：</strong></p>
<p>​       RIP分为RIP1与RIP2两个版本，区别如下：</p>
<ol>
<li>RIP1是一个有类路由协议，即所有的更新包中不含子网掩码，不支持VLSM， 所以就要求网络中所有设备必须使用相同的子网掩码，否则就会出错，而RIP2是一个无类的路由协议，它使用子网掩码。</li>
<li>RIP1是发送更新包的时候使用的是广播包，而RIP2默认使用的是组播224.0.0.9，也支持广播发送，这样相对于RIP1来说就节省了一部分网络带宽。</li>
<li>RIP2支持明文或者是 MD5验证，要求两台路由器在同步路由表的时候必须进行验证，通过才可以进行路由同步，这样可以加强安全性。</li>
</ol>
<h2 id="实验配置"><a href="#实验配置" class="headerlink" title="实验配置"></a>实验配置</h2><p><strong>网络拓扑图: </strong></p>
<p> <img src="\imgs\net\rip2\1.png" alt="1"></p>
<p> <strong><code>RTA</code> CLI配置命令</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&lt;Huawei&gt;sys</div><div class="line">[Huawei]sysname RTA</div><div class="line">[RTA]</div><div class="line">[RTA]interface GigabitEthernet0/0/0</div><div class="line">[RTA-GigabitEthernet0/0/0]ip address 11.0.0.11 255.0.0.0</div><div class="line">[RTA-GigabitEthernet0/0/0]rip version 2 broadcast</div><div class="line">[RTA-GigabitEthernet0/0/0]q</div><div class="line">[RTA]</div><div class="line">[RTA]interface Serial 0/0/0</div><div class="line">[RTA-Serial0/0/0]link-protocol ppp</div><div class="line">[RTA-Serial0/0/0]ip address 1.1.1.1 255.0.0.0</div><div class="line">[RTA-Serial0/0/0]rip version 2 broadcast</div><div class="line">[RTA-Serial0/0/0]rip authentication-mode md5 usual abc</div><div class="line">[RTA-Serial0/0/0]q</div><div class="line">[RTA]</div><div class="line">[RTA]rip </div><div class="line">[RTA-rip-1]network 11.0.0.0</div><div class="line">[RTA-rip-1]network 1.0.0.0</div></pre></td></tr></table></figure>
<p><strong><code>RTB</code> CLI配置命令</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">&lt;Huawei&gt;sys</div><div class="line">[Huawei]sysname RTB</div><div class="line">[RTB]</div><div class="line">[RTB]interface GigabitEthernet0/0/0</div><div class="line">[RTB-GigabitEthernet0/0/0]ip address 12.0.0.1 255.0.0.0</div><div class="line">[RTB-GigabitEthernet0/0/0]rip version 2 broadcast</div><div class="line">[RTB-GigabitEthernet0/0/0]q</div><div class="line">[RTB]</div><div class="line">[RTB]interface Serial 0/0/0</div><div class="line">[RTB-Serial0/0/0]link-protocol ppp</div><div class="line">[RTB-Serial0/0/0]ip address 1.1.1.2 255.0.0.0</div><div class="line">[RTB-Serial0/0/0]rip version 2 broadcast</div><div class="line">[RTB-Serial0/0/0]rip authentication-mode md5 usual abc</div><div class="line">[RTB-Serial0/0/0]q</div><div class="line">[RTB]</div><div class="line">[RTB]interface Serial 0/0/1</div><div class="line">[RTB-Serial0/0/1]link-protocol fr</div><div class="line">[RTB-Serial0/0/1]ip address 2.1.1.2 255.0.0.0</div><div class="line">[RTB-Serial0/0/1]rip version 2 broadcast</div><div class="line">[RTB]rip </div><div class="line">[RTB-rip-1]peer 2.1.1.1</div><div class="line">[RTB-rip-1]network 1.0.0.0</div><div class="line">[RTB-rip-1]network 2.0.0.0</div><div class="line">[RTB-rip-1]network 12.0.0.0</div></pre></td></tr></table></figure>
<p><strong><code>RTC</code> CLI配置命令</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&lt;Huawei&gt;sys</div><div class="line">[Huawei]sysname RTC</div><div class="line">[RTC]</div><div class="line">[RTC]interface GigabitEthernet0/0/0</div><div class="line">[RTC-GigabitEthernet0/0/0]ip address 13.0.0.1 255.0.0.0</div><div class="line">[RTC-GigabitEthernet0/0/0]rip version 2 broadcast</div><div class="line">[RTC-GigabitEthernet0/0/0]q</div><div class="line">[RTC]</div><div class="line">[RTC]interface Serial 0/0/1</div><div class="line">[RTC-Serial0/0/1]link-protocol fr</div><div class="line">[RTC-Serial0/0/1]fr interface-type DCE</div><div class="line">[RTC-Serial0/0/1]fr dlci 20</div><div class="line">[RTC-fr-dlci-Serial0/0/1-20]ip address 2.1.1.2 255.0.0.0</div><div class="line">[RTC-Serial0/0/1]rip version 2 broadcast</div><div class="line">[RTC]rip </div><div class="line">[RTB-rip-1]peer 2.1.1.2</div><div class="line">[RTC-rip-1]network 2.0.0.0</div><div class="line">[RTC-rip-1]network 13.0.0.0</div></pre></td></tr></table></figure>
<h2 id="实验情景1"><a href="#实验情景1" class="headerlink" title="实验情景1"></a>实验情景1</h2><p><strong><em>PC-A只rip E0,  PC-B rip E0,S0,S1,  PC-C ping A 是否能够ping 通？</em></strong></p>
<p>解：按照拓扑图配置好各路由端口，PC的IP，同时还原情景1.</p>
<p><code>RTA</code> CLI配置命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;RTA&gt;sys</div><div class="line">[RTA]undo rip 1</div><div class="line">[RTA]rip</div><div class="line">[RTA-rip-1]network 11.0.0.0</div></pre></td></tr></table></figure>
<p><code>RTB</code> CLI配置命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;RTB&gt;sys</div><div class="line">[RTB]undo rip 1</div><div class="line">[RTB]rip</div><div class="line">[RTB-rip-1]network 1.0.0.0</div><div class="line">[RTB-rip-1]network 2.0.0.0</div><div class="line">[RTB-rip-1]network 12.0.0.0</div></pre></td></tr></table></figure>
<p>PC-A 的rip截图如下：</p>
<p> <img src="\imgs\net\rip2\2.png" alt="2"></p>
<p>PC-B 的rip截图如下</p>
<p> <img src="\imgs\net\rip2\7.png" alt="7"></p>
<p>PC-C ping PC-A截图如下： <img src="\imgs\net\rip2\3.png" alt="3"></p>
<p>PC-C ping PC-B截图如下：</p>
<p><img src="\imgs\net\rip2\4.png" alt="4"></p>
<h2 id="实验情景2"><a href="#实验情景2" class="headerlink" title="实验情景2"></a>实验情景2</h2><p><strong><em>PC-A rip E0, S0，PC-B只 rip E0, S1, C ping A 是否能够ping 通？</em></strong></p>
<p>解：按照拓扑图配置好各路由端口，PC的IP，同时还原情景2.</p>
<p><code>RTA</code> CLI配置命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;RTA&gt;sys</div><div class="line">[RTA]undo rip 1</div><div class="line">[RTA]rip</div><div class="line">[RTA-rip-1]network 1.0.0.0</div><div class="line">[RTA-rip-1]network 11.0.0.0</div></pre></td></tr></table></figure>
<p><code>RTB</code> CLI配置命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;RTB&gt;sys</div><div class="line">[RTB]undo rip 1</div><div class="line">[RTB]rip</div><div class="line">[RTB-rip-1]network 2.0.0.0</div><div class="line">[RTB-rip-1]network 12.0.0.0</div></pre></td></tr></table></figure>
<p>PC-A 的rip截图如下：</p>
<p>  <img src="\imgs\net\rip2\5.png" alt="5"></p>
<p>PC-B 的rip截图如下：</p>
<p><img src="\imgs\net\rip2\8.png" alt="8"></p>
<p>PC-C ping PC-A截图如下： <img src="\imgs\net\rip2\10.png" alt="10"></p>
<h2 id="实验情景3"><a href="#实验情景3" class="headerlink" title="实验情景3"></a>实验情景3</h2><p><strong><em>A，B同时rip E0，S0, C ping A 是否能够ping 通？</em></strong></p>
<p>解：按照拓扑图配置好各路由端口，PC的IP，同时还原情景2.</p>
<p><code>RTA</code> CLI配置命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;RTA&gt;sys</div><div class="line">[RTA]undo rip 1</div><div class="line">[RTA]rip</div><div class="line">[RTA-rip-1]network 1.0.0.0</div><div class="line">[RTA-rip-1]network 11.0.0.0</div></pre></td></tr></table></figure>
<p><code>RTB</code> CLI配置命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;RTB&gt;sys</div><div class="line">[RTB]undo rip 1</div><div class="line">[RTB]rip</div><div class="line">[RTA-rip-1]network 1.0.0.0</div><div class="line">[RTB-rip-1]network 2.0.0.0</div><div class="line">[RTB-rip-1]network 12.0.0.0</div></pre></td></tr></table></figure>
<p>PC-A 的rip截图如下：</p>
<p> <img src="\imgs\net\rip2\5.png" alt="5"></p>
<p>PC-B 的rip截图如下：</p>
<p> <img src="\imgs\net\rip2\9.png" alt="9"></p>
<p>PC-C ping PC-A截图如下：</p>
<p><img src="\imgs\net\rip2\6.png" alt="6"></p>
<p>PC-C 的路由表截图如下：</p>
<p><img src="\imgs\net\rip2\11.png" alt="11"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>​    动态路由是网络中路由器之间互相通信，传递路由信息，利用收到的路由信息更新路由表的过程。它能实时地适应网络结构的变化。如果路由更新信息表明网络发生了变化，路由选择软件会重新计算路由，并发出新的路由更新信息。这信息通过各个网络，引起各路由器重新启动其路由算法，并更新各自的路由表以动态地反映网络拓扑的变化。</p>
<p>​    路由器接受到相邻路由器发送来的路由信息，会与自己的路由表中的条目进行比较，如果路由表中已经存在这条路由信息，路由器会比较新接收到的路由信息是否优于现在的条目，如果优于现在的条目，路由器会用新的路由信息替换原有的路由条目。反之，则路由器比较这条路由信息与原有的条目是否来自同一个源，如果来自同一个源，则更新，否则就忽略这条路由信息。</p>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 网络 </tag>
            
            <tag> 编程 </tag>
            
            <tag> 实验 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[三个实体型之间的多对多联系和两两之间的三个多对多联系的区别]]></title>
      <url>/2017/03/14/%E4%B8%89%E4%B8%AA%E5%AE%9E%E4%BD%93%E5%9E%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%A4%9A%E5%AF%B9%E5%A4%9A%E8%81%94%E7%B3%BB%E5%92%8C%E4%B8%A4%E4%B8%A4%E4%B9%8B%E9%97%B4%E7%9A%84%E4%B8%89%E4%B8%AA%E5%A4%9A%E5%AF%B9%E5%A4%9A%E8%81%94%E7%B3%BB%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[<p>​    </p>
<p>​    3 个实体型之间的多对多联系和 3 个实体型两两之间的 3 个多对多联系是不等价，因为它们拥有不同的语义，不同的量级。</p>
<ul>
<li><p>三个实体型之间的多对多联系如下图所示</p>
<p> <img src="http://pic002.cnblogs.com/images/2011/293214/2011110211325957.jpg" alt="img"></p>
</li>
<li><p>3 个实体型两两之间的三个多对多联系如下图所示</p>
<p>  <img src="http://pic002.cnblogs.com/images/2011/293214/2011110211331188.jpg" alt="img"></p>
</li>
</ul>
<p><strong>两者不等价，量级和语义不同。前者是一个关系，后者是3个关系；前者的要求更强，要求更为严格，后者的3个关系也无法连接成前者的1个关系。</strong></p>
<p>比如在后者中一个学生可以在一个教室中上自习，而该教室当前没有用于上课。</p>
<p>换句话说，前者的关系要求三个实体同时出现。而后者的3个关系中要求各个关系中涉及的两个实体同时出现，但从总体上看，在某个时刻，可能仅仅出现3个关系中1个或者2个，这与前者就不相同；也可能3个关系均出现，这个时候就与前者等价了。<strong>(即：“上课”这个联系的三要素是：“学生”、“教室”和“课程”，三者缺一不可，而“学习”这个联系，只要有“学生”和“教室”即可。)</strong></p>
<p>在物理模型上,两两之间的3个多对多关系(记为后者)存在数据冗余.<br>从数据一致性的角度看,前者三个实体只存在一个关系,数据间的相关性较高,要求严格,后者三个实体间两两各有一个关系,各关系的的数据相关性很低,在某个时刻,同一个实体允许不同数据的存在(即实体间的关系系和其他关系是独立的)</p>
<p>多个实体集之间的多对多联系定义：在两个以上多个实体集之间，当一个实体集与其它实体集之间均(<strong>注意是均</strong>)存在多对多联系，而其它实体集之间没有联系时，这种联系才称之为多个实体集之间的多对多联系。</p>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> 编程 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[网络命令详解ping、arp、ipconfig、tracert、route详解]]></title>
      <url>/2017/03/12/%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3ping%E3%80%81arp%E3%80%81ipconfig%E3%80%81tracert%E3%80%81route%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<h2 id="1、PING"><a href="#1、PING" class="headerlink" title="1、PING"></a>1、PING</h2><p>＞＞用的最多的命令，使用 ping可以测试计算机名和计算机的 ip 地址,验证与远程计算机的连接,该命令只有在安装了 tcp/ip 协议后才可以使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ping 域名 查看某个域名对应的ip地址，或者利用站长工具。</div></pre></td></tr></table></figure>
<h3 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h3><p><code>-t</code> ping 指定的计算机直到中断。ctrl c停止 例:c:>ping 160.219.1.8 -t</p>
<p><code>-a</code> 将地址解析为计算机名。例:c:>ping -a 160.219.1.8（如图）其中htsc-dc1 为计算机名</p>
<p><img src="https://segmentfault.com/img/bVp5O1" alt="img"></p>
<p><code>-l</code> 自定定义ping数据包大小单位字节，默认为 32 字节；最大值是 65,527。例:c:>ping 160.219.1.8 -l 1024</p>
<p><img src="https://segmentfault.com/img/bVp5O2" alt="img"></p>
<p><code>-n</code> 指定ping命令的执行次数，而不是默认的4次。例:c:>ping 160.219.1.8 -n 100 指定ping100次后结束</p>
<p>以上只是ping命令的常用参数其他参数可以用 ping -？进行查看。</p>
<p>特别提示：在ping命令执行过程中可以按<code>ctrl break</code>键可以查看当前ping的统计信息，而不用中断ping命令</p>
<h3 id="用ping命令检测网络故障的典型次序"><a href="#用ping命令检测网络故障的典型次序" class="headerlink" title="用ping命令检测网络故障的典型次序"></a>用ping命令检测网络故障的典型次序</h3><p>①<code>ping 127.0.0.1</code>：该命令被送到本地计算机而不会离开本机，如果没有收到应答包，就表示TCP/IP的安装或运行存在某些最基本的问题。</p>
<p>② ping 本机IP：该命令多用于手工配置IP地址的局域网用户，用户计算机始终都应该对该命令做出应答，如果没有收到应答，局域网用户应断开网络电缆，然后重新发送此命令，如果运行正确，则有可能是网络中有另一台计算机配置了相同的IP地址。若仍然有错，则表示本地配置或安装有问题。</p>
<p>③ ping 局域网内其它IP：该命令离开用户计算机，经过网卡和网络电缆到达其他计算机，再返回。收到应答表明本地网络的网卡和载体运行正确。若没有收到应答，则可能是子网掩码错误、网卡配置错误、或网络电缆不通。<br><code>同一个局域网内其它ip都可以被ping通吗？</code></p>
<p>④ ping 网关IP：若错误，表示网关地址错、或网关未启动，或到网关的线路不通。<br><code>怎样查看自己的网关？</code></p>
<p>⑤ ping 远程IP：若收到应答，表示网关运行正常，可以成功访问Internet。</p>
<p>⑥ ping localhost：localhost是127.0.0.1的别名，是操作系统的网络保留名，系统应该能够将该名字转换成该地址。如果有问题，则表示主机文件（/Windows/host）中存在问题。</p>
<p>⑦ <code>ping 域名</code>：执行此命令时，计算机会先将域名转换为IP地址，一般是通过DNS服务器。如果有问题，则可能DNS服务器地址配置错误或DNS服务器故障。该功能还可用于查看域名对应的IP地址。</p>
<p>如果以上所有ping命令都能正常运行，通常说明用户计算机进行本地和远程通信的功能基本具备。</p>
<p><code>特别说明</code>：ping不成功不意味着网络一定有问题，有些路由器和防火墙设置了过滤ping数据包的功能，因此当收不到返回包时，不一定说明网络有错。同样，ping命令的成功也不表示所有的网络配置都没有问题，例如，某些子网掩码错误就可能无法用这些方法检测到。</p>
<h2 id="ping命令补充"><a href="#ping命令补充" class="headerlink" title="ping命令补充"></a>ping命令补充</h2><p><img src="https://segmentfault.com/img/bVp52V" alt="img"></p>
<p>使用ipconfig产看缺省网关。</p>
<h2 id="2、ARP："><a href="#2、ARP：" class="headerlink" title="2、ARP："></a>2、ARP：</h2><p>》》显示和修改“地址解析协议”(ARP) 所使用的到以太网的 IP 或令牌环物理地址翻译表。该命令只有在安装了 TCP/IP 协议之后才可用。arp类型分为静态和动态，动态项目由系统自动创建保存时间大概15-20分钟，静态项目有管理员手工输入创建，永久保存但重启后会失效。</p>
<p><code>多次提到的缓存是什么鬼？</code></p>
<p>常用参数</p>
<p>-a 用于查看所有网络接口缓存中的项目。包括IP地址mac地址和类型 例:c:>arp -a</p>
<p><img src="https://segmentfault.com/img/bVp524" alt="img"></p>
<p>-a ip 用于查看指定目的ip缓存中的项目。例:c:>arp -a 160.219.0.3</p>
<p>-d 用于清除所有网络接口的arp缓存。例:c:>arp -d</p>
<p>-d ip 用于清除指定目的IP的arp缓存。例:c:>arp -d 160.219.0.3</p>
<p>-s 增加一条静态arp项。例:c:>arp -s 157.55.85.212 00-aa-00-62-c6-09</p>
<p>以上仅为arp命令的常用参数更多参数可以输入apr /?查看</p>
<p><img src="https://segmentfault.com/img/bVp528" alt="img"></p>
<p><img src="https://segmentfault.com/img/bVp529" alt="img"></p>
<h2 id="3、ipconfig"><a href="#3、ipconfig" class="headerlink" title="3、ipconfig"></a>3、ipconfig</h2><p>》》显示所有当前的 TCP/IP 网络配置值、刷新<code>动态主机配置协议 (DHCP)</code>和域名系统 (DNS) 设置。</p>
<h3 id="常用参数-1"><a href="#常用参数-1" class="headerlink" title="常用参数"></a>常用参数</h3><p>/all 显示所有适配器的完整 TCP/IP 配置信息。相对于不带-all参数显示的内容更完整包括当前计算机名、mac地址、网卡描述、dns设置等信息。例:c:>ipconfig /all</p>
<p>举例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">在盘符提示符中输入： ipconfig /all 后回车。</div><div class="line">显示如下:</div><div class="line">Windows IP Configuration 【Windows IP 配置】（中文意思，下同）</div><div class="line">    Host Name . . . . . . . . . . . . : PCNAME 【域中计算机名、主机名】</div><div class="line">    Primary Dns Suffix . . . . . . . : 【主 DNS 后缀】</div><div class="line">    Node Type . . . . . . . . . . . . : Unknown 【节点类型】</div><div class="line">    IP Routing Enabled. . . . . . . . : No 【IP路由服务是否启用】</div><div class="line">    WINS Proxy Enabled. . . . . . . . : No 【WINS代理服务是否启用 】</div><div class="line">Ethernet adapter: 【本地连接】</div><div class="line">    Connection-specific DNS Suffix : 【连接特定的DNS后缀】</div><div class="line">    Description . . . . . . . . . . . : Realtek RTL8168/8111 PCI-E Gigabi 【网卡型号描述】</div><div class="line">    Physical Address. . . . . . . . . : 00-1D-7D-71-A8-D6 【网卡MAC地址】</div><div class="line">    DHCP Enabled. . . . . . . . . . . : No 【动态主机设置协议是否启用】</div><div class="line">    IP Address. . . . . . . . . . . . : 192.168.90.114 【IP地址】</div><div class="line">    Subnet Mask . . . . . . . . . . . : 255.255.255.0 【子网掩码】</div><div class="line">    Default Gateway . . . . . . . . . : 192.168.90.254 【默认网关】</div><div class="line">    DHCP Server. . . . . . . . . : 192.168.90.88 【DHCP管理者机子IP】</div><div class="line">    DNS Servers . . . . . . . . . . . : 221.5.88.88 【DNS服务器地址】</div><div class="line">    Lease Obtained. . . . . . . . . . . : 2011年4月1号 8：13：54 【IP地址租用开始时间】</div><div class="line">    Lease Expires . . . . . . . .. . . .: 2011年4月10号 8：13：54 【IP地址租用结束时间】</div><div class="line">    </div><div class="line">时间不太够，有空大家一起来完善。</div></pre></td></tr></table></figure>
<p>/release 如果网卡ip设置为自动获取此参数可以向DHCP 服务器发送重新获得ip的请求，以释放所有适配器或特定适配器的当前 DHCP 配置并丢弃 IP 地址配置。例:c:>ipconfig /release<br><code>不懂</code><br>还有两个比较常用的参数就是release和renew了，一般情况下，这两个参数是一起使用的，ipconfig/release为释放现有的IP地址，ipconfig/renew命令则是向DHCP服务器发出请求，并租用一个IP地址。但是一般情况下使用ipconfig/renew获得的IP地址和之前的地址一样，只有在原有的地址被占用的情况下才会获得一个新的地址。</p>
<p>/flushdns 清除当前dns缓存，如果修改了dns服务器想要立即生效可以使用此命令 例:c:>ipconfig /flushdns</p>
<h2 id="4、Tracert"><a href="#4、Tracert" class="headerlink" title="4、Tracert"></a>4、Tracert</h2><p>》》（跟踪路由）是路由跟踪实用程序，用于确定 IP 数据报访问目标所采取的路径。Tracert 命令用 IP 生存时间 (TTL) 字段和 ICMP 错误消息来确定从一个主机到网络上其他主机的路由。最多30跳。</p>
<p>-d 防止 tracert 试图将中间路由器的 IP 地址解析为它们的名称。这样可加速显示 tracert 的结果。例;c:>tracert -d 8.8.8.8</p>
<p>-h 指定搜索目标的路径中存在的跃点的最大数。默认值为 30 个跃点。例:c:>tracert -d -h 5 8.8.8.8</p>
<h2 id="5、route"><a href="#5、route" class="headerlink" title="5、route"></a>5、route</h2><p>》》用于显示和修改本地的路由表</p>
<h3 id="常用命令和参数"><a href="#常用命令和参数" class="headerlink" title="常用命令和参数"></a>常用命令和参数</h3><p>print 显示本地路由表。例:c:>route print</p>
<p>add 添加路由条目</p>
<p>例：要添加目标为 10.41.0.0，子网掩码为 255.255.0.0，下一个跃点地址为 10.27.0.1 的路由，请键入：route add 10.41.0.0 mask 255.255.0.0 10.27.0.1</p>
<p>change 更改现存路由条目</p>
<p>例：要将目标为 10.41.0.0，子网掩码为 255.255.0.0 的路由的下一个跃点地址由 10.27.0.1 更改为 10.27.0.25，请键入：route change 10.41.0.0 mask 255.255.0.0 10.27.0.25</p>
<p>delete 删除路由条目</p>
<p>例：要删除目标为 10.41.0.0，子网掩码为 255.255.0.0 的路由，请键入：route delete 10.41.0.0 mask 255.255.0.0</p>
<p>-f 清除所有不是主路由（网掩码为 255.255.255.255 的路由）、环回网络路由（目标为 127.0.0.0，网掩码为 255.255.255.0 的路由）或多播路由（目标为 224.0.0.0，网掩码为 240.0.0.0 的路由）的条目的路由表。如果它与命令之一（例如 add、change 或 delete）结合使用，表会在运行命令之前清除。</p>
<p>-p 默认情况下添加路由条目在系统重启后会丢失，使用“-p”参数后指定路由被添加到注册表并在启动系统的时候初始化 IP 路由表。（静态路由）例:c:>route -p add 10.41.0.0 mask 255.255.0.0 10.27.0.1</p>
<p>以上这些都是windows下网管员常用的一些网络命令，更高级的功能可以查看命令帮助 “命令 /?”</p>
<h2 id="路由概念-route-print"><a href="#路由概念-route-print" class="headerlink" title="路由概念 route print"></a>路由概念 route print</h2><p>》》通过路由器将数据从一个网络传输到另一个网络称之为路由。路由选择负责在网络中选择一段最优先的路径将数据传输到目的网络，路由选择的基础和依据是路由表，路由表由目的网络ID、子网掩码、网关、接口和计费组成，通过route print可查看计算机的路由表。</p>
<p><img src="https://segmentfault.com/img/bVp5TS" alt="img"></p>
<p><code>路由表规则怎么起作用的我忘了</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">IPv4 Route Table</div><div class="line">　　===========================================================================</div><div class="line">　　Interface List</div><div class="line">　　0x1 ........................... MS TCP Loopback interface</div><div class="line">　　0x10003 ...00 03 ff 25 88 8c ...... Intel 21140-Based PCI Fast Ethernet Adapter</div><div class="line">　　(Generic)</div><div class="line">　　===========================================================================</div><div class="line">　　===========================================================================</div><div class="line">　　Active Routes:</div><div class="line">　　Network Destination     Netmask        Gateway     Interface     Metric</div><div class="line">　　0.0.0.0                 0.0.0.0        172.16.11.1 172.16.11.30  20</div><div class="line">　　127.0.0.0               255.0.0.0      127.0.0.1   127.0.0.1     1</div><div class="line">　　172.16.11.0             255.255.255.0  172.16.11.30 172.16.11.30 20</div><div class="line">　　172.16.11.30            255.255.255.255 127.0.0.1  127.0.0.1     20</div><div class="line">　　172.16.255.255          255.255.255.255 172.16.11.30 172.16.11.30 20    </div><div class="line">　　224.0.0.0               240.0.0.0       172.16.11.30 172.16.11.30 20</div><div class="line">　　255.255.255.255         255.255.255.255 172.16.11.30 172.16.11.30 1</div><div class="line">　　Default Gateway: 172.16.11.1</div><div class="line">　　===========================================================================</div><div class="line">　　Persistent Routes:</div><div class="line">　　None</div></pre></td></tr></table></figure>
<p>路由表中每一个路由表项(或路由)都由五个字段组成：<br>　　网络目标地址(Network Destination)：代表某个可能的目的地址，它是一个IP地址或子网，即表示IP数据包被转发到何处的地址。<code>好理解</code><br>　　掩码(Netmask):一个用于将某数据包中的IP地址中的目标地址字段与上面可能的网络地址匹配起来的位模式。<code>好理解，和目标地址配合使用</code><br>　　网关(Gateway)：<code>下一跳的IP地址</code>，数据包必须被转发到此，才能到达特定的目的网络。<br>　　<code>接口(Interface)</code>：下一跳的接口，这个接口必须用于将数据包进行转发，以达到特定的目的网络。<br>　　<code>跳数(metric)</code>:表示到达目的的过程中经过了多少跳数(路由器数)，即路由的成本。</p>
<p><code>有了网关及目标地址还要接口做什么？</code></p>
<p>示例一：目标主机在本地子网上<br>　　假设这个服务器(172.16.11.30)要将数据包发往同一子网内的另一台主机(IP地址为172.16.11.80)。那么这个数据包的源地址为172.16.11.30，目标地址为172.16.11.80。下面我们将展示Windows是如何用其路由表来决定选择使用哪条路由的：<br>　　1、 Windows首先依次从路由表中取出每一个路由，并将数据包的目标地址(172.16.11.80)与选中路由的掩码执行逻辑“与”运算。下面展示结果，这里，路由表中的每一个路由是通过其网络目的地址确定的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Route                   Netmask           172.16.11.80 AND Netmask</div><div class="line">0.0.0.0                 0.0.0.0           0.0.0.0</div><div class="line">127.0.0.0               255.0.0.0         172.0.0.0</div><div class="line">172.16.11.0             255.255.255.0     172.16.11.0</div><div class="line">172.16.11.30            255.255.255.255   172.16.11.80</div><div class="line">172.16.255.255          255.255.255.255   172.16.11.80</div><div class="line">224.0.0.0               224.0.0.0         160.0.0.0</div><div class="line">255.255.255.255         255.255.255.255   172.16.11.80</div></pre></td></tr></table></figure>
<p>2、对每一个路由来说，这个“与”运算的结果要与路由的网络目标地址比较，二者的一次匹配意味着这条路由可用于将数据包转发到其目标地址。如果发现不只有一个匹配，Windows就会选用拥有最长匹配的路由(即1的位数最高的路由)。如果这并没有产生唯一的路由，Windows就任意地选用一个作为路由。从上面的列表中，这个“与”运算的结果导致了两个匹配(路由1和3)，因此Windows选择了拥有最长匹配的路由，即第三行的那个。其结果是Windows知道了使用哪个路由将数据包传送到目的地。下面是这条路由在服务器的路由表中看起来的样子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">　　Network Destination   Netmask     　 Gateway        　Interface   Metric</div><div class="line">　　172.16.11.0           255.255.255.0  172.16.11.30 　　172.16.11.30   20</div></pre></td></tr></table></figure>
<p>　　3、 Windows现在要使用下面的算法来决定下一步做什么：<br>　　a) 如果路由的网关字段与服务器上的一个网络接口的地址相匹配(或者如果网关是空的话)，那么Windows就会用在路由中指定的接口将数据包直接发送到目标地址。<br>　　b) 如果路由的网关字段并不与服务器上网络接口的任意地址相匹配，Windows将会把数据包转发给路由中的网关字段的地址。<br>　　很明显，这里符合条件a，路由的网关字段(172.16.11.30)即为分配给服务器单个网卡的地址。Windows因此会作出决定认为目标地址位于本地子网上，这也就是说Windows不需要将数据包发送到任何路由器，而是直接发送给其目的地址。在此例中，Windows使用服务器的172.16.11.30的网络接口，简单地将数据包发送给172.16.11.80，接收主机得到了数据包。</p>
<p>示例二：目标主机在远程子网上<br>　　现在，让我们继续同样的过程，不过这次我们假定服务器想把数据包发往一个不同子网上的一台主机(IP地址为172.16.10.200)。换句话说，数据包的源地址为172.16.11.30，目标地址为172.16.10.200。下面我们看一下Windows是如何利用路由表决定选择哪条路由的： 网管网bitsCN_com<br>　　1、Windows从路由表中取出每一条路由，将数据包的目标地址(172.16.10.200)与路由中的掩码进行“与” 运算。运算结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Route           Netmask                  172.16.10.200 AND Netmask</div><div class="line">0.0.0.0         0.0.0.0                   0.0.0.0</div><div class="line">127.0.0.0       255.0.0.0                 172.0.0.0 </div><div class="line">172.16.11.0     255.255.255.0             172.16.10.0</div><div class="line">172.16.11.30    255.255.255.255           172.16.10.200 </div><div class="line">172.16.255.255  255.255.255.255           172.16.10.200</div><div class="line">224.0.0.0       224.0.0.0                 160.0.0.0 </div><div class="line">255.255.255.255 255.255.255.255           172.16.10.200</div></pre></td></tr></table></figure>
<p>2、对于每一条路由来说，“与”运算的结果要与路由中网络目标地址相比较，二者匹配意味着这条路由可被用于将数据包转发到其目标地址。从我们上面的第二张路由表，你可以看出这次只有一个匹配，也就是说是第一行，这个路由的网络目地字段(0.0.0.0)与“与”运算的结果匹配。因此Windows用来将数据包转发到其目标地址的路由即为下面的路由：</p>
<p>　　Network Destination 　　　Netmask 　　　　Gateway 　　　　Interface Metric<br>　　0.0.0.0 　　　　　　　　　　0.0.0.0 　　　172.16.11.1　　 172.16.11.30 20<br>　　3. 然后Windows就会使用前述的算法来决定下一步做什么，这次符合条件b，因为路由的网关字段(172.16.11.1)与分配给服务器的单独网卡的地址(172.16.11.30)并不匹配。Windows因此会决定目标地址位于一个远程子网上，将数据包转发给路由器，路由器通过继续转发数据包将其传送到目的地。在此例中，Windows使用服务器的172.16.11.30网络接口，将数据包发送到在网关字段中所显示的地址。一旦位于172.16.11.1的路由器收到了数据包，它会决定下一步需要采取什么步骤，才能将数据包转发到其最后的目标地址172.16.10.200，而这又依赖于172.16.11.10/24网络是172.16.11.11/24(由单个路由器连接)或一个远程网络的邻近子网(由几个中间网络之间的路由器连接)。</p>
<h2 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h2><p>netstat -s——本选项能够<code>按照各个协议</code>分别显示其统计数据。如果你的应用程序（如Web浏览器）运行速度比较慢，或者不能显示Web页之类的数据，那么你就可以用本选项来查看一下所显示的信息。你需要仔细查看统计数据的各行，找到出错的关键字，进而确定问题所在。</p>
<p><img src="https://segmentfault.com/img/bVp53b" alt="img"></p>
<p><img src="https://segmentfault.com/img/bVp53c" alt="img"></p>
<p><img src="https://segmentfault.com/img/bVp53d" alt="img"></p>
<p>netstat -e——本选项用于<code>显示关于以太网的统计数据</code>。它列出的项目包括传送的数据报的总字节数、错误数、删除数、数据报的数量和广播的数量。这些统计数据既有发送的数据报数量，也有接收的数据报数量。这个选项可以用来统计一些基本的网络流量。</p>
<p><img src="https://segmentfault.com/img/bVp53f" alt="img"></p>
<p>netstat -r——本选项可以显示关于路由表的信息，类似于后面所讲使用route print命令时看到的 信息。除了显示有效路由外，还显示当前有效的连接。</p>
<p>netstat -a——本选项显示一个所有的有效连接信息列表，包括已建立的连接（ESTABLISHED），也包括<code>监听连接请求（LISTENING）</code>的那些连接，<code>断开连接（CLOSE_WAIT）</code>或者处于<code>联机等待状态的（TIME_WAIT）</code>等</p>
<p>netstat -n——显示所有已建立的有效连接。 好像不会显示listening的。</p>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> 命令 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[命令行学习笔记：网络相关命令]]></title>
      <url>/2017/03/12/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<h1 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h1><blockquote>
<p>网络相关：ping, telnet, curl, netstat，修改ip, dns, hosts</p>
</blockquote>
<h1 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h1><hr>
<h2 id="ping"><a href="#ping" class="headerlink" title="ping"></a><strong>ping</strong></h2><p><strong>简述：</strong><br>Linux 系统的ping 命令是常用的网络命令，它<strong>通常用来测试与目标主机的连通性</strong>。比如：我们经常说的ping一下某主机看是否能够访问到、不能打开网页的时候先ping 网关地址192.168.1.1尝试默认网关是否能够联通。它通过发送ICMP ECHO_REQUEST数据包到网络主机（send ICMP ECHO_REQUEST to network hosts），并显示响应情况，这样我们就可以根据它输出的信息来确定目标主机是否可访问（但这不是绝对的）。有些服务器为了防止通过ping探测到，通过防火墙设置了禁止ping或者在内核参数中禁止ping，这样就不能通过ping确定该主机是否还处于开启状态.</p>
<p><strong>命令格式：</strong><br><code>ping [参数] [主机名或IP地址]</code></p>
<p><strong>功能：</strong></p>
<ul>
<li>确定网络和各外部主机的状态；</li>
<li>跟踪和隔离硬件和软件问题；</li>
<li>测试、评估和管理网络。</li>
</ul>
<p>如果主机正在运行并连在网上，它就对回送信号进行响应。每个回送信号请求包含一个网际协议（IP）和 ICMP 头，后面紧跟一个 tim 结构，以及来填写这个信息包的足够的字节。缺省情况是连续发送回送信号请求直到接收到中断信号（Ctrl-C）。</p>
<p><strong>参数：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">-d 使用Socket的SO_DEBUG功能。</div><div class="line">-f  极限检测。大量且快速地送网络封包给一台机器，看它的回应。</div><div class="line">-n 只输出数值。</div><div class="line">-q 不显示任何传送封包的信息，只显示最后的结果。</div><div class="line">-r 忽略普通的Routing Table，直接将数据包送到远端主机上。通常是查看本机的网络接口是否有问题。</div><div class="line">-R 记录路由过程。</div><div class="line">-v 详细显示指令的执行过程。</div><div class="line">&lt;p&gt;-c 数目：在发送指定数目的包后停止。</div><div class="line">-i 秒数：设定间隔几秒送一个网络封包给一台机器，预设值是一秒送一次。</div><div class="line">-I 网络界面：使用指定的网络界面送出数据包。</div><div class="line">-l 前置载入：设置在送出要求信息之前，先行发出的数据包。</div><div class="line">-p 范本样式：设置填满数据包的范本样式。</div><div class="line">-s 字节数：指定发送的数据字节数，预设值是56，加上8字节的ICMP头，一共是64ICMP数据字节。</div><div class="line">-t 存活数值：设置存活数值TTL的大小。</div></pre></td></tr></table></figure>
<p><strong>实例：</strong></p>
<ul>
<li>ping 不通的情况</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">➜  ~ ping 192.168.1.99</div><div class="line">PING 192.168.1.99 (192.168.1.99) 56(84) bytes of data.</div><div class="line">From 192.168.1.196 icmp_seq=1 Destination Host Unreachable</div><div class="line">From 192.168.1.196 icmp_seq=2 Destination Host Unreachable</div><div class="line">From 192.168.1.196 icmp_seq=3 Destination Host Unreachable</div><div class="line">From 192.168.1.196 icmp_seq=4 Destination Host Unreachable</div><div class="line">From 192.168.1.196 icmp_seq=5 Destination Host Unreachable</div><div class="line">From 192.168.1.196 icmp_seq=6 Destination Host Unreachable</div><div class="line">From 192.168.1.196 icmp_seq=7 Destination Host Unreachable</div><div class="line">From 192.168.1.196 icmp_seq=8 Destination Host Unreachable</div><div class="line">From 192.168.1.196 icmp_seq=9 Destination Host Unreachable</div><div class="line">^C</div><div class="line">--- 192.168.1.99 ping statistics ---</div><div class="line">12 packets transmitted, 0 received, +9 errors, 100% packet loss, time 11064ms</div><div class="line">pipe 3</div></pre></td></tr></table></figure>
<ul>
<li>ping 通的情况</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">➜  ~ ping 192.168.1.123</div><div class="line">PING 192.168.1.123 (192.168.1.123) 56(84) bytes of data.</div><div class="line">64 bytes from 192.168.1.123: icmp_seq=1 ttl=128 time=1.65 ms</div><div class="line">64 bytes from 192.168.1.123: icmp_seq=2 ttl=128 time=0.844 ms</div><div class="line">64 bytes from 192.168.1.123: icmp_seq=3 ttl=128 time=0.959 ms</div><div class="line">64 bytes from 192.168.1.123: icmp_seq=4 ttl=128 time=0.736 ms</div><div class="line">64 bytes from 192.168.1.123: icmp_seq=5 ttl=128 time=0.732 ms</div><div class="line">^C</div><div class="line">--- 192.168.1.123 ping statistics ---</div><div class="line">5 packets transmitted, 5 received, 0% packet loss, time 4002ms</div><div class="line">rtt min/avg/max/mdev = 0.732/0.984/1.653/0.346 ms</div></pre></td></tr></table></figure>
<ul>
<li>ping 网关</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">➜  ~ ping -b 192.168.1.1</div><div class="line">PING 192.168.1.1 (192.168.1.1) 56(84) bytes of data.</div><div class="line">64 bytes from 192.168.1.1: icmp_seq=1 ttl=64 time=0.211 ms</div><div class="line">64 bytes from 192.168.1.1: icmp_seq=2 ttl=64 time=0.225 ms</div><div class="line">64 bytes from 192.168.1.1: icmp_seq=3 ttl=64 time=0.222 ms</div><div class="line">64 bytes from 192.168.1.1: icmp_seq=4 ttl=64 time=0.182 ms</div><div class="line">64 bytes from 192.168.1.1: icmp_seq=5 ttl=64 time=0.464 ms</div><div class="line">64 bytes from 192.168.1.1: icmp_seq=6 ttl=64 time=0.224 ms</div><div class="line">^C</div><div class="line">--- 192.168.1.1 ping statistics ---</div><div class="line">6 packets transmitted, 6 received, 0% packet loss, time 4999ms</div><div class="line">rtt min/avg/max/mdev = 0.182/0.254/0.464/0.096 ms</div></pre></td></tr></table></figure>
<ul>
<li>ping 指定次数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">➜  ~ ping -c 3 192.168.1.1</div><div class="line">PING 192.168.1.1 (192.168.1.1) 56(84) bytes of data.</div><div class="line">64 bytes from 192.168.1.1: icmp_seq=1 ttl=64 time=1.22 ms</div><div class="line">64 bytes from 192.168.1.1: icmp_seq=2 ttl=64 time=0.360 ms</div><div class="line">64 bytes from 192.168.1.1: icmp_seq=3 ttl=64 time=0.382 ms</div><div class="line"></div><div class="line">--- 192.168.1.1 ping statistics ---</div><div class="line">3 packets transmitted, 3 received, 0% packet loss, time 2000ms</div><div class="line">rtt min/avg/max/mdev = 0.360/0.654/1.221/0.401 ms</div></pre></td></tr></table></figure>
<ul>
<li>ping 指定时间间隔</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">➜  ~ ping -i 0.5 192.168.1.123</div><div class="line">PING 192.168.1.123 (192.168.1.123) 56(84) bytes of data.</div><div class="line">64 bytes from 192.168.1.123: icmp_seq=1 ttl=128 time=1.14 ms</div><div class="line">64 bytes from 192.168.1.123: icmp_seq=2 ttl=128 time=0.999 ms</div><div class="line">64 bytes from 192.168.1.123: icmp_seq=3 ttl=128 time=0.822 ms</div><div class="line">64 bytes from 192.168.1.123: icmp_seq=4 ttl=128 time=0.952 ms</div><div class="line">64 bytes from 192.168.1.123: icmp_seq=5 ttl=128 time=0.847 ms</div><div class="line">64 bytes from 192.168.1.123: icmp_seq=6 ttl=128 time=0.957 ms</div><div class="line">64 bytes from 192.168.1.123: icmp_seq=7 ttl=128 time=0.848 ms</div><div class="line">^C</div><div class="line">--- 192.168.1.123 ping statistics ---</div><div class="line">7 packets transmitted, 7 received, 0% packet loss, time 3001ms</div><div class="line">rtt min/avg/max/mdev = 0.822/0.938/1.141/0.103 ms</div></pre></td></tr></table></figure>
<ul>
<li>ping 指定时间间隔和指定次数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">➜  ~ ping -c5 -i 0.5 192.168.1.123</div><div class="line">PING 192.168.1.123 (192.168.1.123) 56(84) bytes of data.</div><div class="line">64 bytes from 192.168.1.123: icmp_seq=1 ttl=128 time=0.775 ms</div><div class="line">64 bytes from 192.168.1.123: icmp_seq=2 ttl=128 time=0.941 ms</div><div class="line">64 bytes from 192.168.1.123: icmp_seq=3 ttl=128 time=0.888 ms</div><div class="line">64 bytes from 192.168.1.123: icmp_seq=4 ttl=128 time=0.761 ms</div><div class="line">64 bytes from 192.168.1.123: icmp_seq=5 ttl=128 time=0.991 ms</div><div class="line"></div><div class="line">--- 192.168.1.123 ping statistics ---</div><div class="line">5 packets transmitted, 5 received, 0% packet loss, time 2000ms</div><div class="line">rtt min/avg/max/mdev = 0.761/0.871/0.991/0.092 ms</div></pre></td></tr></table></figure>
<ul>
<li>ping 公网上站点</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">➜  ~ ping -c 5 www.sina.com</div><div class="line">PING cernetnews.sina.com.cn (121.194.0.239) 56(84) bytes of data.</div><div class="line">64 bytes from 121.194.0.239: icmp_seq=1 ttl=50 time=21.3 ms</div><div class="line">64 bytes from 121.194.0.239: icmp_seq=2 ttl=50 time=18.7 ms</div><div class="line">64 bytes from 121.194.0.239: icmp_seq=3 ttl=50 time=17.8 ms</div><div class="line">64 bytes from 121.194.0.239: icmp_seq=4 ttl=50 time=19.7 ms</div><div class="line">64 bytes from 121.194.0.239: icmp_seq=5 ttl=50 time=18.3 ms</div><div class="line"></div><div class="line">--- cernetnews.sina.com.cn ping statistics ---</div><div class="line">5 packets transmitted, 5 received, 0% packet loss, time 4007ms</div><div class="line">rtt min/avg/max/mdev = 17.860/19.218/21.344/1.248 ms</div></pre></td></tr></table></figure>
<ul>
<li>ping 多参数使用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">➜  ~ ping -i 0.5 -c 5 -s 512 -t 255 192.168.1.123</div><div class="line">PING 192.168.1.123 (192.168.1.123) 512(540) bytes of data.</div><div class="line">520 bytes from 192.168.1.123: icmp_seq=1 ttl=128 time=1.64 ms</div><div class="line">520 bytes from 192.168.1.123: icmp_seq=2 ttl=128 time=1.05 ms</div><div class="line">520 bytes from 192.168.1.123: icmp_seq=3 ttl=128 time=1.68 ms</div><div class="line">520 bytes from 192.168.1.123: icmp_seq=4 ttl=128 time=1.45 ms</div><div class="line">520 bytes from 192.168.1.123: icmp_seq=5 ttl=128 time=1.66 ms</div><div class="line"></div><div class="line">--- 192.168.1.123 ping statistics ---</div><div class="line">5 packets transmitted, 5 received, 0% packet loss, time 2004ms</div><div class="line">rtt min/avg/max/mdev = 1.051/1.500/1.683/0.239 ms</div></pre></td></tr></table></figure>
<hr>
<h2 id="telnett"><a href="#telnett" class="headerlink" title="telnett"></a><strong>telnett</strong></h2><p>  <strong>简述：　　telnet命令通常用来远程登录。</strong> <strong>telnet程序</strong>是基于<code>TELNET协议</code>的<code>远程登录客户端程序</code>。<strong>Telnet协议</strong>是<code>TCP/IP协议族中的一员</code>，是<code>Internet远程登陆服务的标准协议和主要方式</code>。它为用户提供了在本地计算机上完成远程主机工作的 能力。在终端使用者的电脑上使用telnet程序，用它连接到服务器。终端使用者可以在telnet程序中输入命令，这些命令会在服务器上运行，就像直接在服务器的控制台上输入一样。可以在本地就能控制服务器。要开始一个 telnet会话，必须输入用户名和密码来登录服务器。<strong>Telnet是常用的远程控制Web服务器的方法</strong>。<br>  　　<strong>但是，telnet因为采用明文传送报文，安全性不好，很多Linux服务器都不开放telnet服务，而改用更安全的ssh方式了</strong>。但仍然有很多别的系统可能采用了telnet方式来提供远程登录，因此弄清楚telnet客户端的使用方式仍是很有必要的。<br>  　　telnet命令还可做<strong>别的用途</strong>，比如<em>确定远程服务的状态</em>，比如<em>确定远程服务器的某个端口是否能访问</em>。</p>
<p><strong>命令格式</strong><br><code>telnet [参数][主机]</code></p>
<p><strong>功能</strong><br>执行 telnett 命令开启终端机器阶段作业，并登入远端主机。</p>
<p><strong>参数</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">-8 允许使用8位字符资料，包括输入与输出。</div><div class="line">-a 尝试自动登入远端系统。</div><div class="line">-b&lt;主机别名&gt; 使用别名指定远端主机名称。</div><div class="line">-c 不读取用户专属目录里的.telnetrc文件。</div><div class="line">-d 启动排错模式。</div><div class="line">-e&lt;脱离字符&gt; 设置脱离字符。</div><div class="line">-E 滤除脱离字符。</div><div class="line">-f 此参数的效果和指定&quot;-F&quot;参数相同。</div><div class="line">-F 使用Kerberos V5认证时，加上此参数可把本地主机的认证数据上传到远端主机。</div><div class="line">-k&lt;域名&gt; 使用Kerberos认证时，加上此参数让远端主机采用指定的领域名，而非该主机的域名。</div><div class="line">-K 不自动登入远端主机。</div><div class="line">-l&lt;用户名称&gt; 指定要登入远端主机的用户名称。</div><div class="line">-L 允许输出8位字符资料。</div><div class="line">-n&lt;记录文件&gt; 指定文件记录相关信息。</div><div class="line">-r 使用类似rlogin指令的用户界面。</div><div class="line">-S&lt;服务类型&gt; 设置telnet连线所需的IP TOS信息。</div><div class="line">-x 假设主机有支持数据加密的功能，就使用它。</div><div class="line">-X&lt;认证形态&gt; 关闭指定的认证形态。</div></pre></td></tr></table></figure>
<p><strong>实例</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">zhyingjia@zhyingjia-Inspiron-5437:~$ telnet 192.168.1.243 22</div><div class="line">Trying 192.168.1.243...</div><div class="line">Connected to 192.168.1.243.</div><div class="line">Escape character is &apos;^]&apos;.</div><div class="line">SSH-2.0-OpenSSH_5.3</div><div class="line"></div><div class="line">Protocol mismatch.</div><div class="line">Connection closed by foreign host.</div></pre></td></tr></table></figure>
<hr>
<h2 id="curl"><a href="#curl" class="headerlink" title="curl"></a><strong>curl</strong></h2><p><strong>简述：</strong>curl是一个利用URL规则在命令行下工作的文件传输工具。它支持文件的上传和下载，所以是综合传输工具，但按传统，习惯称url为下载工具。<br><strong>参数：</strong><br>参数太多啦, 用的时候在搜~<br><strong>实例：</strong></p>
<ul>
<li>抓取页面内容<br><code>curl -o/--output filename link</code> 把输出写到该文件中。<br><code>curl -O url</code>　后面的url要具体到某个文件，不然抓不下来。我们还可以用正则来抓取东西</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">➜  newDir ls</div><div class="line">➜  newDir curl -o shouhui.html http://www.jianshu.com/p/5dcce74fc415</div><div class="line">  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</div><div class="line">                                 Dload  Upload   Total   Spent    Left  Speed</div><div class="line">100 41120  100 41120    0     0  82488      0 --:--:-- --:--:-- --:--:-- 82404</div><div class="line">➜  newDir ls</div><div class="line">shouhui.html</div><div class="line">➜  newDir </div><div class="line"></div><div class="line">➜  newDir curl -O http://www.jianshu.com/p/5ead3cfb630b                 </div><div class="line">  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</div><div class="line">                                 Dload  Upload   Total   Spent    Left  Speed</div><div class="line">100 47028  100 47028    0     0    97k      0 --:--:-- --:--:-- --:--:--   97k</div><div class="line">➜  newDir ls</div><div class="line">5ead3cfb630b  shouhui.html</div><div class="line">➜  newDir</div></pre></td></tr></table></figure>
<ul>
<li>模拟登录<br><code>curl -c &lt;file&gt;</code> 操作结束后把cookie写入到这个文件中<br><code>curl -F &lt;name=content&gt;</code> 模拟http表单提交数据</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">➜  newDir curl -c ./cookie_c.txt -F log=aaaa -F pwd=****** http://www.2cto.com /wp-login.php</div><div class="line">&lt;html&gt;</div><div class="line">&lt;head&gt;&lt;title&gt;405 Not Allowed&lt;/title&gt;&lt;/head&gt;</div><div class="line">&lt;body bgcolor=&quot;white&quot;&gt;</div><div class="line">&lt;center&gt;&lt;h1&gt;405 Not Allowed&lt;/h1&gt;&lt;/center&gt;</div><div class="line">&lt;hr&gt;&lt;center&gt;nginx&lt;/center&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div><div class="line">curl: (3) &lt;url&gt; malformed</div></pre></td></tr></table></figure>
<ul>
<li>显示下载进度条<br><code>curl -#</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">➜  newDir ls</div><div class="line">5ead3cfb630b  shouhui.html</div><div class="line">➜  newDir curl -O -# http://www.jianshu.com/p/230efbd68016</div><div class="line">######################################################################## 100.0%</div><div class="line">➜  newDir ls</div><div class="line">230efbd68016  5ead3cfb630b  shouhui.html</div><div class="line">➜  newDir</div></pre></td></tr></table></figure>
<ul>
<li>断点续传<br><code>curl -C -O url</code> 下载比较打的文件可以使用 <code>-C</code>.</li>
</ul>
<hr>
<h2 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a><strong>netstat</strong></h2><p><strong>简述 ：</strong><br><code>netstat命令</code> <strong>用于显示与IP、TCP、UDP和ICMP协议相关的统计数据，一般用于检验本机各端口的网络连接情况</strong>。netstat是在内核中访问网络及相关信息的程序，它能提供TCP连接，TCP和UDP监听，进程内存管理的相关报告.<br><strong>常用参数：</strong><br><code>netstat -a</code> 显示端口信息<br><code>netstat -nu</code> 显示当前ＵＤＰ连接情况<br><code>netstat -apu</code> 显示当前ＵＤＰ端口号使用情况<br><code>netstat -i</code> 显示网卡列表<br><code>netstat -g</code>显示组播关系<br><code>netstat -l</code>显示监听的套接口<br><code>netstat -n</code>显示多有已建立的连接<br><code>netstat -e</code>显示关于以太网的统计数据<br><code>netstat -r</code>显示路由表信息<br><code>netstat -at</code>列出所有ＴＣＰ端口</p>
<p><strong>实例：</strong></p>
<ul>
<li>无参数使用</li>
</ul>
<p><code>netstat</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">Active Internet connections (w/o servers)</div><div class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State      </div><div class="line">tcp        0      1 192.168.1.197:38870     www.google.com.gr:https SYN_SENT   </div><div class="line">tcp        1      1 192.168.1.197:48054     121.194.7.192:http      LAST_ACK   </div><div class="line">tcp        0      1 192.168.1.197:38854     www.google.com.gr:https SYN_SENT   </div><div class="line">tcp        0      1 192.168.1.197:38860     www.google.com.gr:https SYN_SENT   </div><div class="line">tcp        0      1 192.168.1.197:38856     www.google.com.gr:https SYN_SENT   </div><div class="line">tcp        0      1 192.168.1.197:34186     prg03s05-in-f14.1:https SYN_SENT   </div><div class="line">tcp        1      1 192.168.1.197:36790     121.194.7.19:http       LAST_ACK   </div><div class="line">tcp        0      1 192.168.1.197:38858     www.google.com.gr:https SYN_SENT   </div><div class="line">tcp        0      1 192.168.1.197:38880     www.google.com.gr:https SYN_SENT   </div><div class="line">tcp        0      1 192.168.1.197:38852     www.google.com.gr:https SYN_SENT   </div><div class="line">tcp        0      1 192.168.1.197:38864     www.google.com.gr:https SYN_SENT   </div><div class="line">tcp        0      1 192.168.1.197:38884     www.google.com.gr:https SYN_SENT   </div><div class="line">tcp        1      1 192.168.1.197:45486     23.248.163.147:http     LAST_ACK   </div><div class="line">tcp        0      0 192.168.1.197:50202     hn.kd.ny.adsl:82        ESTABLISHED</div><div class="line"></div><div class="line">　　　... ... </div><div class="line">Active UNIX domain sockets (w/o servers)</div><div class="line">Proto RefCnt Flags       Type       State         I-Node   Path</div><div class="line">unix  2      [ ]         DGRAM                    22602    /run/user/1000/systemd/notify</div><div class="line">unix  8      [ ]         DGRAM                    568      /run/systemd/journal/socket</div><div class="line">unix  17     [ ]         DGRAM                    11639    /run/systemd/journal/dev-log</div><div class="line">unix  2      [ ]         DGRAM                    11642    /run/systemd/journal/syslog</div><div class="line">unix  3      [ ]         SEQPACKET  CONNECTED     31602    @0001b</div><div class="line">unix  2      [ ]         DGRAM                    17911    /run/wpa_supplicant/wlp6s0</div><div class="line">unix  3      [ ]         DGRAM                    556      /run/systemd/notify</div><div class="line">unix  3      [ ]         SEQPACKET  CONNECTED     27350    </div><div class="line">unix  3      [ ]         STREAM     CONNECTED     26055    /run/systemd/journal/stdout</div><div class="line">unix  3      [ ]         STREAM     CONNECTED     24124    </div><div class="line">unix  3      [ ]         STREAM     CONNECTED     23298    @/tmp/dbus-sYzUcwM148</div><div class="line">unix  3      [ ]         STREAM     CONNECTED     25062    @/tmp/dbus-sYzUcwM148</div><div class="line">unix  3      [ ]         STREAM     CONNECTED     22310    </div><div class="line">unix  3      [ ]         STREAM     CONNECTED     29561    </div><div class="line">unix  3      [ ]         STREAM     CONNECTED     23338    @/tmp/dbus-NFWQkgLokd</div><div class="line">unix  3      [ ]         STREAM     CONNECTED     24598    @/tmp/.X11-unix/X0</div><div class="line">... ...</div></pre></td></tr></table></figure>
<p><strong>说明：</strong><br><code>netstat</code>　命令输出结果分为两部分：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">１． Active Internet connections　：　有源 TCP 连接　</div><div class="line">          Recv-Q　：　接受队列</div><div class="line">          Send-Q　：　发送队列 (这两列一般情况下为０，如果为１，则表示有软件包在队列中堆积)</div><div class="line">２．Active UNIX domain sockets　：　有源ＵＮＩＸ域套接口(和网络套接字一样，但是只能用于本机通信，性能可以提高一倍)</div><div class="line">　　　    Proto　　：　显示连接使用的协议</div><div class="line">   　　　RefCnt　　：    表示连接到本套接口上的进程号</div><div class="line">　　　　   Types　　：    显示套接口的类型</div><div class="line">　　     State 　　：　显示套接口当前的状态</div><div class="line">　　       Path　　：　表示连接到套接口的其它进程使用的路径名</div></pre></td></tr></table></figure>
<p>状态字段说明</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">LISTEN：侦听来自远方的TCP端口的连接请求</div><div class="line">SYN-SENT：再发送连接请求后等待匹配的连接请求（如果有大量这样的状态包，检查是否中招了）</div><div class="line">SYN-RECEIVED：再收到和发送一个连接请求后等待对方对连接请求的确认（如有大量此状态，估计被flood攻击了）</div><div class="line">ESTABLISHED：代表一个打开的连接</div><div class="line">FIN-WAIT-1：等待远程TCP连接中断请求，或先前的连接中断请求的确认</div><div class="line">FIN-WAIT-2：从远程TCP等待连接中断请求</div><div class="line">CLOSE-WAIT：等待从本地用户发来的连接中断请求</div><div class="line">CLOSING：等待远程TCP对连接中断的确认</div><div class="line">LAST-ACK：等待原来的发向远程TCP的连接中断请求的确认（不是什么好东西，此项出现，检查是否被攻击）</div><div class="line">TIME-WAIT：等待足够的时间以确保远程TCP接收到连接中断请求的确认</div><div class="line">CLOSED：没有任何连接状态</div></pre></td></tr></table></figure>
<ul>
<li>显示端口信息<br><code>netstat -a</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">➜  ~ netstat -a</div><div class="line">Active Internet connections (servers and established)</div><div class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State      </div><div class="line">tcp        0      0 localhost:mysql         *:*                     LISTEN     </div><div class="line">tcp        0      0 zhyingjia-Inspir:domain *:*                     LISTEN     </div><div class="line">tcp        0      0 *:ssh                   *:*                     LISTEN     </div><div class="line">tcp        0      1 192.168.1.197:39094     www.google.com.gr:https SYN_SENT   </div><div class="line">tcp        0      0 192.168.1.197:56872     106.75.2.241:http       ESTABLISHED</div><div class="line">tcp        0      1 192.168.1.197:39088     www.google.com.gr:https SYN_SENT   </div><div class="line">tcp        0      1 192.168.1.197:39092     www.google.com.gr:https SYN_SENT   </div><div class="line">tcp        1      1 192.168.1.197:45848     23.248.163.147:http     LAST_ACK   </div><div class="line">tcp        0      1 192.168.1.197:39098     www.google.com.gr:https SYN_SENT</div></pre></td></tr></table></figure>
<hr>
<p>  <strong>简述：</strong><br>  安全外壳协议（SSH）是一种在不安全网络上提供安全远程登录及其它安全网络服务的协议。<br>  <strong>命令格式：</strong><br>  <code>ssh [-l login_name] [-p port] [user@]hostname</code><br>  <strong>常用参数：</strong><br>  <code>ssh -p port [user@]hostname</code> 远程登录指定 IP 主机的端口<br>  <code>ssh -u login_name [user@]hostname</code> 指定用户</p>
<p><strong>实例：</strong></p>
<ul>
<li>指定用户<br><code>ssh -l long_name ip</code><br><code>ssh login_name@ip</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">➜  ~ ssh -l root 192.168.1.222</div><div class="line">root@192.168.1.222&apos;s password: </div><div class="line"></div><div class="line"></div><div class="line">BusyBox v1.20.2 () built-in shell (ash)</div><div class="line">Enter &apos;help&apos; for a list of built-in commands.</div><div class="line"></div><div class="line">this board is EasyARM-iMX283</div><div class="line">root@EasyARM-iMX28x ~# </div><div class="line"></div><div class="line">➜  ~ ssh root@192.168.1.222</div><div class="line">root@192.168.1.222&apos;s password: </div><div class="line"></div><div class="line"></div><div class="line">BusyBox v1.20.2 () built-in shell (ash)</div><div class="line">Enter &apos;help&apos; for a list of built-in commands.</div><div class="line"></div><div class="line">this board is EasyARM-iMX283</div><div class="line">root@EasyARM-iMX28x ~#</div></pre></td></tr></table></figure>
<ul>
<li>指定端口(若不指定端口，ssh 命令默认登录 22 端口)<br><code>ssh -l long_name -p port ip</code><br><code>ssh -p port login_name@ip</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">➜  ~ ssh -l root -p 22 192.168.1.222</div><div class="line">root@192.168.1.222&apos;s password: </div><div class="line"></div><div class="line"></div><div class="line">BusyBox v1.20.2 () built-in shell (ash)</div><div class="line">Enter &apos;help&apos; for a list of built-in commands.</div><div class="line"></div><div class="line">this board is EasyARM-iMX283</div><div class="line">root@EasyARM-iMX28x ~# </div><div class="line"></div><div class="line">➜  ~ ssh -p 22 root@192.168.1.222</div><div class="line">root@192.168.1.222&apos;s password: </div><div class="line"></div><div class="line"></div><div class="line">BusyBox v1.20.2 () built-in shell (ash)</div><div class="line">Enter &apos;help&apos; for a list of built-in commands.</div><div class="line"></div><div class="line">this board is EasyARM-iMX283</div><div class="line">root@EasyARM-iMX28x ~#</div></pre></td></tr></table></figure>
<ul>
<li>更改 ssh 默认端口<br>１．修改配置文件　：<code>/etc/ssh/sshd_config</code><br>２．重启服务　：<code>service sshd restart</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">➜  ~ sudo vim /etc/ssh/sshd_config</div><div class="line">//  修改端口</div><div class="line">修改 Port 22  -&gt;  Port 23   :wq 保存并退出</div><div class="line">➜  ~ cat /etc/ssh/sshd_config</div><div class="line"># Package generated configuration file</div><div class="line"># See the sshd_config(5) manpage for details</div><div class="line"></div><div class="line"># What ports, IPs and protocols we listen for</div><div class="line">Port 23</div><div class="line"># Use these options to restrict which interfaces/protocols sshd will bind to</div><div class="line">  ... ... </div><div class="line">➜  ~ service sshd restart           </div><div class="line">➜  ~ ssh root@192.168.1.222</div><div class="line">root@192.168.1.222&apos;s password: </div><div class="line"></div><div class="line"></div><div class="line">BusyBox v1.20.2 () built-in shell (ash)</div><div class="line">Enter &apos;help&apos; for a list of built-in commands.</div><div class="line"></div><div class="line">this board is EasyARM-iMX283</div><div class="line">root@EasyARM-iMX28x ~#</div></pre></td></tr></table></figure>
<hr>
<ul>
<li><strong>scp</strong><br><code>scp &lt;file-name&gt; &lt;user-name&gt;@&lt;des-ip&gt;:[des-path]</code> 　远程传输文件<br><code>scp -r &lt;dir-name&gt; &lt;user-name&gt;@&lt;des-ip&gt;:[des-path]</code>　远程传输文件夹</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"> //  发送方</div><div class="line">[root@hadoop1 ~]# scp client1.c zhyingjia@192.168.1.196:</div><div class="line">The authenticity of host &apos;192.168.1.196 (192.168.1.196)&apos; can&apos;t be established.</div><div class="line">RSA key fingerprint is b4:8a:27:96:37:e5:27:4b:67:9f:6f:bc:51:c3:9e:f3.</div><div class="line">Are you sure you want to continue connecting (yes/no)? yes</div><div class="line">Warning: Permanently added &apos;192.168.1.196&apos; (RSA) to the list of known hosts.</div><div class="line">zhyingjia@192.168.1.196&apos;s password: </div><div class="line">client1.c                                     100% 5320     5.2KB/s   00:00  </div><div class="line"></div><div class="line"></div><div class="line">[root@hadoop1 ~]# scp -r testDir/ zhyingjia@192.168.1.196:</div><div class="line">zhyingjia@192.168.1.196&apos;s password: </div><div class="line">[root@hadoop1 ~]# ls</div><div class="line"></div><div class="line">// 接收前</div><div class="line">➜  /home ls </div><div class="line">zhyingjia</div><div class="line">➜  /home cd zhyingjia </div><div class="line">➜  ~ ls</div><div class="line">Book              IdeaProjects        Public            Videos</div><div class="line">client1.c         logs                Ruby              WebstormProjects</div><div class="line">Desktop           Music               RubymineProjects  wince3+1</div><div class="line">Documents         newDir              sshd.txt</div><div class="line">Downloads         newRamlProject      Templates</div><div class="line">Pictures     </div><div class="line"></div><div class="line">// 接收后</div><div class="line">➜  /home ls </div><div class="line">zhyingjia</div><div class="line">➜  /home cd zhyingjia </div><div class="line">➜  ~ ls</div><div class="line">Book              IdeaProjects        Public            Videos</div><div class="line">client1.c         logs                Ruby              WebstormProjects</div><div class="line">Desktop           Music               RubymineProjects  wince3+1</div><div class="line">Documents         newDir              sshd.txt</div><div class="line">Downloads         newRamlProject      Templates</div><div class="line">Pictures          testDir</div><div class="line"></div><div class="line">// 文件夹已经传送过来。</div></pre></td></tr></table></figure>
<h2 id="配置IP地址"><a href="#配置IP地址" class="headerlink" title="配置IP地址"></a><strong>配置IP地址</strong></h2><p>  <strong>IP地址为动态获取：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">netsh interface ip set address name=&quot;本地连接&quot; source=dhcp</div></pre></td></tr></table></figure>
<p><strong>设置静态IP地址：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">netsh interface ip set address name=&quot;本地连接&quot; source=static addr=192.168.1.100mask=255.255.255.0 gateway=192.168.1.1</div></pre></td></tr></table></figure>
<p><strong>清空IP地址：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">netsh interface ip set address name=&quot;本地连接&quot; source=dhcp</div></pre></td></tr></table></figure>
<p><strong>参数说明：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">1.name：网络连接名称，一般为“本地连接”。你可以在“控制面板”-&gt;“网络连接”中看到。</div><div class="line"></div><div class="line">2.source：获取IP的途径。动态获取，则为dhcp，手动设置，则为static。</div><div class="line"></div><div class="line">3.addr：要设置的IP地址。</div><div class="line"></div><div class="line">4.mask：子网掩码。</div><div class="line"></div><div class="line">5.gateway：网关地址。</div><div class="line"></div><div class="line">6.gwmetric：网关跃点数，可以设置为整型数值，也可以设置为“自动”：auto</div></pre></td></tr></table></figure>
<h2 id="配置DNS地址："><a href="#配置DNS地址：" class="headerlink" title="配置DNS地址："></a><strong>配置DNS地址：</strong></h2><p> <strong>DNS为动态获取的命令：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">netsh interface ip set dns name=&quot;本地连接&quot; source=dhcp</div></pre></td></tr></table></figure>
<p><strong>设置首选DNS地址：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">netsh interface ip set dns name=&quot;本地连接&quot; source=static addr=202.200.100.3register=primary</div></pre></td></tr></table></figure>
<p><strong>设置多个DNS地址：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">netsh interface ip set dns name=&quot;本地连接&quot; source=static addr = 202.200.100.3register=primary</div><div class="line"></div><div class="line">netsh interface ip add dns name=&quot;本地连接&quot; addr=61.134.100.14</div></pre></td></tr></table></figure>
<p><strong>清空DNS地址：</strong></p>
<p>netsh interface ip set dns name=”本地连接” source=dhcp</p>
<p><strong>参数说明：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">1.name：网络连接名称，一般为“本地连接”。你可以在“控制面板”-&gt;“网络连接”中看到。</div><div class="line"></div><div class="line">2.source：获取IP的途径。动态获取，则为dhcp，手动设置，则为static。</div><div class="line"></div><div class="line">3.addr：要设置的IP地址。</div><div class="line"></div><div class="line">4.register：</div><div class="line"></div><div class="line">5.none: 禁用动态 DNS 注册。</div><div class="line"></div><div class="line">6.primary: 只在主 DNS 后缀下注册。</div><div class="line"></div><div class="line">7.both: 在主 DNS 后缀下注册，也在特定连接后缀下注册。</div><div class="line"></div><div class="line">8.index：设置的DNS的顺序号。</div></pre></td></tr></table></figure>
<h2 id="导出配置文件"><a href="#导出配置文件" class="headerlink" title="导出配置文件"></a><strong>导出配置文件</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">netsh -c interface dump&gt;c:\ip.txt</div></pre></td></tr></table></figure>
<h2 id="修改之后导入本机配置"><a href="#修改之后导入本机配置" class="headerlink" title="修改之后导入本机配置"></a><strong>修改之后导入本机配置</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">netsh -f c:\ip.txt</div></pre></td></tr></table></figure>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li>每天一个 Linux 命令：ping<br><a href="http://www.cnblogs.com/peida/archive/2013/03/06/2945407.html" target="_blank" rel="external">http://www.cnblogs.com/peida/archive/2013/03/06/2945407.html</a></li>
<li>每天一个Ｌinux命令：telnet<br><a href="http://www.cnblogs.com/peida/archive/2013/03/13/2956992.html" target="_blank" rel="external">http://www.cnblogs.com/peida/archive/2013/03/13/2956992.html</a></li>
<li>每天一个Ｌinux命令：netstat<br><a href="http://www.cnblogs.com/peida/archive/2013/03/08/2949194.html" target="_blank" rel="external">http://www.cnblogs.com/peida/archive/2013/03/08/2949194.html</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> 命令 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Git 命令大全]]></title>
      <url>/2017/03/12/Git-%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/</url>
      <content type="html"><![CDATA[<p>注:转载自<a href="http://www.jianshu.com/u/c16f95bb708b" target="_blank" rel="external">wuzhen</a></p>
<h2 id="git-config"><a href="#git-config" class="headerlink" title="git config"></a>git config</h2><p>配置 Git 的相关参数。<br>Git 一共有3个配置文件：<br>\1. 仓库级的配置文件：在仓库的 <code>.git/.gitconfig</code>，该配置文件只对所在的仓库有效。<br>\2. 全局配置文件：Mac 系统在 <code>~/.gitconfig</code>，Windows 系统在 <code>C:\Users\&lt;用户名&gt;\.gitconfig</code>。<br>\3. 系统级的配置文件：在 Git 的安装目录下（Mac 系统下安装目录在 <code>/usr/local/git</code>）的 <code>etc</code> 文件夹中的 <code>gitconfig</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"># 查看配置信息</div><div class="line"># --local：仓库级，--global：全局级，--system：系统级</div><div class="line">$ git config &lt;--local | --global | --system&gt; -l</div><div class="line"></div><div class="line"># 查看当前生效的配置信息</div><div class="line">$ git config -l</div><div class="line"></div><div class="line"># 编辑配置文件</div><div class="line"># --local：仓库级，--global：全局级，--system：系统级</div><div class="line">$ git config &lt;--local | --global | --system&gt; -e</div><div class="line"></div><div class="line"># 添加配置项</div><div class="line"># --local：仓库级，--global：全局级，--system：系统级</div><div class="line">$ git config &lt;--local | --global | --system&gt; --add &lt;name&gt; &lt;value&gt;</div><div class="line"></div><div class="line"># 获取配置项</div><div class="line">$ git config &lt;--local | --global | --system&gt; --get &lt;name&gt;</div><div class="line"></div><div class="line"># 删除配置项</div><div class="line">$ git config &lt;--local | --global | --system&gt; --unset &lt;name&gt;</div><div class="line"></div><div class="line"># 配置提交记录中的用户信息</div><div class="line">$ git config --global user.name &lt;用户名&gt;</div><div class="line">$ git config --global user.email &lt;邮箱地址&gt;</div><div class="line"></div><div class="line"># 更改Git缓存区的大小</div><div class="line"># 如果提交的内容较大，默认缓存较小，提交会失败</div><div class="line"># 缓存大小单位：B，例如：524288000（500MB）</div><div class="line">$ git config --global http.postBuffer &lt;缓存大小&gt;</div><div class="line"></div><div class="line"># 调用 git status/git diff 命令时以高亮或彩色方式显示改动状态</div><div class="line">$ git config --global color.ui true</div><div class="line"></div><div class="line"># 配置可以缓存密码，默认缓存时间15分钟</div><div class="line">$ git config --global credential.helper cache</div><div class="line"></div><div class="line"># 配置密码的缓存时间</div><div class="line"># 缓存时间单位：秒</div><div class="line">$ git config --global credential.helper &apos;cache --timeout=&lt;缓存时间&gt;&apos;</div><div class="line"></div><div class="line"># 配置长期存储密码</div><div class="line">$ git config --global credential.helper store</div></pre></td></tr></table></figure>
<h2 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a>git clone</h2><p>从远程仓库克隆一个版本库到本地。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># 默认在当前目录下创建和版本库名相同的文件夹并下载版本到该文件夹下</div><div class="line">$ git clone &lt;远程仓库的网址&gt;</div><div class="line"></div><div class="line"># 指定本地仓库的目录</div><div class="line">$ git clone &lt;远程仓库的网址&gt; &lt;本地目录&gt;</div><div class="line"></div><div class="line"># -b 指定要克隆的分支，默认是master分支</div><div class="line">$ git clone &lt;远程仓库的网址&gt; -b &lt;分支名称&gt; &lt;本地目录&gt;</div></pre></td></tr></table></figure>
<h2 id="git-init"><a href="#git-init" class="headerlink" title="git init"></a>git init</h2><p>初始化项目所在目录，初始化后会在当前目录下出现一个名为 .git 的目录。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># 初始化本地仓库，在当前目录下生成 .git 文件夹</div><div class="line">$ git init</div></pre></td></tr></table></figure>
<h2 id="git-status"><a href="#git-status" class="headerlink" title="git status"></a>git status</h2><p>查看本地仓库的状态。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># 查看本地仓库的状态</div><div class="line">$ git status</div><div class="line"></div><div class="line"># 以简短模式查看本地仓库的状态</div><div class="line"># 会显示两列，第一列是文件的状态，第二列是对应的文件</div><div class="line"># 文件状态：A 新增，M 修改，D 删除，?? 未添加到Git中</div><div class="line">$ git status -s</div></pre></td></tr></table></figure>
<h2 id="git-remote"><a href="#git-remote" class="headerlink" title="git remote"></a>git remote</h2><p>操作远程库。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"># 列出已经存在的远程仓库</div><div class="line">$ git remote</div><div class="line"></div><div class="line"># 列出远程仓库的详细信息，在别名后面列出URL地址</div><div class="line">$ git remote -v</div><div class="line">$ git remote --verbose</div><div class="line"></div><div class="line"># 添加远程仓库</div><div class="line">$ git remote add &lt;远程仓库的别名&gt; &lt;远程仓库的URL地址&gt;</div><div class="line"></div><div class="line"># 修改远程仓库的别名</div><div class="line">$ git remote rename &lt;原远程仓库的别名&gt; &lt;新的别名&gt;</div><div class="line"></div><div class="line"># 删除指定名称的远程仓库</div><div class="line">$ git remote remove &lt;远程仓库的别名&gt;</div><div class="line"></div><div class="line"># 修改远程仓库的 URL 地址</div><div class="line">$ git remote set-url &lt;远程仓库的别名&gt; &lt;新的远程仓库URL地址&gt;</div></pre></td></tr></table></figure>
<h2 id="git-branch"><a href="#git-branch" class="headerlink" title="git branch"></a>git branch</h2><p>操作 Git 的分支命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"># 列出本地的所有分支，当前所在分支以 &quot;*&quot; 标出</div><div class="line">$ git branch</div><div class="line"></div><div class="line"># 列出本地的所有分支并显示最后一次提交，当前所在分支以 &quot;*&quot; 标出</div><div class="line">$ git branch -v</div><div class="line"></div><div class="line"># 创建新分支，新的分支基于上一次提交建立</div><div class="line">$ git branch &lt;分支名&gt;</div><div class="line"></div><div class="line"># 修改分支名称</div><div class="line"># 如果不指定原分支名称则为当前所在分支</div><div class="line">$ git branch -m [&lt;原分支名称&gt;] &lt;新的分支名称&gt;</div><div class="line"># 强制修改分支名称</div><div class="line">$ git branch -M [&lt;原分支名称&gt;] &lt;新的分支名称&gt;</div><div class="line"></div><div class="line"># 删除指定的本地分支</div><div class="line">$ git branch -d &lt;分支名称&gt;</div><div class="line"></div><div class="line"># 强制删除指定的本地分支</div><div class="line">$ git branch -D &lt;分支名称&gt;</div></pre></td></tr></table></figure>
<h2 id="git-checkout"><a href="#git-checkout" class="headerlink" title="git checkout"></a>git checkout</h2><p>检出命令，用于创建、切换分支等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"># 切换到已存在的指定分支</div><div class="line">$ git checkout &lt;分支名称&gt;</div><div class="line"></div><div class="line"># 创建并切换到指定的分支，保留所有的提交记录</div><div class="line"># 等同于 &quot;git branch&quot; 和 &quot;git checkout&quot; 两个命令合并</div><div class="line">$ git checkout -b &lt;分支名称&gt;</div><div class="line"></div><div class="line"># 创建并切换到指定的分支，删除所有的提交记录</div><div class="line">$ git checkout --orphan &lt;分支名称&gt;</div><div class="line"></div><div class="line"># 替换掉本地的改动，新增的文件和已经添加到暂存区的内容不受影响</div><div class="line">$ git checkout &lt;文件路径&gt;</div></pre></td></tr></table></figure>
<h2 id="git-cherry-pick"><a href="#git-cherry-pick" class="headerlink" title="git cherry-pick"></a>git cherry-pick</h2><p>把已经提交的记录合并到当前分支。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># 把已经提交的记录合并到当前分支</div><div class="line">$ git cherry-pick &lt;commit ID&gt;</div></pre></td></tr></table></figure>
<h2 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a>git add</h2><p>把要提交的文件的信息添加到暂存区中。当使用 git commit 时，将依据暂存区中的内容来进行文件的提交。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"># 把指定的文件添加到暂存区中</div><div class="line">$ git add &lt;文件路径&gt;</div><div class="line"></div><div class="line"># 添加所有修改、已删除的文件到暂存区中</div><div class="line">$ git add -u [&lt;文件路径&gt;]</div><div class="line">$ git add --update [&lt;文件路径&gt;]</div><div class="line"></div><div class="line"># 添加所有修改、已删除、新增的文件到暂存区中，省略 &lt;文件路径&gt; 即为当前目录</div><div class="line">$ git add -A [&lt;文件路径&gt;]</div><div class="line">$ git add --all [&lt;文件路径&gt;]</div><div class="line"></div><div class="line"># 查看所有修改、已删除但没有提交的文件，进入一个子命令系统</div><div class="line">$ git add -i [&lt;文件路径&gt;]</div><div class="line">$ git add --interactive [&lt;文件路径&gt;]</div></pre></td></tr></table></figure>
<h2 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h2><p>将暂存区中的文件提交到本地仓库中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"># 把暂存区中的文件提交到本地仓库，调用文本编辑器输入该次提交的描述信息</div><div class="line">$ git commit</div><div class="line"></div><div class="line"># 把暂存区中的文件提交到本地仓库中并添加描述信息</div><div class="line">$ git commit -m &quot;&lt;提交的描述信息&gt;&quot;</div><div class="line"></div><div class="line"># 把所有修改、已删除的文件提交到本地仓库中</div><div class="line"># 不包括未被版本库跟踪的文件，等同于先调用了 &quot;git add -u&quot;</div><div class="line">$ git commit -a -m &quot;&lt;提交的描述信息&gt;&quot;</div><div class="line"></div><div class="line"># 修改上次提交的描述信息</div><div class="line">$ git commit --amend</div></pre></td></tr></table></figure>
<h2 id="git-fetch"><a href="#git-fetch" class="headerlink" title="git fetch"></a>git fetch</h2><p>从远程仓库获取最新的版本到本地的 tmp 分支上。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># 将远程仓库所有分支的最新版本全部取回到本地</div><div class="line">$ git fetch &lt;远程仓库的别名&gt;</div><div class="line"></div><div class="line"># 将远程仓库指定分支的最新版本取回到本地</div><div class="line">$ git fetch &lt;远程主机名&gt; &lt;分支名&gt;</div></pre></td></tr></table></figure>
<h2 id="git-merge"><a href="#git-merge" class="headerlink" title="git merge"></a>git merge</h2><p>合并分支。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># 把指定的分支合并到当前所在的分支下</div><div class="line">$ git merge &lt;分支名称&gt;</div></pre></td></tr></table></figure>
<h2 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h2><p>比较版本之间的差异。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"># 比较当前文件和暂存区中文件的差异，显示没有暂存起来的更改</div><div class="line">$ git diff</div><div class="line"></div><div class="line"># 比较暂存区中的文件和上次提交时的差异</div><div class="line">$ git diff --cached</div><div class="line">$ git diff --staged</div><div class="line"></div><div class="line"># 比较当前文件和上次提交时的差异</div><div class="line">$ git diff HEAD</div><div class="line"></div><div class="line"># 查看从指定的版本之后改动的内容</div><div class="line">$ git diff &lt;commit ID&gt;</div><div class="line"></div><div class="line"># 比较两个分支之间的差异</div><div class="line">$ git diff &lt;分支名称&gt; &lt;分支名称&gt;</div><div class="line"></div><div class="line"># 查看两个分支分开后各自的改动内容</div><div class="line">$ git diff &lt;分支名称&gt;...&lt;分支名称&gt;</div></pre></td></tr></table></figure>
<h2 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h2><p>从远程仓库获取最新版本并合并到本地。<br>首先会执行 <code>git fetch</code>，然后执行 <code>git merge</code>，把获取的分支的 HEAD 合并到当前分支。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># 从远程仓库获取最新版本。</div><div class="line">$ git pull</div></pre></td></tr></table></figure>
<h2 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h2><p>把本地仓库的提交推送到远程仓库。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># 把本地仓库的分支推送到远程仓库的指定分支</div><div class="line">$ git push &lt;远程仓库的别名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</div><div class="line"></div><div class="line"># 删除指定的远程仓库的分支</div><div class="line">$ git push &lt;远程仓库的别名&gt; :&lt;远程分支名&gt;</div><div class="line">$ git push &lt;远程仓库的别名&gt; --delete &lt;远程分支名&gt;</div></pre></td></tr></table></figure>
<h2 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a>git log</h2><p>显示提交的记录。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># 打印所有的提交记录</div><div class="line">$ git log</div><div class="line"></div><div class="line"># 打印从第一次提交到指定的提交的记录</div><div class="line">$ git log &lt;commit ID&gt;</div><div class="line"></div><div class="line"># 打印指定数量的最新提交的记录</div><div class="line">$ git log -&lt;指定的数量&gt;</div></pre></td></tr></table></figure>
<h2 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h2><p>还原提交记录。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"># 重置暂存区，但文件不受影响</div><div class="line"># 相当于将用 &quot;git add&quot; 命令更新到暂存区的内容撤出暂存区，可以指定文件</div><div class="line"># 没有指定 commit ID 则默认为当前 HEAD</div><div class="line">$ git reset [&lt;文件路径&gt;]</div><div class="line">$ git reset --mixed [&lt;文件路径&gt;]</div><div class="line"></div><div class="line"># 将 HEAD 的指向改变，撤销到指定的提交记录，文件未修改</div><div class="line">$ git reset &lt;commit ID&gt;</div><div class="line">$ git reset --mixed &lt;commit ID&gt;</div><div class="line"></div><div class="line"># 将 HEAD 的指向改变，撤销到指定的提交记录，文件未修改</div><div class="line"># 相当于调用 &quot;git reset --mixed&quot; 命令后又做了一次 &quot;git add&quot;</div><div class="line">$ git reset --soft &lt;commit ID&gt;</div><div class="line"></div><div class="line"># 将 HEAD 的指向改变，撤销到指定的提交记录，文件也修改了</div><div class="line">$ git reset --hard &lt;commit ID&gt;</div></pre></td></tr></table></figure>
<h2 id="git-revert"><a href="#git-revert" class="headerlink" title="git revert"></a>git revert</h2><p>生成一个新的提交来撤销某次提交，此次提交之前的所有提交都会被保留。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># 生成一个新的提交来撤销某次提交</div><div class="line">$ git revert &lt;commit ID&gt;</div></pre></td></tr></table></figure>
<h2 id="git-tag"><a href="#git-tag" class="headerlink" title="git tag"></a>git tag</h2><p>操作标签的命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"># 打印所有的标签</div><div class="line">$ git tag</div><div class="line"></div><div class="line"># 添加轻量标签，指向提交对象的引用，可以指定之前的提交记录</div><div class="line">$ git tag &lt;标签名称&gt; [&lt;commit ID&gt;]</div><div class="line"></div><div class="line"># 添加带有描述信息的附注标签，可以指定之前的提交记录</div><div class="line">$ git tag -a &lt;标签名称&gt; -m &lt;标签描述信息&gt; [&lt;commit ID&gt;]</div><div class="line"></div><div class="line"># 切换到指定的标签</div><div class="line">$ git checkout &lt;标签名称&gt;</div><div class="line"></div><div class="line"># 查看标签的信息</div><div class="line">$ git show &lt;标签名称&gt;</div><div class="line"></div><div class="line"># 删除指定的标签</div><div class="line">$ git tag -d &lt;标签名称&gt;</div><div class="line"></div><div class="line"># 将指定的标签提交到远程仓库</div><div class="line">$ git push &lt;远程仓库的别名&gt; &lt;标签名称&gt;</div><div class="line"></div><div class="line"># 将本地所有的标签全部提交到远程仓库</div><div class="line">$ git push &lt;远程仓库的别名&gt; –tags</div></pre></td></tr></table></figure>
<h2 id="git-mv"><a href="#git-mv" class="headerlink" title="git mv"></a>git mv</h2><p>重命名文件或者文件夹。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># 重命名指定的文件或者文件夹</div><div class="line">$ git mv &lt;源文件/文件夹&gt; &lt;目标文件/文件夹&gt;</div></pre></td></tr></table></figure>
<h2 id="git-rm"><a href="#git-rm" class="headerlink" title="git rm"></a>git rm</h2><p>删除文件或者文件夹。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># 移除跟踪指定的文件，并从本地仓库的文件夹中删除</div><div class="line">$ git rm &lt;文件路径&gt;</div><div class="line"></div><div class="line"># 移除跟踪指定的文件夹，并从本地仓库的文件夹中删除</div><div class="line">$ git rm -r &lt;文件夹路径&gt;</div><div class="line"></div><div class="line"># 移除跟踪指定的文件，在本地仓库的文件夹中保留该文件</div><div class="line">$ git rm --cached</div></pre></td></tr></table></figure>
<h2 id="Git操作场景示例"><a href="#Git操作场景示例" class="headerlink" title="Git操作场景示例"></a>Git操作场景示例</h2><h3 id="1-删除掉本地不存在的远程分支"><a href="#1-删除掉本地不存在的远程分支" class="headerlink" title="1. 删除掉本地不存在的远程分支"></a>1. 删除掉本地不存在的远程分支</h3><p>多人合作开发时，如果远程的分支被其他开发删除掉，在本地执行 <code>git branch --all</code> 依然会显示该远程分支，可使用下列的命令进行删除：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># 使用 pull 命令，添加 -p 参数</div><div class="line">$ git pull -p</div><div class="line"></div><div class="line"># 等同于下面的命令</div><div class="line">$ git fetch -p</div><div class="line">$ git fetch --prune origin</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> Git </tag>
            
            <tag> 命令 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ADB 用法大全]]></title>
      <url>/2017/03/12/ADB-%E7%94%A8%E6%B3%95%E5%A4%A7%E5%85%A8/</url>
      <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a><img src="./assets/title.png" alt="Awesome Adb"></h1><p>ADB，即 <a href="https://developer.android.com/studio/command-line/adb.html" target="_blank" rel="external">Android Debug Bridge</a>，它是 Android 开发/测试人员不可替代的强大工具，也是 Android 设备玩家的好玩具。</p>
<p>持续更新中，欢迎提 PR 和 Issue 补充指正，觉得有用的可以将 <a href="https://github.com/mzlogin/awesome-adb" target="_blank" rel="external">此 GitHub 仓库</a> Star 收藏备用。</p>
<p><strong>注：</strong>有部分命令的支持情况可能与 Android 系统版本及定制 ROM 的实现有关。</p>
<p>Other languages: <a href="./README.en.md">:gb: English</a></p>
<h1 id="-1"><a href="#-1" class="headerlink" title=""></a><img src="./assets/toc.png" alt="Table of Contents"></h1><!-- vim-markdown-toc GFM -->
<ul>
<li><a href="#基本用法">基本用法</a><ul>
<li><a href="#命令语法">命令语法</a></li>
<li><a href="#为命令指定目标设备">为命令指定目标设备</a></li>
<li><a href="#启动停止">启动/停止</a></li>
<li><a href="#查看-adb-版本">查看 adb 版本</a></li>
<li><a href="#以-root-权限运行-adbd">以 root 权限运行 adbd</a></li>
<li><a href="#指定-adb-server-的网络端口">指定 adb server 的网络端口</a></li>
</ul>
</li>
<li><a href="#设备连接管理">设备连接管理</a><ul>
<li><a href="#查询已连接设备模拟器">查询已连接设备/模拟器</a></li>
<li><a href="#usb-连接">USB 连接</a></li>
<li><a href="#无线连接需要借助-usb-线">无线连接（需要借助 USB 线）</a></li>
<li><a href="#无线连接无需借助-usb-线">无线连接（无需借助 USB 线）</a></li>
</ul>
</li>
<li><a href="#应用管理">应用管理</a><ul>
<li><a href="#查看应用列表">查看应用列表</a><ul>
<li><a href="#所有应用">所有应用</a></li>
<li><a href="#系统应用">系统应用</a></li>
<li><a href="#第三方应用">第三方应用</a></li>
<li><a href="#包名包含某字符串的应用">包名包含某字符串的应用</a></li>
</ul>
</li>
<li><a href="#安装-apk">安装 APK</a></li>
<li><a href="#卸载应用">卸载应用</a></li>
<li><a href="#清除应用数据与缓存">清除应用数据与缓存</a></li>
<li><a href="#查看前台-activity">查看前台 Activity</a></li>
<li><a href="#查看正在运行的-services">查看正在运行的 Services</a></li>
</ul>
</li>
<li><a href="#与应用交互">与应用交互</a><ul>
<li><a href="#调起-activity">调起 Activity</a></li>
<li><a href="#调起-service">调起 Service</a></li>
<li><a href="#发送广播">发送广播</a></li>
<li><a href="#强制停止应用">强制停止应用</a></li>
</ul>
</li>
<li><a href="#文件管理">文件管理</a><ul>
<li><a href="#复制设备里的文件到电脑">复制设备里的文件到电脑</a></li>
<li><a href="#复制电脑里的文件到设备">复制电脑里的文件到设备</a></li>
</ul>
</li>
<li><a href="#模拟按键输入">模拟按键/输入</a><ul>
<li><a href="#电源键">电源键</a></li>
<li><a href="#菜单键">菜单键</a></li>
<li><a href="#home-键">HOME 键</a></li>
<li><a href="#返回键">返回键</a></li>
<li><a href="#音量控制">音量控制</a></li>
<li><a href="#媒体控制">媒体控制</a></li>
<li><a href="#点亮熄灭屏幕">点亮/熄灭屏幕</a></li>
<li><a href="#滑动解锁">滑动解锁</a></li>
<li><a href="#输入文本">输入文本</a></li>
</ul>
</li>
<li><a href="#查看日志">查看日志</a><ul>
<li><a href="#android-日志">Android 日志</a><ul>
<li><a href="#按级别过滤日志">按级别过滤日志</a></li>
<li><a href="#按-tag-和级别过滤日志">按 tag 和级别过滤日志</a></li>
<li><a href="#日志格式">日志格式</a></li>
<li><a href="#清空日志">清空日志</a></li>
</ul>
</li>
<li><a href="#内核日志">内核日志</a></li>
</ul>
</li>
<li><a href="#查看设备信息">查看设备信息</a><ul>
<li><a href="#型号">型号</a></li>
<li><a href="#电池状况">电池状况</a></li>
<li><a href="#屏幕分辨率">屏幕分辨率</a></li>
<li><a href="#屏幕密度">屏幕密度</a></li>
<li><a href="#显示屏参数">显示屏参数</a></li>
<li><a href="#android_id">android_id</a></li>
<li><a href="#imei">IMEI</a></li>
<li><a href="#android-系统版本">Android 系统版本</a></li>
<li><a href="#ip-地址">IP 地址</a></li>
<li><a href="#mac-地址">Mac 地址</a></li>
<li><a href="#cpu-信息">CPU 信息</a></li>
<li><a href="#内存信息">内存信息</a></li>
<li><a href="#更多硬件与系统属性">更多硬件与系统属性</a></li>
</ul>
</li>
<li><a href="#修改设置">修改设置</a><ul>
<li><a href="#分辨率">分辨率</a></li>
<li><a href="#屏幕密度-1">屏幕密度</a></li>
<li><a href="#显示区域">显示区域</a></li>
<li><a href="#关闭-usb-调试模式">关闭 USB 调试模式</a></li>
<li><a href="#状态栏和导航栏的显示隐藏">状态栏和导航栏的显示隐藏</a></li>
</ul>
</li>
<li><a href="#实用功能">实用功能</a><ul>
<li><a href="#屏幕截图">屏幕截图</a></li>
<li><a href="#录制屏幕">录制屏幕</a></li>
<li><a href="#重新挂载-system-分区为可写">重新挂载 system 分区为可写</a></li>
<li><a href="#查看连接过的-wifi-密码">查看连接过的 WiFi 密码</a></li>
<li><a href="#设置系统日期和时间">设置系统日期和时间</a></li>
<li><a href="#重启手机">重启手机</a></li>
<li><a href="#检测设备是否已-root">检测设备是否已 root</a></li>
<li><a href="#使用-monkey-进行压力测试">使用 Monkey 进行压力测试</a></li>
<li><a href="#开启关闭-wifi">开启/关闭 WiFi</a></li>
</ul>
</li>
<li><a href="#刷机相关命令">刷机相关命令</a><ul>
<li><a href="#重启到-recovery-模式">重启到 Recovery 模式</a></li>
<li><a href="#从-recovery-重启到-android">从 Recovery 重启到 Android</a></li>
<li><a href="#重启到-fastboot-模式">重启到 Fastboot 模式</a></li>
<li><a href="#通过-sideload-更新系统">通过 sideload 更新系统</a></li>
</ul>
</li>
<li><a href="#更多-adb-shell-命令">更多 adb shell 命令</a><ul>
<li><a href="#查看进程">查看进程</a></li>
<li><a href="#查看实时资源占用情况">查看实时资源占用情况</a></li>
<li><a href="#其它">其它</a></li>
</ul>
</li>
<li><a href="#常见问题">常见问题</a><ul>
<li><a href="#启动-adb-server-失败">启动 adb server 失败</a></li>
</ul>
</li>
<li><a href="#adb-的非官方实现">adb 的非官方实现</a></li>
<li><a href="#致谢">致谢</a></li>
<li><a href="#参考链接">参考链接</a></li>
</ul>
<!-- vim-markdown-toc -->
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><h3 id="命令语法"><a href="#命令语法" class="headerlink" title="命令语法"></a>命令语法</h3><p>adb 命令的基本语法如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb [-d|-e|-s &lt;serialNumber&gt;] &lt;<span class="built_in">command</span>&gt;</div></pre></td></tr></table></figure>
<p>如果只有一个设备/模拟器连接时，可以省略掉 <code>[-d|-e|-s &lt;serialNumber&gt;]</code> 这一部分，直接使用 <code>adb &lt;command&gt;</code>。</p>
<h3 id="为命令指定目标设备"><a href="#为命令指定目标设备" class="headerlink" title="为命令指定目标设备"></a>为命令指定目标设备</h3><p>如果有多个设备/模拟器连接，则需要为命令指定目标设备。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>-d</td>
<td>指定当前唯一通过 USB 连接的 Android 设备为命令目标</td>
</tr>
<tr>
<td>-e</td>
<td>指定当前唯一运行的模拟器为命令目标</td>
</tr>
<tr>
<td><code>-s &lt;serialNumber&gt;</code></td>
<td>指定相应 serialNumber 号的设备/模拟器为命令目标</td>
</tr>
</tbody>
</table>
<p>在多个设备/模拟器连接的情况下较常用的是 <code>-s &lt;serialNumber&gt;</code> 参数，serialNumber 可以通过 <code>adb devices</code> 命令获取。如：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ adb devices</div><div class="line"></div><div class="line">List of devices attached</div><div class="line">cf264b8f	device</div><div class="line">emulator-5554	device</div><div class="line">10.129.164.6:5555	device</div></pre></td></tr></table></figure>
<p>输出里的 <code>cf264b8f</code>、<code>emulator-5554</code> 和 <code>10.129.164.6:5555</code> 即为 serialNumber。</p>
<p>比如这时想指定 <code>cf264b8f</code> 这个设备来运行 adb 命令获取屏幕分辨率：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb -s cf264b8f shell wm size</div></pre></td></tr></table></figure>
<p>又如想给 <code>10.129.164.6:5555</code> 这个设备安装应用（<em>这种形式的 serialNumber 格式为 <code>&lt;IP&gt;:&lt;Port&gt;</code>，一般为无线连接的设备或 Genymotion 等第三方 Android 模拟器</em>）：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb -s 10.129.164.6:5555 install test.apk</div></pre></td></tr></table></figure>
<p><strong>遇到多设备/模拟器的情况均使用这几个参数为命令指定目标设备，下文中为简化描述，不再重复。</strong></p>
<h3 id="启动-停止"><a href="#启动-停止" class="headerlink" title="启动/停止"></a>启动/停止</h3><p>启动 adb server 命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb start-server</div></pre></td></tr></table></figure>
<p>（一般无需手动执行此命令，在运行 adb 命令时若发现 adb server 没有启动会自动调起。）</p>
<p>停止 adb server 命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb <span class="built_in">kill</span>-server</div></pre></td></tr></table></figure>
<h3 id="查看-adb-版本"><a href="#查看-adb-版本" class="headerlink" title="查看 adb 版本"></a>查看 adb 版本</h3><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb version</div></pre></td></tr></table></figure>
<p>示例输出：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Android Debug Bridge version 1.0.36</div><div class="line">Revision 8f855a3d9b35-android</div></pre></td></tr></table></figure>
<h3 id="以-root-权限运行-adbd"><a href="#以-root-权限运行-adbd" class="headerlink" title="以 root 权限运行 adbd"></a>以 root 权限运行 adbd</h3><p>adb 的运行原理是 PC 端的 adb server 与手机端的守护进程 adbd 建立连接，然后 PC 端的 adb client 通过 adb server 转发命令，adbd 接收命令后解析运行。</p>
<p>所以如果 adbd 以普通权限执行，有些需要 root 权限才能执行的命令无法直接用 <code>adb xxx</code> 执行。这时可以 <code>adb shell</code> 然后 <code>su</code> 后执行命令，也可以让 adbd 以 root 权限执行，这个就能随意执行高权限命令了。</p>
<p>命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb root</div></pre></td></tr></table></figure>
<p>正常输出：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">restarting adbd as root</div></pre></td></tr></table></figure>
<p>现在再运行 <code>adb shell</code>，看看命令行提示符是不是变成 <code>#</code> 了？</p>
<p>有些手机 root 后也无法通过 <code>adb root</code> 命令让 adbd 以 root 权限执行，比如三星的部分机型，会提示 <code>adbd cannot run as root in production builds</code>，此时可以先安装 adbd Insecure，然后 <code>adb root</code> 试试。</p>
<p>相应地，如果要恢复 adbd 为非 root 权限的话，可以使用 <code>adb unroot</code> 命令。</p>
<h3 id="指定-adb-server-的网络端口"><a href="#指定-adb-server-的网络端口" class="headerlink" title="指定 adb server 的网络端口"></a>指定 adb server 的网络端口</h3><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb -P &lt;port&gt; start-server</div></pre></td></tr></table></figure>
<p>默认端口为 5037。</p>
<h2 id="设备连接管理"><a href="#设备连接管理" class="headerlink" title="设备连接管理"></a>设备连接管理</h2><h3 id="查询已连接设备-模拟器"><a href="#查询已连接设备-模拟器" class="headerlink" title="查询已连接设备/模拟器"></a>查询已连接设备/模拟器</h3><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb devices</div></pre></td></tr></table></figure>
<p>输出示例：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">List of devices attached</div><div class="line">cf264b8f	device</div><div class="line">emulator-5554	device</div><div class="line">10.129.164.6:5555	device</div></pre></td></tr></table></figure>
<p>输出格式为 <code>[serialNumber] [state]</code>，serialNumber 即我们常说的 SN，state 有如下几种：</p>
<ul>
<li><p><code>offline</code> —— 表示设备未连接成功或无响应。</p>
</li>
<li><p><code>device</code> —— 设备已连接。注意这个状态并不能标识 Android 系统已经完全启动和可操作，在设备启动过程中设备实例就可连接到 adb，但启动完毕后系统才处于可操作状态。</p>
</li>
<li><p><code>no device</code> —— 没有设备/模拟器连接。</p>
</li>
</ul>
<p>以上输出显示当前已经连接了三台设备/模拟器，<code>cf264b8f</code>、<code>emulator-5554</code> 和 <code>10.129.164.6:5555</code> 分别是它们的 SN。从 <code>emulator-5554</code> 这个名字可以看出它是一个 Android 模拟器，而 <code>10.129.164.6:5555</code> 这种形为 <code>&lt;IP&gt;:&lt;Port&gt;</code> 的 serialNumber 一般是无线连接的设备或 Genymotion 等第三方 Android 模拟器。</p>
<p>常见异常输出：</p>
<ol>
<li><p>没有设备/模拟器连接成功。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">List of devices attached</div></pre></td></tr></table></figure>
</li>
<li><p>设备/模拟器未连接到 adb 或无响应。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">List of devices attached</div><div class="line">cf264b8f	offline</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="USB-连接"><a href="#USB-连接" class="headerlink" title="USB 连接"></a>USB 连接</h3><p>通过 USB 连接来正常使用 adb 需要保证几点：</p>
<ol>
<li><p>硬件状态正常。</p>
<p>包括 Android 设备处于正常开机状态，USB 连接线和各种接口完好。</p>
</li>
<li><p>Android 设备的开发者选项和 USB 调试模式已开启。</p>
<p>可以到「设置」-「开发者选项」-「Android 调试」查看。</p>
<p>如果在设置里找不到开发者选项，那需要通过一个彩蛋来让它显示出来：在「设置」-「关于手机」连续点击「版本号」7 次。</p>
</li>
<li><p>设备驱动状态正常。</p>
<p>这一点貌似在 Linux 和 Mac OS X 下不用操心，在 Windows 下有可能遇到需要安装驱动的情况，确认这一点可以右键「计算机」-「属性」，到「设备管理器」里查看相关设备上是否有黄色感叹号或问号，如果没有就说明驱动状态已经好了。否则可以下载一个手机助手类程序来安装驱动先。</p>
</li>
<li><p>通过 USB 线连接好电脑和设备后确认状态。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb devices</div></pre></td></tr></table></figure>
<p>如果能看到</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xxxxxx device</div></pre></td></tr></table></figure>
<p>说明连接成功。</p>
</li>
</ol>
<h3 id="无线连接（需要借助-USB-线）"><a href="#无线连接（需要借助-USB-线）" class="headerlink" title="无线连接（需要借助 USB 线）"></a>无线连接（需要借助 USB 线）</h3><p>除了可以通过 USB 连接设备与电脑来使用 adb，也可以通过无线连接——虽然连接过程中也有需要使用 USB 的步骤，但是连接成功之后你的设备就可以在一定范围内摆脱 USB 连接线的限制啦！</p>
<p>操作步骤：</p>
<ol>
<li><p>将 Android 设备与要运行 adb 的电脑连接到同一个局域网，比如连到同一个 WiFi。</p>
</li>
<li><p>将设备与电脑通过 USB 线连接。</p>
<p>应确保连接成功（可运行 <code>adb devices</code> 看是否能列出该设备）。</p>
</li>
<li><p>让设备在 5555 端口监听 TCP/IP 连接：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb tcpip 5555</div></pre></td></tr></table></figure>
</li>
<li><p>断开 USB 连接。</p>
</li>
<li><p>找到设备的 IP 地址。</p>
<p>一般能在「设置」-「关于手机」-「状态信息」-「IP地址」找到，也可以使用下文里 <a href="#ip-地址">查看设备信息 - IP 地址</a> 一节里的方法用 adb 命令来查看。</p>
</li>
<li><p>通过 IP 地址连接设备。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb connect &lt;device-ip-address&gt;</div></pre></td></tr></table></figure>
<p>这里的 <code>&lt;device-ip-address&gt;</code> 就是上一步中找到的设备 IP 地址。</p>
</li>
<li><p>确认连接状态。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb devices</div></pre></td></tr></table></figure>
<p>如果能看到</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;device-ip-address&gt;:5555 device</div></pre></td></tr></table></figure>
<p>说明连接成功。</p>
</li>
</ol>
<p>如果连接不了，请确认 Android 设备与电脑是连接到了同一个 WiFi，然后再次执行 <code>adb connect &lt;device-ip-address&gt;</code> 那一步；</p>
<p>如果还是不行的话，通过 <code>adb kill-server</code> 重新启动 adb 然后从头再来一次试试。</p>
<p><strong>断开无线连接</strong></p>
<p>命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb disconnect &lt;device-ip-address&gt;</div></pre></td></tr></table></figure>
<h3 id="无线连接（无需借助-USB-线）"><a href="#无线连接（无需借助-USB-线）" class="headerlink" title="无线连接（无需借助 USB 线）"></a>无线连接（无需借助 USB 线）</h3><p><strong>注：需要 root 权限。</strong></p>
<p>上一节「无线连接（需要借助 USB 线）」是官方文档里介绍的方法，需要借助于 USB 数据线来实现无线连接。</p>
<p>既然我们想要实现无线连接，那能不能所有步骤下来都是无线的呢？答案是能的。</p>
<ol>
<li><p>在 Android 设备上安装一个终端模拟器。</p>
<p>已经安装过的设备可以跳过此步。我使用的终端模拟器下载地址是：<a href="https://jackpal.github.io/Android-Terminal-Emulator/" target="_blank" rel="external">Terminal Emulator for Android Downloads</a></p>
</li>
<li><p>将 Android 设备与要运行 adb 的电脑连接到同一个局域网，比如连到同一个 WiFi。</p>
</li>
<li><p>打开 Android 设备上的终端模拟器，在里面依次运行命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">su</div><div class="line">setprop service.adb.tcp.port 5555</div></pre></td></tr></table></figure>
</li>
<li><p>找到 Android 设备的 IP 地址。</p>
<p>一般能在「设置」-「关于手机」-「状态信息」-「IP地址」找到，也可以使用下文里 <a href="#ip-地址">查看设备信息 - IP 地址</a> 一节里的方法用 adb 命令来查看。</p>
</li>
<li><p>在电脑上通过 adb 和 IP 地址连接 Android 设备。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb connect &lt;device-ip-address&gt;</div></pre></td></tr></table></figure>
<p>这里的 <code>&lt;device-ip-address&gt;</code> 就是上一步中找到的设备 IP 地址。</p>
<p>如果能看到 <code>connected to &lt;device-ip-address&gt;:5555</code> 这样的输出则表示连接成功。</p>
</li>
</ol>
<p><em>节注一：</em></p>
<p>有的设备，比如小米 5S + MIUI 8.0 + Android 6.0.1 MXB48T，可能在第 5 步之前需要重启 adbd 服务，在设备的终端模拟器上运行：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">restart adbd</div></pre></td></tr></table></figure>
<p>如果 restart 无效，尝试以下命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">start adbd</div><div class="line">stop adbd</div></pre></td></tr></table></figure>
<h2 id="应用管理"><a href="#应用管理" class="headerlink" title="应用管理"></a>应用管理</h2><h3 id="查看应用列表"><a href="#查看应用列表" class="headerlink" title="查看应用列表"></a>查看应用列表</h3><p>查看应用列表的基本命令格式是</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb shell pm list packages [-f] [-d] [-e] [-s] [-3] [-i] [-u] [--user USER_ID] [FILTER]</div></pre></td></tr></table></figure>
<p>即在 <code>adb shell pm list packages</code> 的基础上可以加一些参数进行过滤查看不同的列表，支持的过滤参数如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>显示列表</th>
</tr>
</thead>
<tbody>
<tr>
<td>无</td>
<td>所有应用</td>
</tr>
<tr>
<td>-f</td>
<td>显示应用关联的 apk 文件</td>
</tr>
<tr>
<td>-d</td>
<td>只显示 disabled 的应用</td>
</tr>
<tr>
<td>-e</td>
<td>只显示 enabled 的应用</td>
</tr>
<tr>
<td>-s</td>
<td>只显示系统应用</td>
</tr>
<tr>
<td>-3</td>
<td>只显示第三方应用</td>
</tr>
<tr>
<td>-i</td>
<td>显示应用的 installer</td>
</tr>
<tr>
<td>-u</td>
<td>包含已卸载应用</td>
</tr>
<tr>
<td><code>&lt;FILTER&gt;</code></td>
<td>包名包含 <code>&lt;FILTER&gt;</code> 字符串</td>
</tr>
</tbody>
</table>
<h4 id="所有应用"><a href="#所有应用" class="headerlink" title="所有应用"></a>所有应用</h4><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb shell pm list packages</div></pre></td></tr></table></figure>
<p>输出示例：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">package:com.android.smoketest</div><div class="line">package:com.example.android.livecubes</div><div class="line">package:com.android.providers.telephony</div><div class="line">package:com.google.android.googlequicksearchbox</div><div class="line">package:com.android.providers.calendar</div><div class="line">package:com.android.providers.media</div><div class="line">package:com.android.protips</div><div class="line">package:com.android.documentsui</div><div class="line">package:com.android.gallery</div><div class="line">package:com.android.externalstorage</div><div class="line">...</div><div class="line">// other packages here</div><div class="line">...</div></pre></td></tr></table></figure>
<h4 id="系统应用"><a href="#系统应用" class="headerlink" title="系统应用"></a>系统应用</h4><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb shell pm list packages -s</div></pre></td></tr></table></figure>
<h4 id="第三方应用"><a href="#第三方应用" class="headerlink" title="第三方应用"></a>第三方应用</h4><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb shell pm list packages -3</div></pre></td></tr></table></figure>
<h4 id="包名包含某字符串的应用"><a href="#包名包含某字符串的应用" class="headerlink" title="包名包含某字符串的应用"></a>包名包含某字符串的应用</h4><p>比如要查看包名包含字符串 <code>mazhuang</code> 的应用列表，命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb shell pm list packages mazhuang</div></pre></td></tr></table></figure>
<p>当然也可以使用 grep 来过滤：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb shell pm list packages | grep mazhuang</div></pre></td></tr></table></figure>
<h3 id="安装-APK"><a href="#安装-APK" class="headerlink" title="安装 APK"></a>安装 APK</h3><p>命令格式：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb install [-lrtsdg] &lt;path_to_apk&gt;</div></pre></td></tr></table></figure>
<p>参数：</p>
<p><code>adb install</code> 后面可以跟一些可选参数来控制安装 APK 的行为，可用参数及含义如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>-l</td>
<td>将应用安装到保护目录 /mnt/asec</td>
</tr>
<tr>
<td>-r</td>
<td>允许覆盖安装</td>
</tr>
<tr>
<td>-t</td>
<td>允许安装 AndroidManifest.xml 里 application 指定 <code>android:testOnly=&quot;true&quot;</code> 的应用</td>
</tr>
<tr>
<td>-s</td>
<td>将应用安装到 sdcard</td>
</tr>
<tr>
<td>-d</td>
<td>允许降级覆盖安装</td>
</tr>
<tr>
<td>-g</td>
<td>授予所有运行时权限</td>
</tr>
</tbody>
</table>
<p>运行命令后如果见到类似如下输出（状态为 <code>Success</code>）代表安装成功：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[100%] /data/<span class="built_in">local</span>/tmp/1.apk</div><div class="line">	pkg: /data/<span class="built_in">local</span>/tmp/1.apk</div><div class="line">Success</div></pre></td></tr></table></figure>
<p>上面是当前最新版 v1.0.36 的 adb 的输出，会显示 push apk 文件到手机的进度百分比。</p>
<p>使用旧版本 adb 的输出则是这样的：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">12040 KB/s (22205609 bytes <span class="keyword">in</span> 1.801s)</div><div class="line">        pkg: /data/<span class="built_in">local</span>/tmp/SogouInput_android_v8.3_sweb.apk</div><div class="line">Success</div></pre></td></tr></table></figure>
<p>而如果状态为 <code>Failure</code> 则表示安装失败，比如：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[100%] /data/<span class="built_in">local</span>/tmp/map-20160831.apk</div><div class="line">        pkg: /data/<span class="built_in">local</span>/tmp/map-20160831.apk</div><div class="line">Failure [INSTALL_FAILED_ALREADY_EXISTS]</div></pre></td></tr></table></figure>
<p>常见安装失败输出代码、含义及可能的解决办法如下：</p>
<table>
<thead>
<tr>
<th>输出</th>
<th>含义</th>
<th>解决办法</th>
</tr>
</thead>
<tbody>
<tr>
<td>INSTALL_FAILED_ALREADY_EXISTS</td>
<td>应用已经存在，或卸载了但没卸载干净</td>
<td><code>adb install</code> 时使用 <code>-r</code> 参数，或者先 <code>adb uninstall &lt;packagename&gt;</code> 再安装</td>
</tr>
<tr>
<td>INSTALL_FAILED_INVALID_APK</td>
<td>无效的 APK 文件</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_INVALID_URI</td>
<td>无效的 APK 文件名</td>
<td>确保 APK 文件名里无中文</td>
</tr>
<tr>
<td>INSTALL_FAILED_INSUFFICIENT_STORAGE</td>
<td>空间不足</td>
<td>清理空间</td>
</tr>
<tr>
<td>INSTALL_FAILED_DUPLICATE_PACKAGE</td>
<td>已经存在同名程序</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_NO_SHARED_USER</td>
<td>请求的共享用户不存在</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_UPDATE_INCOMPATIBLE</td>
<td>以前安装过同名应用，但卸载时数据没有移除</td>
<td>先 <code>adb uninstall &lt;packagename&gt;</code> 再安装</td>
</tr>
<tr>
<td>INSTALL_FAILED_SHARED_USER_INCOMPATIBLE</td>
<td>请求的共享用户存在但签名不一致</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_MISSING_SHARED_LIBRARY</td>
<td>安装包使用了设备上不可用的共享库</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_REPLACE_COULDNT_DELETE</td>
<td>替换时无法删除</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_DEXOPT</td>
<td>dex 优化验证失败或空间不足</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_OLDER_SDK</td>
<td>设备系统版本低于应用要求</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_CONFLICTING_PROVIDER</td>
<td>设备里已经存在与应用里同名的 content provider</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_NEWER_SDK</td>
<td>设备系统版本高于应用要求</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_TEST_ONLY</td>
<td>应用是 test-only 的，但安装时没有指定 <code>-t</code> 参数</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_CPU_ABI_INCOMPATIBLE</td>
<td>包含不兼容设备 CPU 应用程序二进制接口的 native code</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_MISSING_FEATURE</td>
<td>应用使用了设备不可用的功能</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_CONTAINER_ERROR</td>
<td>1. sdcard 访问失败; 2. 应用签名与 ROM 签名一致，被当作内置应用</td>
<td>1. 确认 sdcard 可用，或者安装到内置存储; 2. 打包时不与 ROM 使用相同签名</td>
</tr>
<tr>
<td>INSTALL_FAILED_INVALID_INSTALL_LOCATION</td>
<td>1. 不能安装到指定位置; 2. 应用签名与 ROM 签名一致，被当作内置应用</td>
<td>1. 切换安装位置，添加或删除 <code>-s</code> 参数; 2. 打包时不与 ROM 使用相同签名</td>
</tr>
<tr>
<td>INSTALL_FAILED_MEDIA_UNAVAILABLE</td>
<td>安装位置不可用</td>
<td>一般为 sdcard，确认 sdcard 可用或安装到内置存储</td>
</tr>
<tr>
<td>INSTALL_FAILED_VERIFICATION_TIMEOUT</td>
<td>验证安装包超时</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_VERIFICATION_FAILURE</td>
<td>验证安装包失败</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_PACKAGE_CHANGED</td>
<td>应用与调用程序期望的不一致</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_UID_CHANGED</td>
<td>以前安装过该应用，与本次分配的 UID 不一致</td>
<td>清除以前安装过的残留文件</td>
</tr>
<tr>
<td>INSTALL_FAILED_VERSION_DOWNGRADE</td>
<td>已经安装了该应用更高版本</td>
<td>使用 <code>-d</code> 参数</td>
</tr>
<tr>
<td>INSTALL_FAILED_PERMISSION_MODEL_DOWNGRADE</td>
<td>已安装 target SDK 支持运行时权限的同名应用，要安装的版本不支持运行时权限</td>
<td></td>
</tr>
<tr>
<td>INSTALL_PARSE_FAILED_NOT_APK</td>
<td>指定路径不是文件，或不是以 <code>.apk</code> 结尾</td>
<td></td>
</tr>
<tr>
<td>INSTALL_PARSE_FAILED_BAD_MANIFEST</td>
<td>无法解析的 AndroidManifest.xml 文件</td>
<td></td>
</tr>
<tr>
<td>INSTALL_PARSE_FAILED_UNEXPECTED_EXCEPTION</td>
<td>解析器遇到异常</td>
<td></td>
</tr>
<tr>
<td>INSTALL_PARSE_FAILED_NO_CERTIFICATES</td>
<td>安装包没有签名</td>
<td></td>
</tr>
<tr>
<td>INSTALL_PARSE_FAILED_INCONSISTENT_CERTIFICATES</td>
<td>已安装该应用，且签名与 APK 文件不一致</td>
<td>先卸载设备上的该应用，再安装</td>
</tr>
<tr>
<td>INSTALL_PARSE_FAILED_CERTIFICATE_ENCODING</td>
<td>解析 APK 文件时遇到 <code>CertificateEncodingException</code></td>
<td></td>
</tr>
<tr>
<td>INSTALL_PARSE_FAILED_BAD_PACKAGE_NAME</td>
<td>manifest 文件里没有或者使用了无效的包名</td>
<td></td>
</tr>
<tr>
<td>INSTALL_PARSE_FAILED_BAD_SHARED_USER_ID</td>
<td>manifest 文件里指定了无效的共享用户 ID</td>
<td></td>
</tr>
<tr>
<td>INSTALL_PARSE_FAILED_MANIFEST_MALFORMED</td>
<td>解析 manifest 文件时遇到结构性错误</td>
<td></td>
</tr>
<tr>
<td>INSTALL_PARSE_FAILED_MANIFEST_EMPTY</td>
<td>在 manifest 文件里找不到找可操作标签（instrumentation 或 application）</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_INTERNAL_ERROR</td>
<td>因系统问题安装失败</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_USER_RESTRICTED</td>
<td>用户被限制安装应用</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_DUPLICATE_PERMISSION</td>
<td>应用尝试定义一个已经存在的权限名称</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_NO_MATCHING_ABIS</td>
<td>应用包含设备的应用程序二进制接口不支持的 native code</td>
<td></td>
</tr>
<tr>
<td>INSTALL_CANCELED_BY_USER</td>
<td>应用安装需要在设备上确认，但未操作设备或点了取消</td>
<td>在设备上同意安装</td>
</tr>
<tr>
<td>INSTALL_FAILED_ACWF_INCOMPATIBLE</td>
<td>应用程序与设备不兼容</td>
<td></td>
</tr>
<tr>
<td>does not contain AndroidManifest.xml</td>
<td>无效的 APK 文件</td>
<td></td>
</tr>
<tr>
<td>is not a valid zip file</td>
<td>无效的 APK 文件</td>
<td></td>
</tr>
<tr>
<td>Offline</td>
<td>设备未连接成功</td>
<td>先将设备与 adb 连接成功</td>
</tr>
<tr>
<td>unauthorized</td>
<td>设备未授权允许调试</td>
<td></td>
</tr>
<tr>
<td>error: device not found</td>
<td>没有连接成功的设备</td>
<td>先将设备与 adb 连接成功</td>
</tr>
<tr>
<td>protocol failure</td>
<td>设备已断开连接</td>
<td>先将设备与 adb 连接成功</td>
</tr>
<tr>
<td>Unknown option: -s</td>
<td>Android 2.2 以下不支持安装到 sdcard</td>
<td>不使用 <code>-s</code> 参数</td>
</tr>
<tr>
<td>No space left on devicerm</td>
<td>空间不足</td>
<td>清理空间</td>
</tr>
<tr>
<td>Permission denied … sdcard …</td>
<td>sdcard 不可用</td>
</tr>
</tbody>
</table>
<p>参考：<a href="https://github.com/android/platform_frameworks_base/blob/master/core%2Fjava%2Fandroid%2Fcontent%2Fpm%2FPackageManager.java" target="_blank" rel="external">PackageManager.java</a></p>
<p><em><code>adb install</code> 内部原理简介</em></p>
<p><code>adb install</code> 实际是分三步完成：</p>
<ol>
<li><p>push apk 文件到 /data/local/tmp。</p>
</li>
<li><p>调用 pm install 安装。</p>
</li>
<li><p>删除 /data/local/tmp 下的对应 apk 文件。</p>
</li>
</ol>
<p>所以，必要的时候也可以根据这个步骤，手动分步执行安装过程。</p>
<h3 id="卸载应用"><a href="#卸载应用" class="headerlink" title="卸载应用"></a>卸载应用</h3><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb uninstall [-k] &lt;packagename&gt;</div></pre></td></tr></table></figure>
<p><code>&lt;packagename&gt;</code> 表示应用的包名，<code>-k</code> 参数可选，表示卸载应用但保留数据和缓存目录。</p>
<p>命令示例：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb uninstall com.qihoo360.mobilesafe</div></pre></td></tr></table></figure>
<p>表示卸载 360 手机卫士。</p>
<h3 id="清除应用数据与缓存"><a href="#清除应用数据与缓存" class="headerlink" title="清除应用数据与缓存"></a>清除应用数据与缓存</h3><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb shell pm clear &lt;packagename&gt;</div></pre></td></tr></table></figure>
<p><code>&lt;packagename&gt;</code> 表示应用名包，这条命令的效果相当于在设置里的应用信息界面点击了「清除缓存」和「清除数据」。</p>
<p>命令示例：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb shell pm clear com.qihoo360.mobilesafe</div></pre></td></tr></table></figure>
<p>表示清除 360 手机卫士的数据和缓存。</p>
<h3 id="查看前台-Activity"><a href="#查看前台-Activity" class="headerlink" title="查看前台 Activity"></a>查看前台 Activity</h3><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb shell dumpsys activity activities | grep mFocusedActivity</div></pre></td></tr></table></figure>
<p>输出示例：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mFocusedActivity: ActivityRecord&#123;8079d7e u0 com.cyanogenmod.trebuchet/com.android.launcher3.Launcher t42&#125;</div></pre></td></tr></table></figure>
<p>其中的 <code>com.cyanogenmod.trebuchet/com.android.launcher3.Launcher</code> 就是当前处于前台的 Activity。</p>
<h3 id="查看正在运行的-Services"><a href="#查看正在运行的-Services" class="headerlink" title="查看正在运行的 Services"></a>查看正在运行的 Services</h3><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb shell dumpsys activity services [&lt;packagename&gt;]</div></pre></td></tr></table></figure>
<p><code>&lt;packagename&gt;</code> 参数不是必须的，指定 <code>&lt;packagename&gt;</code> 表示查看与某个包名相关的 Services，不指定表示查看所有 Services。</p>
<p><code>&lt;packagename&gt;</code> 不一定要给出完整的包名，比如运行 <code>adb shell dumpsys activity services org.mazhuang</code>，那么包名 <code>org.mazhuang.demo1</code>、<code>org.mazhuang.demo2</code> 和 <code>org.mazhuang123</code> 等相关的 Services 都会列出来。</p>
<h2 id="与应用交互"><a href="#与应用交互" class="headerlink" title="与应用交互"></a>与应用交互</h2><p>主要是使用 <code>am &lt;command&gt;</code> 命令，常用的 <code>&lt;command&gt;</code> 如下：</p>
<table>
<thead>
<tr>
<th>command</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>start [options] &lt;INTENT&gt;</code></td>
<td>启动 <code>&lt;INTENT&gt;</code> 指定的 Activity</td>
</tr>
<tr>
<td><code>startservice [options] &lt;INTENT&gt;</code></td>
<td>启动 <code>&lt;INTENT&gt;</code> 指定的 Service</td>
</tr>
<tr>
<td><code>broadcast [options] &lt;INTENT&gt;</code></td>
<td>发送 <code>&lt;INTENT&gt;</code> 指定的广播</td>
</tr>
<tr>
<td><code>force-stop &lt;packagename&gt;</code></td>
<td>停止 <code>&lt;packagename&gt;</code> 相关的进程</td>
</tr>
</tbody>
</table>
<p><code>&lt;INTENT&gt;</code> 参数很灵活，和写 Android 程序时代码里的 Intent 相对应。</p>
<p>用于决定 intent 对象的选项如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-a &lt;ACTION&gt;</code></td>
<td>指定 action，比如 <code>android.intent.action.VIEW</code></td>
</tr>
<tr>
<td><code>-c &lt;CATEGORY&gt;</code></td>
<td>指定 category，比如 <code>android.intent.category.APP_CONTACTS</code></td>
</tr>
<tr>
<td><code>-n &lt;COMPONENT&gt;</code></td>
<td>指定完整 component 名，用于明确指定启动哪个 Activity，如 <code>com.example.app/.ExampleActivity</code></td>
</tr>
</tbody>
</table>
<p><code>&lt;INTENT&gt;</code> 里还能带数据，就像写代码时的 Bundle 一样：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>--esn &lt;EXTRA_KEY&gt;</code></td>
<td>null 值（只有 key 名）</td>
</tr>
<tr>
<td>`-e</td>
<td>–es <extra_key> <extra_string_value>`</extra_string_value></extra_key></td>
<td>string 值</td>
</tr>
<tr>
<td><code>--ez &lt;EXTRA_KEY&gt; &lt;EXTRA_BOOLEAN_VALUE&gt;</code></td>
<td>boolean 值</td>
</tr>
<tr>
<td><code>--ei &lt;EXTRA_KEY&gt; &lt;EXTRA_INT_VALUE&gt;</code></td>
<td>integer 值</td>
</tr>
<tr>
<td><code>--el &lt;EXTRA_KEY&gt; &lt;EXTRA_LONG_VALUE&gt;</code></td>
<td>long 值</td>
</tr>
<tr>
<td><code>--ef &lt;EXTRA_KEY&gt; &lt;EXTRA_FLOAT_VALUE&gt;</code></td>
<td>float 值</td>
</tr>
<tr>
<td><code>--eu &lt;EXTRA_KEY&gt; &lt;EXTRA_URI_VALUE&gt;</code></td>
<td>URI</td>
</tr>
<tr>
<td><code>--ecn &lt;EXTRA_KEY&gt; &lt;EXTRA_COMPONENT_NAME_VALUE&gt;</code></td>
<td>component name</td>
</tr>
<tr>
<td><code>--eia &lt;EXTRA_KEY&gt; &lt;EXTRA_INT_VALUE&gt;[,&lt;EXTRA_INT_VALUE...]</code></td>
<td>integer 数组</td>
</tr>
<tr>
<td><code>--ela &lt;EXTRA_KEY&gt; &lt;EXTRA_LONG_VALUE&gt;[,&lt;EXTRA_LONG_VALUE...]</code></td>
<td>long 数组</td>
</tr>
</tbody>
</table>
<h3 id="调起-Activity"><a href="#调起-Activity" class="headerlink" title="调起 Activity"></a>调起 Activity</h3><p>命令格式：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb shell am start [options] &lt;INTENT&gt;</div></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb shell am start -n com.tencent.mm/.ui.LauncherUI</div></pre></td></tr></table></figure>
<p>表示调起微信主界面。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb shell am start -n org.mazhuang.boottimemeasure/.MainActivity --es <span class="string">"toast"</span> <span class="string">"hello, world"</span></div></pre></td></tr></table></figure>
<p>表示调起 <code>org.mazhuang.boottimemeasure/.MainActivity</code> 并传给它 string 数据键值对 <code>toast - hello, world</code>。</p>
<h3 id="调起-Service"><a href="#调起-Service" class="headerlink" title="调起 Service"></a>调起 Service</h3><p>命令格式：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb shell am startservice [options] &lt;INTENT&gt;</div></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb shell am startservice -n com.tencent.mm/.plugin.accountsync.model.AccountAuthenticatorService</div></pre></td></tr></table></figure>
<p>表示调起微信的某 Service。</p>
<h3 id="发送广播"><a href="#发送广播" class="headerlink" title="发送广播"></a>发送广播</h3><p>命令格式：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb shell am broadcast [options] &lt;INTENT&gt;</div></pre></td></tr></table></figure>
<p>可以向所有组件广播，也可以只向指定组件广播。</p>
<p>例如，向所有组件广播 <code>BOOT_COMPLETED</code>：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb shell am broadcast -a android.intent.action.BOOT_COMPLETED</div></pre></td></tr></table></figure>
<p>又例如，只向 <code>org.mazhuang.boottimemeasure/.BootCompletedReceiver</code> 广播 <code>BOOT_COMPLETED</code>：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb shell am broadcast -a android.intent.action.BOOT_COMPLETED -n org.mazhuang.boottimemeasure/.BootCompletedReceiver</div></pre></td></tr></table></figure>
<p>这类用法在测试的时候很实用，比如某个广播的场景很难制造，可以考虑通过这种方式来发送广播。</p>
<p>既能发送系统预定义的广播，也能发送自定义广播。如下是部分系统预定义广播及正常触发时机：</p>
<table>
<thead>
<tr>
<th>action</th>
<th>触发时机</th>
</tr>
</thead>
<tbody>
<tr>
<td>android.net.conn.CONNECTIVITY_CHANGE</td>
<td>网络连接发生变化</td>
</tr>
<tr>
<td>android.intent.action.SCREEN_ON</td>
<td>屏幕点亮</td>
</tr>
<tr>
<td>android.intent.action.SCREEN_OFF</td>
<td>屏幕熄灭</td>
</tr>
<tr>
<td>android.intent.action.BATTERY_LOW</td>
<td>电量低，会弹出电量低提示框</td>
</tr>
<tr>
<td>android.intent.action.BATTERY_OKAY</td>
<td>电量恢复了</td>
</tr>
<tr>
<td>android.intent.action.BOOT_COMPLETED</td>
<td>设备启动完毕</td>
</tr>
<tr>
<td>android.intent.action.DEVICE_STORAGE_LOW</td>
<td>存储空间过低</td>
</tr>
<tr>
<td>android.intent.action.DEVICE_STORAGE_OK</td>
<td>存储空间恢复</td>
</tr>
<tr>
<td>android.intent.action.PACKAGE_ADDED</td>
<td>安装了新的应用</td>
</tr>
<tr>
<td>android.net.wifi.STATE_CHANGE</td>
<td>WiFi 连接状态发生变化</td>
</tr>
<tr>
<td>android.net.wifi.WIFI_STATE_CHANGED</td>
<td>WiFi 状态变为启用/关闭/正在启动/正在关闭/未知</td>
</tr>
<tr>
<td>android.intent.action.BATTERY_CHANGED</td>
<td>电池电量发生变化</td>
</tr>
<tr>
<td>android.intent.action.INPUT_METHOD_CHANGED</td>
<td>系统输入法发生变化</td>
</tr>
<tr>
<td>android.intent.action.ACTION_POWER_CONNECTED</td>
<td>外部电源连接</td>
</tr>
<tr>
<td>android.intent.action.ACTION_POWER_DISCONNECTED</td>
<td>外部电源断开连接</td>
</tr>
<tr>
<td>android.intent.action.DREAMING_STARTED</td>
<td>系统开始休眠</td>
</tr>
<tr>
<td>android.intent.action.DREAMING_STOPPED</td>
<td>系统停止休眠</td>
</tr>
<tr>
<td>android.intent.action.WALLPAPER_CHANGED</td>
<td>壁纸发生变化</td>
</tr>
<tr>
<td>android.intent.action.HEADSET_PLUG</td>
<td>插入耳机</td>
</tr>
<tr>
<td>android.intent.action.MEDIA_UNMOUNTED</td>
<td>卸载外部介质</td>
</tr>
<tr>
<td>android.intent.action.MEDIA_MOUNTED</td>
<td>挂载外部介质</td>
</tr>
<tr>
<td>android.os.action.POWER_SAVE_MODE_CHANGED</td>
<td>省电模式开启</td>
</tr>
</tbody>
</table>
<p><em>（以上广播均可使用 adb 触发）</em></p>
<h3 id="强制停止应用"><a href="#强制停止应用" class="headerlink" title="强制停止应用"></a>强制停止应用</h3><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb shell am force-stop &lt;packagename&gt;</div></pre></td></tr></table></figure>
<p>命令示例：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb shell am force-stop com.qihoo360.mobilesafe</div></pre></td></tr></table></figure>
<p>表示停止 360 安全卫士的一切进程与服务。</p>
<h2 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h2><h3 id="复制设备里的文件到电脑"><a href="#复制设备里的文件到电脑" class="headerlink" title="复制设备里的文件到电脑"></a>复制设备里的文件到电脑</h3><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb pull &lt;设备里的文件路径&gt; [电脑上的目录]</div></pre></td></tr></table></figure>
<p>其中 <code>电脑上的目录</code> 参数可以省略，默认复制到当前目录。</p>
<p>例：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb pull /sdcard/sr.mp4 ~/tmp/</div></pre></td></tr></table></figure>
<p><em>小技巧：</em>设备上的文件路径可能需要 root 权限才能访问，如果你的设备已经 root 过，可以先使用 <code>adb shell</code> 和 <code>su</code> 命令在 adb shell 里获取 root 权限后，先 <code>cp /path/on/device /sdcard/filename</code> 将文件复制到 sdcard，然后 <code>adb pull /sdcard/filename /path/on/pc</code>。</p>
<h3 id="复制电脑里的文件到设备"><a href="#复制电脑里的文件到设备" class="headerlink" title="复制电脑里的文件到设备"></a>复制电脑里的文件到设备</h3><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb push &lt;电脑上的文件路径&gt; &lt;设备里的目录&gt;</div></pre></td></tr></table></figure>
<p>例：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb push ~/sr.mp4 /sdcard/</div></pre></td></tr></table></figure>
<p><em>小技巧：</em>设备上的文件路径普通权限可能无法直接写入，如果你的设备已经 root 过，可以先 <code>adb push /path/on/pc /sdcard/filename</code>，然后 <code>adb shell</code> 和 <code>su</code> 在 adb shell 里获取 root 权限后，<code>cp /sdcard/filename /path/on/device</code>。</p>
<h2 id="模拟按键-输入"><a href="#模拟按键-输入" class="headerlink" title="模拟按键/输入"></a>模拟按键/输入</h2><p>在 <code>adb shell</code> 里有个很实用的命令叫 <code>input</code>，通过它可以做一些有趣的事情。</p>
<p><code>input</code> 命令的完整 help 信息如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">Usage: input [&lt;<span class="built_in">source</span>&gt;] &lt;<span class="built_in">command</span>&gt; [&lt;arg&gt;...]</div><div class="line"></div><div class="line">The sources are:</div><div class="line">      mouse</div><div class="line">      keyboard</div><div class="line">      joystick</div><div class="line">      touchnavigation</div><div class="line">      touchpad</div><div class="line">      trackball</div><div class="line">      stylus</div><div class="line">      dpad</div><div class="line">      gesture</div><div class="line">      touchscreen</div><div class="line">      gamepad</div><div class="line"></div><div class="line">The commands and default sources are:</div><div class="line">      text &lt;string&gt; (Default: touchscreen)</div><div class="line">      keyevent [--longpress] &lt;key code number or name&gt; ... (Default: keyboard)</div><div class="line">      tap &lt;x&gt; &lt;y&gt; (Default: touchscreen)</div><div class="line">      swipe &lt;x1&gt; &lt;y1&gt; &lt;x2&gt; &lt;y2&gt; [duration(ms)] (Default: touchscreen)</div><div class="line">      press (Default: trackball)</div><div class="line">      roll &lt;dx&gt; &lt;dy&gt; (Default: trackball)</div></pre></td></tr></table></figure>
<p>比如使用 <code>adb shell input keyevent &lt;keycode&gt;</code> 命令，不同的 keycode 能实现不同的功能，完整的 keycode 列表详见 <a href="https://developer.android.com/reference/android/view/KeyEvent.html" target="_blank" rel="external">KeyEvent</a>，摘引部分我觉得有意思的如下：</p>
<table>
<thead>
<tr>
<th>keycode</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>3</td>
<td>HOME 键</td>
</tr>
<tr>
<td>4</td>
<td>返回键</td>
</tr>
<tr>
<td>5</td>
<td>打开拨号应用</td>
</tr>
<tr>
<td>6</td>
<td>挂断电话</td>
</tr>
<tr>
<td>24</td>
<td>增加音量</td>
</tr>
<tr>
<td>25</td>
<td>降低音量</td>
</tr>
<tr>
<td>26</td>
<td>电源键</td>
</tr>
<tr>
<td>27</td>
<td>拍照（需要在相机应用里）</td>
</tr>
<tr>
<td>64</td>
<td>打开浏览器</td>
</tr>
<tr>
<td>82</td>
<td>菜单键</td>
</tr>
<tr>
<td>85</td>
<td>播放/暂停</td>
</tr>
<tr>
<td>86</td>
<td>停止播放</td>
</tr>
<tr>
<td>87</td>
<td>播放下一首</td>
</tr>
<tr>
<td>88</td>
<td>播放上一首</td>
</tr>
<tr>
<td>122</td>
<td>移动光标到行首或列表顶部</td>
</tr>
<tr>
<td>123</td>
<td>移动光标到行末或列表底部</td>
</tr>
<tr>
<td>126</td>
<td>恢复播放</td>
</tr>
<tr>
<td>127</td>
<td>暂停播放</td>
</tr>
<tr>
<td>164</td>
<td>静音</td>
</tr>
<tr>
<td>176</td>
<td>打开系统设置</td>
</tr>
<tr>
<td>187</td>
<td>切换应用</td>
</tr>
<tr>
<td>207</td>
<td>打开联系人</td>
</tr>
<tr>
<td>208</td>
<td>打开日历</td>
</tr>
<tr>
<td>209</td>
<td>打开音乐</td>
</tr>
<tr>
<td>210</td>
<td>打开计算器</td>
</tr>
<tr>
<td>220</td>
<td>降低屏幕亮度</td>
</tr>
<tr>
<td>221</td>
<td>提高屏幕亮度</td>
</tr>
<tr>
<td>223</td>
<td>系统休眠</td>
</tr>
<tr>
<td>224</td>
<td>点亮屏幕</td>
</tr>
<tr>
<td>231</td>
<td>打开语音助手</td>
</tr>
<tr>
<td>276</td>
<td>如果没有 wakelock 则让系统休眠</td>
</tr>
</tbody>
</table>
<p>下面是 <code>input</code> 命令的一些用法举例。</p>
<h3 id="电源键"><a href="#电源键" class="headerlink" title="电源键"></a>电源键</h3><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb shell input keyevent 26</div></pre></td></tr></table></figure>
<p>执行效果相当于按电源键。</p>
<h3 id="菜单键"><a href="#菜单键" class="headerlink" title="菜单键"></a>菜单键</h3><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb shell input keyevent 82</div></pre></td></tr></table></figure>
<h3 id="HOME-键"><a href="#HOME-键" class="headerlink" title="HOME 键"></a>HOME 键</h3><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb shell input keyevent 3</div></pre></td></tr></table></figure>
<h3 id="返回键"><a href="#返回键" class="headerlink" title="返回键"></a>返回键</h3><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb shell input keyevent 4</div></pre></td></tr></table></figure>
<h3 id="音量控制"><a href="#音量控制" class="headerlink" title="音量控制"></a>音量控制</h3><p>增加音量：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb shell input keyevent 24</div></pre></td></tr></table></figure>
<p>降低音量：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb shell input keyevent 25</div></pre></td></tr></table></figure>
<p>静音：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb shell input keyevent 164</div></pre></td></tr></table></figure>
<h3 id="媒体控制"><a href="#媒体控制" class="headerlink" title="媒体控制"></a>媒体控制</h3><p>播放/暂停：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb shell input keyevent 85</div></pre></td></tr></table></figure>
<p>停止播放：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb shell input keyevent 86</div></pre></td></tr></table></figure>
<p>播放下一首：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb shell input keyevent 87</div></pre></td></tr></table></figure>
<p>播放上一首：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb shell input keyevent 88</div></pre></td></tr></table></figure>
<p>恢复播放：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb shell input keyevent 126</div></pre></td></tr></table></figure>
<p>暂停播放：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb shell input keyevent 127</div></pre></td></tr></table></figure>
<h3 id="点亮-熄灭屏幕"><a href="#点亮-熄灭屏幕" class="headerlink" title="点亮/熄灭屏幕"></a>点亮/熄灭屏幕</h3><p>可以通过上文讲述过的模拟电源键来切换点亮和熄灭屏幕，但如果明确地想要点亮或者熄灭屏幕，那可以使用如下方法。</p>
<p>点亮屏幕：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb shell input keyevent 224</div></pre></td></tr></table></figure>
<p>熄灭屏幕：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb shell input keyevent 223</div></pre></td></tr></table></figure>
<h3 id="滑动解锁"><a href="#滑动解锁" class="headerlink" title="滑动解锁"></a>滑动解锁</h3><p>如果锁屏没有密码，是通过滑动手势解锁，那么可以通过 <code>input swipe</code> 来解锁。</p>
<p>命令（参数以机型 Nexus 5，向上滑动手势解锁举例）：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb shell input swipe 300 1000 300 500</div></pre></td></tr></table></figure>
<p>参数 <code>300 1000 300 500</code> 分别表示<code>起始点x坐标 起始点y坐标 结束点x坐标 结束点y坐标</code>。</p>
<h3 id="输入文本"><a href="#输入文本" class="headerlink" title="输入文本"></a>输入文本</h3><p>在焦点处于某文本框时，可以通过 <code>input</code> 命令来输入文本。</p>
<p>命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb shell input text hello</div></pre></td></tr></table></figure>
<p>现在 <code>hello</code> 出现在文本框了。</p>
<h2 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h2><p>Android 系统的日志分为两部分，底层的 Linux 内核日志输出到 /proc/kmsg，Android 的日志输出到 /dev/log。</p>
<h3 id="Android-日志"><a href="#Android-日志" class="headerlink" title="Android 日志"></a>Android 日志</h3><p>命令格式：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[adb] logcat [&lt;option&gt;] ... [&lt;filter-spec&gt;] ...</div></pre></td></tr></table></figure>
<p>常用用法列举如下：</p>
<h4 id="按级别过滤日志"><a href="#按级别过滤日志" class="headerlink" title="按级别过滤日志"></a>按级别过滤日志</h4><p>Android 的日志分为如下几个优先级（priority）：</p>
<ul>
<li>V —— Verbose（最低，输出得最多）</li>
<li>D —— Debug</li>
<li>I —— Info</li>
<li>W —— Warning</li>
<li>E —— Error</li>
<li>F —— Fatal</li>
<li>S —— Silent（最高，啥也不输出）</li>
</ul>
<p>按某级别过滤日志则会将该级别及以上的日志输出。</p>
<p>比如，命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb logcat *:W</div></pre></td></tr></table></figure>
<p>会将 Warning、Error、Fatal 和 Silent 日志输出。</p>
<p>（<strong>注：</strong>在 macOS 下需要给 <code>*:W</code> 这样以 <code>*</code> 作为 tag 的参数加双引号，如 <code>adb logcat &quot;*:W&quot;</code>，不然会报错 <code>no matches found: *:W</code>。）</p>
<h4 id="按-tag-和级别过滤日志"><a href="#按-tag-和级别过滤日志" class="headerlink" title="按 tag 和级别过滤日志"></a>按 tag 和级别过滤日志</h4><p><code>&lt;filter-spec&gt;</code> 可以由多个 <code>&lt;tag&gt;[:priority]</code> 组成。</p>
<p>比如，命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb logcat ActivityManager:I MyApp:D *:S</div></pre></td></tr></table></figure>
<p>表示输出 tag <code>ActivityManager</code> 的 Info 以上级别日志，输出 tag <code>MyApp</code> 的 Debug 以上级别日志，及其它 tag 的 Silent 级别日志（即屏蔽其它 tag 日志）。</p>
<h4 id="日志格式"><a href="#日志格式" class="headerlink" title="日志格式"></a>日志格式</h4><p>可以用 <code>adb logcat -v &lt;format&gt;</code> 选项指定日志输出格式。</p>
<p>日志支持按以下几种 <code>&lt;format&gt;</code>：</p>
<ul>
<li><p>brief</p>
<p>默认格式。格式为：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;priority&gt;/&lt;tag&gt;(&lt;pid&gt;): &lt;message&gt;</div></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">D/HeadsetStateMachine( 1785): Disconnected process message: 10, size: 0</div></pre></td></tr></table></figure>
</li>
<li><p>process</p>
<p>格式为：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;priority&gt;(&lt;pid&gt;) &lt;message&gt;</div></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">D( 1785) Disconnected process message: 10, size: 0  (HeadsetStateMachine)</div></pre></td></tr></table></figure>
</li>
<li><p>tag</p>
<p>格式为：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;priority&gt;/&lt;tag&gt;: &lt;message&gt;</div></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">D/HeadsetStateMachine: Disconnected process message: 10, size: 0</div></pre></td></tr></table></figure>
</li>
<li><p>raw</p>
<p>格式为：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;message&gt;</div></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Disconnected process message: 10, size: 0</div></pre></td></tr></table></figure>
</li>
<li><p>time</p>
<p>格式为：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;datetime&gt; &lt;priority&gt;/&lt;tag&gt;(&lt;pid&gt;): &lt;message&gt;</div></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">08-28 22:39:39.974 D/HeadsetStateMachine( 1785): Disconnected process message: 10, size: 0</div></pre></td></tr></table></figure>
</li>
<li><p>threadtime</p>
<p>格式为：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;datetime&gt; &lt;pid&gt; &lt;tid&gt; &lt;priority&gt; &lt;tag&gt;: &lt;message&gt;</div></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">08-28 22:39:39.974  1785  1832 D HeadsetStateMachine: Disconnected process message: 10, size: 0</div></pre></td></tr></table></figure>
</li>
<li><p>long</p>
<p>格式为：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[ &lt;datetime&gt; &lt;pid&gt;:&lt;tid&gt; &lt;priority&gt;/&lt;tag&gt; ]</div><div class="line">&lt;message&gt;</div></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[ 08-28 22:39:39.974  1785: 1832 D/HeadsetStateMachine ]</div><div class="line">Disconnected process message: 10, size: 0</div></pre></td></tr></table></figure>
</li>
</ul>
<p>指定格式可与上面的过滤同时使用。比如：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb logcat -v long ActivityManager:I *:S</div></pre></td></tr></table></figure>
<h4 id="清空日志"><a href="#清空日志" class="headerlink" title="清空日志"></a>清空日志</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb logcat -c</div></pre></td></tr></table></figure>
<h3 id="内核日志"><a href="#内核日志" class="headerlink" title="内核日志"></a>内核日志</h3><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb shell dmesg</div></pre></td></tr></table></figure>
<p>输出示例：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;6&gt;[14201.684016] PM: noirq resume of devices complete after 0.982 msecs</div><div class="line">&lt;6&gt;[14201.685525] PM: early resume of devices complete after 0.838 msecs</div><div class="line">&lt;6&gt;[14201.753642] PM: resume of devices complete after 68.106 msecs</div><div class="line">&lt;4&gt;[14201.755954] Restarting tasks ... <span class="keyword">done</span>.</div><div class="line">&lt;6&gt;[14201.771229] PM: <span class="built_in">suspend</span> <span class="built_in">exit</span> 2016-08-28 13:31:32.679217193 UTC</div><div class="line">&lt;6&gt;[14201.872373] PM: <span class="built_in">suspend</span> entry 2016-08-28 13:31:32.780363596 UTC</div><div class="line">&lt;6&gt;[14201.872498] PM: Syncing filesystems ... <span class="keyword">done</span>.</div></pre></td></tr></table></figure>
<p>中括号里的 <code>[14201.684016]</code> 代表内核开始启动后的时间，单位为秒。</p>
<p>通过内核日志我们可以做一些事情，比如衡量内核启动时间，在系统启动完毕后的内核日志里找到 <code>Freeing init memory</code> 那一行前面的时间就是。</p>
<h2 id="查看设备信息"><a href="#查看设备信息" class="headerlink" title="查看设备信息"></a>查看设备信息</h2><h3 id="型号"><a href="#型号" class="headerlink" title="型号"></a>型号</h3><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb shell getprop ro.product.model</div></pre></td></tr></table></figure>
<p>输出示例：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Nexus 5</div></pre></td></tr></table></figure>
<h3 id="电池状况"><a href="#电池状况" class="headerlink" title="电池状况"></a>电池状况</h3><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb shell dumpsys battery</div></pre></td></tr></table></figure>
<p>输入示例：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Current Battery Service state:</div><div class="line">  AC powered: <span class="literal">false</span></div><div class="line">  USB powered: <span class="literal">true</span></div><div class="line">  Wireless powered: <span class="literal">false</span></div><div class="line">  status: 2</div><div class="line">  health: 2</div><div class="line">  present: <span class="literal">true</span></div><div class="line">  level: 44</div><div class="line">  scale: 100</div><div class="line">  voltage: 3872</div><div class="line">  temperature: 280</div><div class="line">  technology: Li-poly</div></pre></td></tr></table></figure>
<p>其中 <code>scale</code> 代表最大电量，<code>level</code> 代表当前电量。上面的输出表示还剩下 44% 的电量。</p>
<h3 id="屏幕分辨率"><a href="#屏幕分辨率" class="headerlink" title="屏幕分辨率"></a>屏幕分辨率</h3><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb shell wm size</div></pre></td></tr></table></figure>
<p>输出示例：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Physical size: 1080x1920</div></pre></td></tr></table></figure>
<p>该设备屏幕分辨率为 1080px * 1920px。</p>
<p>如果使用命令修改过，那输出可能是：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Physical size: 1080x1920</div><div class="line">Override size: 480x1024</div></pre></td></tr></table></figure>
<p>表明设备的屏幕分辨率原本是 1080px <em> 1920px，当前被修改为 480px </em> 1024px。</p>
<h3 id="屏幕密度"><a href="#屏幕密度" class="headerlink" title="屏幕密度"></a>屏幕密度</h3><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb shell wm density</div></pre></td></tr></table></figure>
<p>输出示例：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Physical density: 420</div></pre></td></tr></table></figure>
<p>该设备屏幕密度为 420dpi。</p>
<p>如果使用命令修改过，那输出可能是：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Physical density: 480</div><div class="line">Override density: 160</div></pre></td></tr></table></figure>
<p>表明设备的屏幕密度原来是 480dpi，当前被修改为 160dpi。</p>
<h3 id="显示屏参数"><a href="#显示屏参数" class="headerlink" title="显示屏参数"></a>显示屏参数</h3><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb shell dumpsys window displays</div></pre></td></tr></table></figure>
<p>输出示例：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">WINDOW MANAGER DISPLAY CONTENTS (dumpsys window displays)</div><div class="line">  Display: mDisplayId=0</div><div class="line">    init=1080x1920 420dpi cur=1080x1920 app=1080x1794 rng=1080x1017-1810x1731</div><div class="line">    deferred=<span class="literal">false</span> layoutNeeded=<span class="literal">false</span></div></pre></td></tr></table></figure>
<p>其中 <code>mDisplayId</code> 为 显示屏编号，<code>init</code> 是初始分辨率和屏幕密度，<code>app</code> 的高度比 <code>init</code> 里的要小，表示屏幕底部有虚拟按键，高度为 1920 - 1794 = 126px 合 42dp。</p>
<h3 id="android-id"><a href="#android-id" class="headerlink" title="android_id"></a>android_id</h3><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb shell settings get secure android_id</div></pre></td></tr></table></figure>
<p>输出示例：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">51b6be48bac8c569</div></pre></td></tr></table></figure>
<h3 id="IMEI"><a href="#IMEI" class="headerlink" title="IMEI"></a>IMEI</h3><p>在 Android 4.4 及以下版本可通过如下命令获取 IMEI：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb shell dumpsys iphonesubinfo</div></pre></td></tr></table></figure>
<p>输出示例：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Phone Subscriber Info:</div><div class="line">  Phone Type = GSM</div><div class="line">  Device ID = 860955027785041</div></pre></td></tr></table></figure>
<p>其中的 <code>Device ID</code> 就是 IMEI。</p>
<p>而在 Android 5.0 及以上版本里这个命令输出为空，得通过其它方式获取了（需要 root 权限）：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">adb shell</div><div class="line">su</div><div class="line">service call iphonesubinfo 1</div></pre></td></tr></table></figure>
<p>输出示例：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Result: Parcel(</div><div class="line">  0x00000000: 00000000 0000000f 00360038 00390030 <span class="string">'........8.6.0.9.'</span></div><div class="line">  0x00000010: 00350035 00320030 00370037 00350038 <span class="string">'5.5.0.2.7.7.8.5.'</span></div><div class="line">  0x00000020: 00340030 00000031                   <span class="string">'0.4.1...        '</span>)</div></pre></td></tr></table></figure>
<p>把里面的有效内容提取出来就是 IMEI 了，比如这里的是 <code>860955027785041</code>。</p>
<p>参考：<a href="http://stackoverflow.com/questions/27002663/adb-shell-dumpsys-iphonesubinfo-not-working-since-android-5-0-lollipop" target="_blank" rel="external">adb shell dumpsys iphonesubinfo not working since Android 5.0 Lollipop</a></p>
<h3 id="Android-系统版本"><a href="#Android-系统版本" class="headerlink" title="Android 系统版本"></a>Android 系统版本</h3><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb shell getprop ro.build.version.release</div></pre></td></tr></table></figure>
<p>输出示例：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">5.0.2</div></pre></td></tr></table></figure>
<h3 id="IP-地址"><a href="#IP-地址" class="headerlink" title="IP 地址"></a>IP 地址</h3><p>每次想知道设备的 IP 地址的时候都得「设置」-「关于手机」-「状态信息」-「IP地址」很烦对不对？通过 adb 可以方便地查看。</p>
<p>命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb shell ifconfig | grep Mask</div></pre></td></tr></table></figure>
<p>输出示例：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">inet addr:10.130.245.230  Mask:255.255.255.252</div><div class="line">inet addr:127.0.0.1  Mask:255.0.0.0</div></pre></td></tr></table></figure>
<p>那么 <code>10.130.245.230</code> 就是设备 IP 地址。</p>
<p>在有的设备上这个命令没有输出，如果设备连着 WiFi，可以使用如下命令来查看局域网 IP：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb shell ifconfig wlan0</div></pre></td></tr></table></figure>
<p>输出示例：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wlan0: ip 10.129.160.99 mask 255.255.240.0 flags [up broadcast running multicast]</div></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">wlan0     Link encap:UNSPEC</div><div class="line">          inet addr:10.129.168.57  Bcast:10.129.175.255  Mask:255.255.240.0</div><div class="line">          inet6 addr: fe80::66cc:2eff:fe68:b6b6/64 Scope: Link</div><div class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</div><div class="line">          RX packets:496520 errors:0 dropped:0 overruns:0 frame:0</div><div class="line">          TX packets:68215 errors:0 dropped:0 overruns:0 carrier:0</div><div class="line">          collisions:0 txqueuelen:3000</div><div class="line">          RX bytes:116266821 TX bytes:8311736</div></pre></td></tr></table></figure>
<p>如果以上命令仍然不能得到期望的信息，那可以试试以下命令（部分系统版本里可用）：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb shell netcfg</div></pre></td></tr></table></figure>
<p>输出示例：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">wlan0    UP                               10.129.160.99/20  0x00001043 f8:a9:d0:17:42:4d</div><div class="line">lo       UP                                   127.0.0.1/8   0x00000049 00:00:00:00:00:00</div><div class="line">p2p0     UP                                     0.0.0.0/0   0x00001003 fa:a9:d0:17:42:4d</div><div class="line">sit0     DOWN                                   0.0.0.0/0   0x00000080 00:00:00:00:00:00</div><div class="line">rmnet0   DOWN                                   0.0.0.0/0   0x00000000 00:00:00:00:00:00</div><div class="line">rmnet1   DOWN                                   0.0.0.0/0   0x00000000 00:00:00:00:00:00</div><div class="line">rmnet3   DOWN                                   0.0.0.0/0   0x00000000 00:00:00:00:00:00</div><div class="line">rmnet2   DOWN                                   0.0.0.0/0   0x00000000 00:00:00:00:00:00</div><div class="line">rmnet4   DOWN                                   0.0.0.0/0   0x00000000 00:00:00:00:00:00</div><div class="line">rmnet6   DOWN                                   0.0.0.0/0   0x00000000 00:00:00:00:00:00</div><div class="line">rmnet5   DOWN                                   0.0.0.0/0   0x00000000 00:00:00:00:00:00</div><div class="line">rmnet7   DOWN                                   0.0.0.0/0   0x00000000 00:00:00:00:00:00</div><div class="line">rev_rmnet3 DOWN                                   0.0.0.0/0   0x00001002 4e:b7:e4:2e:17:58</div><div class="line">rev_rmnet2 DOWN                                   0.0.0.0/0   0x00001002 4e:f0:c8:bf:7a:cf</div><div class="line">rev_rmnet4 DOWN                                   0.0.0.0/0   0x00001002 a6:c0:3b:6b:c4:1f</div><div class="line">rev_rmnet6 DOWN                                   0.0.0.0/0   0x00001002 66:bb:5d:64:2e:e9</div><div class="line">rev_rmnet5 DOWN                                   0.0.0.0/0   0x00001002 0e:1b:eb:b9:23:a0</div><div class="line">rev_rmnet7 DOWN                                   0.0.0.0/0   0x00001002 7a:d9:f6:81:40:5a</div><div class="line">rev_rmnet8 DOWN                                   0.0.0.0/0   0x00001002 4e:e2:a9:bb:d0:1b</div><div class="line">rev_rmnet0 DOWN                                   0.0.0.0/0   0x00001002 fe:65:d0:ca:82:a9</div><div class="line">rev_rmnet1 DOWN                                   0.0.0.0/0   0x00001002 da:d8:e8:4f:2e:fe</div></pre></td></tr></table></figure>
<p>可以看到网络连接名称、启用状态、IP 地址和 Mac 地址等信息。</p>
<h3 id="Mac-地址"><a href="#Mac-地址" class="headerlink" title="Mac 地址"></a>Mac 地址</h3><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb shell cat /sys/class/net/wlan0/address</div></pre></td></tr></table></figure>
<p>输出示例：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">f8:a9:d0:17:42:4d</div></pre></td></tr></table></figure>
<p>这查看的是局域网 Mac 地址，移动网络或其它连接的信息可以通过前面的小节「IP 地址」里提到的 <code>adb shell netcfg</code> 命令来查看。</p>
<h3 id="CPU-信息"><a href="#CPU-信息" class="headerlink" title="CPU 信息"></a>CPU 信息</h3><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb shell cat /proc/cpuinfo</div></pre></td></tr></table></figure>
<p>输出示例：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">Processor       : ARMv7 Processor rev 0 (v7l)</div><div class="line">processor       : 0</div><div class="line">BogoMIPS        : 38.40</div><div class="line"></div><div class="line">processor       : 1</div><div class="line">BogoMIPS        : 38.40</div><div class="line"></div><div class="line">processor       : 2</div><div class="line">BogoMIPS        : 38.40</div><div class="line"></div><div class="line">processor       : 3</div><div class="line">BogoMIPS        : 38.40</div><div class="line"></div><div class="line">Features        : swp half thumb fastmult vfp edsp neon vfpv3 tls vfpv4 idiva idivt</div><div class="line">CPU implementer : 0x51</div><div class="line">CPU architecture: 7</div><div class="line">CPU variant     : 0x2</div><div class="line">CPU part        : 0x06f</div><div class="line">CPU revision    : 0</div><div class="line"></div><div class="line">Hardware        : Qualcomm MSM 8974 HAMMERHEAD (Flattened Device Tree)</div><div class="line">Revision        : 000b</div><div class="line">Serial          : 0000000000000000</div></pre></td></tr></table></figure>
<p>这是 Nexus 5 的 CPU 信息，我们从输出里可以看到使用的硬件是 <code>Qualcomm MSM 8974</code>，processor 的编号是 0 到 3，所以它是四核的，采用的架构是 <code>ARMv7 Processor rev 0 (v71)</code>。</p>
<h3 id="内存信息"><a href="#内存信息" class="headerlink" title="内存信息"></a>内存信息</h3><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb shell cat /proc/meminfo</div></pre></td></tr></table></figure>
<p>输出示例：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">MemTotal:        1027424 kB</div><div class="line">MemFree:          486564 kB</div><div class="line">Buffers:           15224 kB</div><div class="line">Cached:            72464 kB</div><div class="line">SwapCached:        24152 kB</div><div class="line">Active:           110572 kB</div><div class="line">Inactive:         259060 kB</div><div class="line">Active(anon):      79176 kB</div><div class="line">Inactive(anon):   207736 kB</div><div class="line">Active(file):      31396 kB</div><div class="line">Inactive(file):    51324 kB</div><div class="line">Unevictable:        3948 kB</div><div class="line">Mlocked:               0 kB</div><div class="line">HighTotal:        409600 kB</div><div class="line">HighFree:         132612 kB</div><div class="line">LowTotal:         617824 kB</div><div class="line">LowFree:          353952 kB</div><div class="line">SwapTotal:        262140 kB</div><div class="line">SwapFree:         207572 kB</div><div class="line">Dirty:                 0 kB</div><div class="line">Writeback:             0 kB</div><div class="line">AnonPages:        265324 kB</div><div class="line">Mapped:            47072 kB</div><div class="line">Shmem:              1020 kB</div><div class="line">Slab:              57372 kB</div><div class="line">SReclaimable:       7692 kB</div><div class="line">SUnreclaim:        49680 kB</div><div class="line">KernelStack:        4512 kB</div><div class="line">PageTables:         5912 kB</div><div class="line">NFS_Unstable:          0 kB</div><div class="line">Bounce:                0 kB</div><div class="line">WritebackTmp:          0 kB</div><div class="line">CommitLimit:      775852 kB</div><div class="line">Committed_AS:   13520632 kB</div><div class="line">VmallocTotal:     385024 kB</div><div class="line">VmallocUsed:       61004 kB</div><div class="line">VmallocChunk:     209668 kB</div></pre></td></tr></table></figure>
<p>其中，<code>MemTotal</code> 就是设备的总内存，<code>MemFree</code> 是当前空闲内存。</p>
<h3 id="更多硬件与系统属性"><a href="#更多硬件与系统属性" class="headerlink" title="更多硬件与系统属性"></a>更多硬件与系统属性</h3><p>设备的更多硬件与系统属性可以通过如下命令查看：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb shell cat /system/build.prop</div></pre></td></tr></table></figure>
<p>这会输出很多信息，包括前面几个小节提到的「型号」和「Android 系统版本」等。</p>
<p>输出里还包括一些其它有用的信息，它们也可通过 <code>adb shell getprop &lt;属性名&gt;</code> 命令单独查看，列举一部分属性如下：</p>
<table>
<thead>
<tr>
<th>属性名</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>ro.build.version.sdk</td>
<td>SDK 版本</td>
</tr>
<tr>
<td>ro.build.version.release</td>
<td>Android 系统版本</td>
</tr>
<tr>
<td>ro.build.version.security_patch</td>
<td>Android 安全补丁程序级别</td>
</tr>
<tr>
<td>ro.product.model</td>
<td>型号</td>
</tr>
<tr>
<td>ro.product.brand</td>
<td>品牌</td>
</tr>
<tr>
<td>ro.product.name</td>
<td>设备名</td>
</tr>
<tr>
<td>ro.product.board</td>
<td>处理器型号</td>
</tr>
<tr>
<td>ro.product.cpu.abilist</td>
<td>CPU 支持的 abi 列表[<em>节注一</em>]</td>
</tr>
<tr>
<td>persist.sys.isUsbOtgEnabled</td>
<td>是否支持 OTG</td>
</tr>
<tr>
<td>dalvik.vm.heapsize</td>
<td>每个应用程序的内存上限</td>
</tr>
<tr>
<td>ro.sf.lcd_density</td>
<td>屏幕密度</td>
</tr>
</tbody>
</table>
<p><em>节注一：</em></p>
<p>一些小厂定制的 ROM 可能修改过 CPU 支持的 abi 列表的属性名，如果用 <code>ro.product.cpu.abilist</code> 属性名查找不到，可以这样试试：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb shell cat /system/build.prop | grep ro.product.cpu.abi</div></pre></td></tr></table></figure>
<p>示例输出：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ro.product.cpu.abi=armeabi-v7a</div><div class="line">ro.product.cpu.abi2=armeabi</div></pre></td></tr></table></figure>
<h2 id="修改设置"><a href="#修改设置" class="headerlink" title="修改设置"></a>修改设置</h2><p><strong>注：</strong>修改设置之后，运行恢复命令有可能显示仍然不太正常，可以运行 <code>adb reboot</code> 重启设备，或手动重启。</p>
<p>修改设置的原理主要是通过 settings 命令修改 /data/data/com.android.providers.settings/databases/settings.db 里存放的设置值。</p>
<h3 id="分辨率"><a href="#分辨率" class="headerlink" title="分辨率"></a>分辨率</h3><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb shell wm size 480x1024</div></pre></td></tr></table></figure>
<p>表示将分辨率修改为 480px * 1024px。</p>
<p>恢复原分辨率命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb shell wm size reset</div></pre></td></tr></table></figure>
<h3 id="屏幕密度-1"><a href="#屏幕密度-1" class="headerlink" title="屏幕密度"></a>屏幕密度</h3><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb shell wm density 160</div></pre></td></tr></table></figure>
<p>表示将屏幕密度修改为 160dpi。</p>
<p>恢复原屏幕密度命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb shell wm density reset</div></pre></td></tr></table></figure>
<h3 id="显示区域"><a href="#显示区域" class="headerlink" title="显示区域"></a>显示区域</h3><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb shell wm overscan 0,0,0,200</div></pre></td></tr></table></figure>
<p>四个数字分别表示距离左、上、右、下边缘的留白像素，以上命令表示将屏幕底部 200px 留白。</p>
<p>恢复原显示区域命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb shell wm overscan reset</div></pre></td></tr></table></figure>
<h3 id="关闭-USB-调试模式"><a href="#关闭-USB-调试模式" class="headerlink" title="关闭 USB 调试模式"></a>关闭 USB 调试模式</h3><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb shell settings put global adb_enabled 0</div></pre></td></tr></table></figure>
<p>恢复：</p>
<p>用命令恢复不了了，毕竟关闭了 USB 调试 adb 就连接不上 Android 设备了。</p>
<p>去设备上手动恢复吧：「设置」-「开发者选项」-「Android 调试」。</p>
<h3 id="状态栏和导航栏的显示隐藏"><a href="#状态栏和导航栏的显示隐藏" class="headerlink" title="状态栏和导航栏的显示隐藏"></a>状态栏和导航栏的显示隐藏</h3><p>本节所说的相关设置对应 Cyanogenmod 里的「扩展桌面」。</p>
<p>命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb shell settings put global policy_control &lt;key-values&gt;</div></pre></td></tr></table></figure>
<p><code>&lt;key-values&gt;</code> 可由如下几种键及其对应的值组成，格式为 <code>&lt;key1&gt;=&lt;value1&gt;:&lt;key2&gt;=&lt;value2&gt;</code>。</p>
<table>
<thead>
<tr>
<th>key</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>immersive.full</td>
<td>同时隐藏</td>
</tr>
<tr>
<td>immersive.status</td>
<td>隐藏状态栏</td>
</tr>
<tr>
<td>immersive.navigation</td>
<td>隐藏导航栏</td>
</tr>
<tr>
<td>immersive.preconfirms</td>
<td>?</td>
</tr>
</tbody>
</table>
<p>这些键对应的值可则如下值用逗号组合：</p>
<table>
<thead>
<tr>
<th>value</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>apps</code></td>
<td>所有应用</td>
</tr>
<tr>
<td><code>*</code></td>
<td>所有界面</td>
</tr>
<tr>
<td><code>packagename</code></td>
<td>指定应用</td>
</tr>
<tr>
<td><code>-packagename</code></td>
<td>排除指定应用</td>
</tr>
</tbody>
</table>
<p>例如：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb shell settings put global policy_control immersive.full=*</div></pre></td></tr></table></figure>
<p>表示设置在所有界面下都同时隐藏状态栏和导航栏。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb shell settings put global policy_control immersive.status=com.package1,com.package2:immersive.navigation=apps,-com.package3</div></pre></td></tr></table></figure>
<p>表示设置在包名为 <code>com.package1</code> 和 <code>com.package2</code> 的应用里隐藏状态栏，在除了包名为 <code>com.package3</code> 的所有应用里隐藏导航栏。</p>
<h2 id="实用功能"><a href="#实用功能" class="headerlink" title="实用功能"></a>实用功能</h2><h3 id="屏幕截图"><a href="#屏幕截图" class="headerlink" title="屏幕截图"></a>屏幕截图</h3><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb shell screencap -p /sdcard/sc.png</div></pre></td></tr></table></figure>
<p>然后将 png 文件导出到电脑：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb pull /sdcard/sc.png</div></pre></td></tr></table></figure>
<p>可以使用 <code>adb shell screencap -h</code> 查看 <code>screencap</code> 命令的帮助信息，下面是两个有意义的参数及含义：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>-p</td>
<td>指定保存文件为 png 格式</td>
</tr>
<tr>
<td>-d display-id</td>
<td>指定截图的显示屏编号（有多显示屏的情况下）</td>
</tr>
</tbody>
</table>
<p>实测如果指定文件名以 <code>.png</code> 结尾时可以省略 -p 参数；否则需要使用 -p 参数。如果不指定文件名，截图文件的内容将直接输出到 stdout。</p>
<p>直接一行命令截图并保存到电脑的方法：</p>
<p><em>Linux 和 Windows</em></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb shell screencap -p | sed <span class="string">"s/\r$//"</span> &gt; sc.png</div></pre></td></tr></table></figure>
<p><em>Mac OS X</em></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb shell screencap -p | gsed <span class="string">"s/\r$//"</span> &gt; sc.png</div></pre></td></tr></table></figure>
<p>这个方法需要用到 gnu sed 命令，在 Linux 下直接就有，在 Windows 下 Git 安装目录的 bin 文件夹下也有。如果确实找不到该命令，可以下载 <a href="http://gnuwin32.sourceforge.net/packages/sed.htm" target="_blank" rel="external">sed for Windows</a> 并将 sed.exe 所在文件夹添加到 PATH 环境变量里。</p>
<p>而在 Mac 下使用系统自带的 sed 命令会报错：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed: RE error: illegal byte sequence</div></pre></td></tr></table></figure>
<p>需要安装 gnu-sed，然后使用 gsed 命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew install gnu-sed</div></pre></td></tr></table></figure>
<h3 id="录制屏幕"><a href="#录制屏幕" class="headerlink" title="录制屏幕"></a>录制屏幕</h3><p>录制屏幕以 mp4 格式保存到 /sdcard：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb shell screenrecord /sdcard/filename.mp4</div></pre></td></tr></table></figure>
<p>需要停止时按 <kbd>Ctrl-C</kbd>，默认录制时间和最长录制时间都是 180 秒。</p>
<p>如果需要导出到电脑：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb pull /sdcard/filename.mp4</div></pre></td></tr></table></figure>
<p>可以使用 <code>adb shell screenrecord --help</code> 查看 <code>screenrecord</code> 命令的帮助信息，下面是常见参数及含义：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>–size WIDTHxHEIGHT</td>
<td>视频的尺寸，比如 <code>1280x720</code>，默认是屏幕分辨率。</td>
</tr>
<tr>
<td>–bit-rate RATE</td>
<td>视频的比特率，默认是 4Mbps。</td>
</tr>
<tr>
<td>–time-limit TIME</td>
<td>录制时长，单位秒。</td>
</tr>
<tr>
<td>–verbose</td>
<td>输出更多信息。</td>
</tr>
</tbody>
</table>
<h3 id="重新挂载-system-分区为可写"><a href="#重新挂载-system-分区为可写" class="headerlink" title="重新挂载 system 分区为可写"></a>重新挂载 system 分区为可写</h3><p><strong>注：需要 root 权限。</strong></p>
<p>/system 分区默认挂载为只读，但有些操作比如给 Android 系统添加命令、删除自带应用等需要对 /system 进行写操作，所以需要重新挂载它为可读写。</p>
<p>步骤：</p>
<ol>
<li><p>进入 shell 并切换到 root 用户权限。</p>
<p>命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">adb shell</div><div class="line">su</div></pre></td></tr></table></figure>
</li>
<li><p>查看当前分区挂载情况。</p>
<p>命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mount</div></pre></td></tr></table></figure>
<p>输出示例：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">rootfs / rootfs ro,relatime 0 0</div><div class="line">tmpfs /dev tmpfs rw,seclabel,nosuid,relatime,mode=755 0 0</div><div class="line">devpts /dev/pts devpts rw,seclabel,relatime,mode=600 0 0</div><div class="line">proc /proc proc rw,relatime 0 0</div><div class="line">sysfs /sys sysfs rw,seclabel,relatime 0 0</div><div class="line">selinuxfs /sys/fs/selinux selinuxfs rw,relatime 0 0</div><div class="line">debugfs /sys/kernel/debug debugfs rw,relatime 0 0</div><div class="line">none /var tmpfs rw,seclabel,relatime,mode=770,gid=1000 0 0</div><div class="line">none /acct cgroup rw,relatime,cpuacct 0 0</div><div class="line">none /sys/fs/cgroup tmpfs rw,seclabel,relatime,mode=750,gid=1000 0 0</div><div class="line">none /sys/fs/cgroup/memory cgroup rw,relatime,memory 0 0</div><div class="line">tmpfs /mnt/asec tmpfs rw,seclabel,relatime,mode=755,gid=1000 0 0</div><div class="line">tmpfs /mnt/obb tmpfs rw,seclabel,relatime,mode=755,gid=1000 0 0</div><div class="line">none /dev/memcg cgroup rw,relatime,memory 0 0</div><div class="line">none /dev/cpuctl cgroup rw,relatime,cpu 0 0</div><div class="line">none /sys/fs/cgroup tmpfs rw,seclabel,relatime,mode=750,gid=1000 0 0</div><div class="line">none /sys/fs/cgroup/memory cgroup rw,relatime,memory 0 0</div><div class="line">none /sys/fs/cgroup/freezer cgroup rw,relatime,freezer 0 0</div><div class="line">/dev/block/platform/msm_sdcc.1/by-name/system /system ext4 ro,seclabel,relatime,data=ordered 0 0</div><div class="line">/dev/block/platform/msm_sdcc.1/by-name/userdata /data ext4 rw,seclabel,nosuid,nodev,relatime,noauto_da_alloc,data=ordered 0 0</div><div class="line">/dev/block/platform/msm_sdcc.1/by-name/cache /cache ext4 rw,seclabel,nosuid,nodev,relatime,data=ordered 0 0</div><div class="line">/dev/block/platform/msm_sdcc.1/by-name/persist /persist ext4 rw,seclabel,nosuid,nodev,relatime,data=ordered 0 0</div><div class="line">/dev/block/platform/msm_sdcc.1/by-name/modem /firmware vfat ro,context=u:object_r:firmware_file:s0,relatime,uid=1000,gid=1000,fmask=0337,dmask=0227,codepage=cp437,iocharset=iso8859-1,shortname=lower,errors=remount-ro 0 0</div><div class="line">/dev/fuse /mnt/shell/emulated fuse rw,nosuid,nodev,relatime,user_id=1023,group_id=1023,default_permissions,allow_other 0 0</div><div class="line">/dev/fuse /mnt/shell/emulated/0 fuse rw,nosuid,nodev,relatime,user_id=1023,group_id=1023,default_permissions,allow_other 0 0</div></pre></td></tr></table></figure>
<p>找到其中我们关注的带 /system 的那一行：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/dev/block/platform/msm_sdcc.1/by-name/system /system ext4 ro,seclabel,relatime,data=ordered 0 0</div></pre></td></tr></table></figure>
</li>
<li><p>重新挂载。</p>
<p>命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mount -o remount,rw -t yaffs2 /dev/block/platform/msm_sdcc.1/by-name/system /system</div></pre></td></tr></table></figure>
<p>这里的 <code>/dev/block/platform/msm_sdcc.1/by-name/system</code> 就是我们从上一步的输出里得到的文件路径。</p>
</li>
</ol>
<p>如果输出没有提示错误的话，操作就成功了，可以对 /system 下的文件为所欲为了。</p>
<h3 id="查看连接过的-WiFi-密码"><a href="#查看连接过的-WiFi-密码" class="headerlink" title="查看连接过的 WiFi 密码"></a>查看连接过的 WiFi 密码</h3><p><strong>注：需要 root 权限。</strong></p>
<p>命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">adb shell</div><div class="line">su</div><div class="line">cat /data/misc/wifi/*.conf</div></pre></td></tr></table></figure>
<p>输出示例：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">network=&#123;</div><div class="line">	ssid=<span class="string">"TP-LINK_9DFC"</span></div><div class="line">	scan_ssid=1</div><div class="line">	psk=<span class="string">"123456789"</span></div><div class="line">	key_mgmt=WPA-PSK</div><div class="line">	group=CCMP TKIP</div><div class="line">	auth_alg=OPEN</div><div class="line">	sim_num=1</div><div class="line">	priority=13893</div><div class="line">&#125;</div><div class="line"></div><div class="line">network=&#123;</div><div class="line">	ssid=<span class="string">"TP-LINK_F11E"</span></div><div class="line">	psk=<span class="string">"987654321"</span></div><div class="line">	key_mgmt=WPA-PSK</div><div class="line">	sim_num=1</div><div class="line">	priority=17293</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>ssid</code> 即为我们在 WLAN 设置里看到的名称，<code>psk</code> 为密码，<code>key_mgmt</code> 为安全加密方式。</p>
<h3 id="设置系统日期和时间"><a href="#设置系统日期和时间" class="headerlink" title="设置系统日期和时间"></a>设置系统日期和时间</h3><p><strong>注：需要 root 权限。</strong></p>
<p>命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">adb shell</div><div class="line">su</div><div class="line">date -s 20160823.131500</div></pre></td></tr></table></figure>
<p>表示将系统日期和时间更改为 2016 年 08 月 23 日 13 点 15 分 00 秒。</p>
<h3 id="重启手机"><a href="#重启手机" class="headerlink" title="重启手机"></a>重启手机</h3><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb reboot</div></pre></td></tr></table></figure>
<h3 id="检测设备是否已-root"><a href="#检测设备是否已-root" class="headerlink" title="检测设备是否已 root"></a>检测设备是否已 root</h3><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">adb shell</div><div class="line">su</div></pre></td></tr></table></figure>
<p>此时命令行提示符是 <code>$</code> 则表示没有 root 权限，是 <code>#</code> 则表示已 root。</p>
<h3 id="使用-Monkey-进行压力测试"><a href="#使用-Monkey-进行压力测试" class="headerlink" title="使用 Monkey 进行压力测试"></a>使用 Monkey 进行压力测试</h3><p>Monkey 可以生成伪随机用户事件来模拟单击、触摸、手势等操作，可以对正在开发中的程序进行随机压力测试。</p>
<p>简单用法：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb shell monkey -p &lt;packagename&gt; -v 500</div></pre></td></tr></table></figure>
<p>表示向 <code>&lt;packagename&gt;</code> 指定的应用程序发送 500 个伪随机事件。</p>
<p>Monkey 的详细用法参考 <a href="https://developer.android.com/studio/test/monkey.html" target="_blank" rel="external">官方文档</a>。</p>
<h3 id="开启-关闭-WiFi"><a href="#开启-关闭-WiFi" class="headerlink" title="开启/关闭 WiFi"></a>开启/关闭 WiFi</h3><p><strong>注：需要 root 权限。</strong></p>
<p>有时需要控制设备的 WiFi 状态，可以用以下指令完成。</p>
<p>开启 WiFi：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">adb root</div><div class="line">adb shell svc wifi <span class="built_in">enable</span></div></pre></td></tr></table></figure>
<p>关闭 WiFi：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">adb root</div><div class="line">adb shell svc wifi <span class="built_in">disable</span></div></pre></td></tr></table></figure>
<p>若执行成功，输出为空；若未取得 root 权限执行此命令，将执行失败，输出 <code>Killed</code>。</p>
<h2 id="刷机相关命令"><a href="#刷机相关命令" class="headerlink" title="刷机相关命令"></a>刷机相关命令</h2><h3 id="重启到-Recovery-模式"><a href="#重启到-Recovery-模式" class="headerlink" title="重启到 Recovery 模式"></a>重启到 Recovery 模式</h3><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb reboot recovery</div></pre></td></tr></table></figure>
<h3 id="从-Recovery-重启到-Android"><a href="#从-Recovery-重启到-Android" class="headerlink" title="从 Recovery 重启到 Android"></a>从 Recovery 重启到 Android</h3><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb reboot</div></pre></td></tr></table></figure>
<h3 id="重启到-Fastboot-模式"><a href="#重启到-Fastboot-模式" class="headerlink" title="重启到 Fastboot 模式"></a>重启到 Fastboot 模式</h3><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb reboot bootloader</div></pre></td></tr></table></figure>
<h3 id="通过-sideload-更新系统"><a href="#通过-sideload-更新系统" class="headerlink" title="通过 sideload 更新系统"></a>通过 sideload 更新系统</h3><p>如果我们下载了 Android 设备对应的系统更新包到电脑上，那么也可以通过 adb 来完成更新。</p>
<p>以 Recovery 模式下更新为例：</p>
<ol>
<li><p>重启到 Recovery 模式。</p>
<p>命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb reboot recovery</div></pre></td></tr></table></figure>
</li>
<li><p>在设备的 Recovery 界面上操作进入 <code>Apply update</code>-<code>Apply from ADB</code>。</p>
<p>注：不同的 Recovery 菜单可能与此有差异，有的是一级菜单就有 <code>Apply update from ADB</code>。</p>
</li>
<li><p>通过 adb 上传和更新系统。</p>
<p>命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb sideload &lt;path-to-update.zip&gt;</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="更多-adb-shell-命令"><a href="#更多-adb-shell-命令" class="headerlink" title="更多 adb shell 命令"></a>更多 adb shell 命令</h2><p>Android 系统是基于 Linux 内核的，所以 Linux 里的很多命令在 Android 里也有相同或类似的实现，在 <code>adb shell</code> 里可以调用。本文档前面的部分内容已经用到了 <code>adb shell</code> 命令。</p>
<h3 id="查看进程"><a href="#查看进程" class="headerlink" title="查看进程"></a>查看进程</h3><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb shell ps</div></pre></td></tr></table></figure>
<p>输出示例：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">USER     PID   PPID  VSIZE  RSS     WCHAN    PC        NAME</div><div class="line">root      1     0     8904   788   ffffffff 00000000 S /init</div><div class="line">root      2     0     0      0     ffffffff 00000000 S kthreadd</div><div class="line">...</div><div class="line">u0_a71    7779  5926  1538748 48896 ffffffff 00000000 S com.sohu.inputmethod.sogou:classic</div><div class="line">u0_a58    7963  5926  1561916 59568 ffffffff 00000000 S org.mazhuang.boottimemeasure</div><div class="line">...</div><div class="line">shell     8750  217   10640  740   00000000 b6f28340 R ps</div></pre></td></tr></table></figure>
<p>各列含义：</p>
<table>
<thead>
<tr>
<th>列名</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>USER</td>
<td>所属用户</td>
</tr>
<tr>
<td>PID</td>
<td>进程 ID</td>
</tr>
<tr>
<td>PPID</td>
<td>父进程 ID</td>
</tr>
<tr>
<td>NAME</td>
<td>进程名</td>
</tr>
</tbody>
</table>
<h3 id="查看实时资源占用情况"><a href="#查看实时资源占用情况" class="headerlink" title="查看实时资源占用情况"></a>查看实时资源占用情况</h3><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb shell top</div></pre></td></tr></table></figure>
<p>输出示例：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">User 0%, System 6%, IOW 0%, IRQ 0%</div><div class="line">User 3 + Nice 0 + Sys 21 + Idle 280 + IOW 0 + IRQ 0 + SIRQ 3 = 307</div><div class="line"></div><div class="line">  PID PR CPU% S  <span class="comment">#THR     VSS     RSS PCY UID      Name</span></div><div class="line"> 8763  0   3% R     1  10640K   1064K  <span class="built_in">fg</span> shell    top</div><div class="line">  131  0   3% S     1      0K      0K  <span class="built_in">fg</span> root     dhd_dpc</div><div class="line"> 6144  0   0% S   115 1682004K 115916K  <span class="built_in">fg</span> system   system_server</div><div class="line">  132  0   0% S     1      0K      0K  <span class="built_in">fg</span> root     dhd_rxf</div><div class="line"> 1731  0   0% S     6  20288K    788K  <span class="built_in">fg</span> root     /system/bin/mpdecision</div><div class="line">  217  0   0% S     6  18008K    356K  <span class="built_in">fg</span> shell    /sbin/adbd</div><div class="line"> ...</div><div class="line"> 7779  2   0% S    19 1538748K  48896K  <span class="built_in">bg</span> u0_a71   com.sohu.inputmethod.sogou:classic</div><div class="line"> 7963  0   0% S    18 1561916K  59568K  <span class="built_in">fg</span> u0_a58   org.mazhuang.boottimemeasure</div><div class="line"> ...</div></pre></td></tr></table></figure>
<p>各列含义：</p>
<table>
<thead>
<tr>
<th>列名</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>PID</td>
<td>进程 ID</td>
</tr>
<tr>
<td>PR</td>
<td>优先级</td>
</tr>
<tr>
<td>CPU%</td>
<td>当前瞬间占用 CPU 百分比</td>
</tr>
<tr>
<td>S</td>
<td>进程状态（R=运行，S=睡眠，T=跟踪/停止，Z=僵尸进程）</td>
</tr>
<tr>
<td>#THR</td>
<td>线程数</td>
</tr>
<tr>
<td>VSS</td>
<td>Virtual Set Size 虚拟耗用内存（包含共享库占用的内存）</td>
</tr>
<tr>
<td>RSS</td>
<td>Resident Set Size 实际使用物理内存（包含共享库占用的内存）</td>
</tr>
<tr>
<td>PCY</td>
<td>调度策略优先级，SP_BACKGROUND/SPFOREGROUND</td>
</tr>
<tr>
<td>UID</td>
<td>进程所有者的用户 ID</td>
</tr>
<tr>
<td>NAME</td>
<td>进程名</td>
</tr>
</tbody>
</table>
<p><code>top</code> 命令还支持一些命令行参数，详细用法如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Usage: top [ -m max_procs ] [ -n iterations ] [ -d delay ] [ -s sort_column ] [ -t ] [ -h ]</div><div class="line">    -m num  最多显示多少个进程</div><div class="line">    -n num  刷新多少次后退出</div><div class="line">    -d num  刷新时间间隔（单位秒，默认值 5）</div><div class="line">    -s col  按某列排序（可用 col 值：cpu, vss, rss, thr）</div><div class="line">    -t      显示线程信息</div><div class="line">    -h      显示帮助文档</div></pre></td></tr></table></figure>
<h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>如下是其它常用命令的简单描述，前文已经专门讲过的命令不再额外说明：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>cat</td>
<td>显示文件内容</td>
</tr>
<tr>
<td>cd</td>
<td>切换目录</td>
</tr>
<tr>
<td>chmod</td>
<td>改变文件的存取模式/访问权限</td>
</tr>
<tr>
<td>df</td>
<td>查看磁盘空间使用情况</td>
</tr>
<tr>
<td>grep</td>
<td>过滤输出</td>
</tr>
<tr>
<td>kill</td>
<td>杀死指定 PID 的进程</td>
</tr>
<tr>
<td>ls</td>
<td>列举目录内容</td>
</tr>
<tr>
<td>mount</td>
<td>挂载目录的查看和管理</td>
</tr>
<tr>
<td>mv</td>
<td>移动或重命名文件</td>
</tr>
<tr>
<td>ps</td>
<td>查看正在运行的进程</td>
</tr>
<tr>
<td>rm</td>
<td>删除文件</td>
</tr>
<tr>
<td>top</td>
<td>查看进程的资源占用情况</td>
</tr>
</tbody>
</table>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="启动-adb-server-失败"><a href="#启动-adb-server-失败" class="headerlink" title="启动 adb server 失败"></a>启动 adb server 失败</h3><p><strong>出错提示</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">error: protocol fault (couldn<span class="string">'t read status): No error</span></div></pre></td></tr></table></figure>
<p><strong>可能原因</strong></p>
<p>adb server 进程想使用的 5037 端口被占用。</p>
<p><strong>解决方案</strong></p>
<p>找到占用 5037 端口的进程，然后终止它。以 Windows 下为例：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">netstat -ano | findstr LISTENING</div><div class="line"></div><div class="line">...</div><div class="line">TCP    0.0.0.0:5037           0.0.0.0:0              LISTENING       1548</div><div class="line">...</div></pre></td></tr></table></figure>
<p>这里 1548 即为进程 ID，用命令结束该进程：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">taskkill /PID 1548</div></pre></td></tr></table></figure>
<p>然后再启动 adb 就没问题了。</p>
<h2 id="adb-的非官方实现"><a href="#adb-的非官方实现" class="headerlink" title="adb 的非官方实现"></a>adb 的非官方实现</h2><ul>
<li><a href="https://github.com/facebook/fb-adb" target="_blank" rel="external">fb-adb</a> - A better shell for Android devices (for Mac).</li>
</ul>
<h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><p>感谢朋友们无私的分享与补充（排名不分先后）。</p>
<p><a href="https://github.com/zxning" target="_blank" rel="external">zxning</a>，<a href="https://github.com/linhua55" target="_blank" rel="external">linhua55</a>，<a href="https://github.com/codeskyblue" target="_blank" rel="external">codeskyblue</a>，<a href="https://github.com/seasonyuu" target="_blank" rel="external">seasonyuu</a>，<a href="https://github.com/fan123199" target="_blank" rel="external">fan123199</a>，<a href="https://github.com/zhEdward" target="_blank" rel="external">zhEdward</a>，<a href="https://github.com/0x8BADFOOD" target="_blank" rel="external">0x8BADFOOD</a>，<a href="https://github.com/keith666666" target="_blank" rel="external">keith666666</a>。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://developer.android.com/studio/command-line/adb.html" target="_blank" rel="external">Android Debug Bridge</a></li>
<li><a href="https://developer.android.com/studio/command-line/shell.html" target="_blank" rel="external">ADB Shell Commands</a></li>
<li><a href="https://developer.android.com/studio/command-line/logcat.html" target="_blank" rel="external">logcat Command-line Tool</a></li>
<li><a href="http://zmywly8866.github.io/2015/01/24/all-adb-command.html" target="_blank" rel="external">Android ADB命令大全</a></li>
<li><a href="https://github.com/ZQiang94/StudyRecords/blob/master/other/src/main/java/com/other/adb%20%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95.md" target="_blank" rel="external">adb 命令行的使用记录</a></li>
<li><a href="http://www.jianshu.com/p/860bc2bf1a6a" target="_blank" rel="external">Android ADB命令大全(通过ADB命令查看wifi密码、MAC地址、设备信息、操作文件、查看文件、日志信息、卸载、启动和安装APK等)</a></li>
<li><a href="http://yifeiyuan.me/2016/06/30/ADB%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86/" target="_blank" rel="external">那些做Android开发必须知道的ADB命令</a></li>
<li><a href="http://blog.csdn.net/kittyboy0001/article/details/38562515" target="_blank" rel="external">adb shell top</a></li>
<li><a href="http://cabins.github.io/2016/03/25/UseAdbLikeAPro-2/" target="_blank" rel="external">像高手一样使用ADB命令行（2）</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> Android </tag>
            
            <tag> 命令 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[手把手教你构建 C 语言编译器（9）——总结]]></title>
      <url>/2017/03/12/write-a-C-interpreter-9/</url>
      <content type="html"><![CDATA[<p>恭喜你完成了自己的 C 语言编译器，本章中我们发一发牢骚，说一说编写编译器值得注意的一些问题；编写编译器时遇到的一些难题。</p>
<p>[注: 该系列转载自<a href="http://lotabout.me" target="_blank" rel="external">三点水</a>]</p>
<p>手把手教你构建 C 语言编译器系列共有10个部分：</p>
<ol>
<li><a href="http://thychan.cn/2017/03/12/write-a-C-interpreter-0/" target="_blank" rel="external">手把手教你构建 C 语言编译器（0）——前言</a></li>
<li><a href="http://thychan.cn/2017/03/12/write-a-C-interpreter-1/" target="_blank" rel="external">手把手教你构建 C 语言编译器（1）——设计</a></li>
<li><a href="http://thychan.cn/2017/03/12/write-a-C-interpreter-2/" target="_blank" rel="external">手把手教你构建 C 语言编译器（2）——虚拟机</a></li>
<li><a href="http://thychan.cn/2017/03/12/write-a-C-interpreter-3/" target="_blank" rel="external">手把手教你构建 C 语言编译器（3）——词法分析器</a></li>
<li><a href="http://thychan.cn/2017/03/12/write-a-C-interpreter-4/" target="_blank" rel="external">手把手教你构建 C 语言编译器（4）——递归下降</a></li>
<li><a href="http://thychan.cn/2017/03/12/write-a-C-interpreter-5/" target="_blank" rel="external">手把手教你构建 C 语言编译器（5）——变量定义</a></li>
<li><a href="http://thychan.cn/2017/03/12/write-a-C-interpreter-6/" target="_blank" rel="external">手把手教你构建 C 语言编译器（6）——函数定义</a></li>
<li><a href="http://thychan.cn/2017/03/12/write-a-C-interpreter-7/" target="_blank" rel="external">手把手教你构建 C 语言编译器（7）——语句</a></li>
<li><a href="http://thychan.cn/2017/03/12/write-a-C-interpreter-8/" target="_blank" rel="external">手把手教你构建 C 语言编译器（8）——表达式</a></li>
<li><a href="http://thychan.cn/2017/03/12/write-a-C-interpreter-9/" target="_blank" rel="external">手把手教你构建 C 语言编译器（9）——总结</a></li>
</ol>
<p># </p>
<p>整个系列的一开始，我们就着手虚拟机的实现。不知道你是否有同感，这部分对于整个编译器的编写其实是十分重要的。我认为至少占了重要程度的50%。</p>
<p>这里要说明这样一个观点，学习编译原理时常常着眼于词法分析和语法分析，而忽略了同样重要的代码生成。对于学习或考试而言或许可以，但实际编译项目时，最为重要的是能“跑起来”，所以我们需要给予代码生成高度的重视。</p>
<p>同时我们也看到，在后期解析语句和表达式时，难点已经不再是语法分析了，而是如何为运算符生成相应的汇编代码。</p>
<h1 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h1><p>我们用了很暴力的手段编写了我们的词法分析器，我认为这并无不可。</p>
<p>但你依旧可以学习相关的知识，了解自动生成词法分析器的原理，它涉及到了“正则表达式”，“状态机”等等知识。相信这部分的知识能够很大程度上提高你的编程水平。</p>
<p>同时，如果今后你仍然想编写编译器，不妨试试这些自动生成工具。</p>
<h1 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h1><p>长期以来，语法分析对我而言一直是迷一样的存在，直到真正用递归下降的方式实现了一个。</p>
<p>我们用了专门的一章讲解了“递归下降”与 BNF 文法的关系。希望能减少你对理论的厌恶。至少，实现起来并不是太难。</p>
<p>如果有兴趣，可以学习学习这些文法，因为已经有许多自动生成的工具支持它们。这样你就不需要重复造轮子。可以看看 yacc 等工具，更先进的版本是 <code>bsion</code>。同时其它语言也有许多类似的支持。</p>
<p>题外话，最近知道了一个叫“PEG 文法”的表示方法，无论是读起来，还是实现起来，都比 BNF 要容易，你也可以学习看看。</p>
<h1 id="关于编代码"><a href="#关于编代码" class="headerlink" title="关于编代码"></a>关于编代码</h1><p>这也是我自己的感慨吧。无论多好的教程，想要完全理解它，最好的方式恐怕还是要自己实现它。</p>
<p>只是在编写代码的过程中，我们会遇到许多的挫折，例如需要考虑许多细节，或是调试起来十分困难。但也只有真正静下心来去克服它，我们才能有所成长吧。</p>
<p>例如在编写表达式的解析时，大量重复的代码特别让人崩溃。还有就是调试编译器，简直痛苦地无话可说。</p>
<p>P.S. 如果你按这个系列自己编写代码，记得事先写一些用于输出汇编代码的函数，很有帮助的。</p>
<p>还有就是写这个系列的文章，开始的冲动过了之后，每写一篇都特别心烦，希望文章本身没有受我的这种情绪影响吧。</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>编程有趣又无趣，只有身在其中的我们才能体会吧。</p>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> 编译器 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[手把手教你构建 C 语言编译器（8）——表达式]]></title>
      <url>/2017/03/12/write-a-C-interpreter-8/</url>
      <content type="html"><![CDATA[<p>这是整个编译器的最后一部分，解析表达式。什么是表达式？表达式是将各种语言要素的一个组合，用来求值。例如：函数调用、变量赋值、运算符运算等等。</p>
<p>表达式的解析难点有二：一是运算符的优先级问题，二是如何将表达式编译成目标代码。我们就来逐一说明。</p>
<p>[注: 该系列转载自<a href="http://lotabout.me" target="_blank" rel="external">三点水</a>]</p>
<p>手把手教你构建 C 语言编译器系列共有10个部分：</p>
<ol>
<li><a href="http://thychan.cn/2017/03/12/write-a-C-interpreter-0/" target="_blank" rel="external">手把手教你构建 C 语言编译器（0）——前言</a></li>
<li><a href="http://thychan.cn/2017/03/12/write-a-C-interpreter-1/" target="_blank" rel="external">手把手教你构建 C 语言编译器（1）——设计</a></li>
<li><a href="http://thychan.cn/2017/03/12/write-a-C-interpreter-2/" target="_blank" rel="external">手把手教你构建 C 语言编译器（2）——虚拟机</a></li>
<li><a href="http://thychan.cn/2017/03/12/write-a-C-interpreter-3/" target="_blank" rel="external">手把手教你构建 C 语言编译器（3）——词法分析器</a></li>
<li><a href="http://thychan.cn/2017/03/12/write-a-C-interpreter-4/" target="_blank" rel="external">手把手教你构建 C 语言编译器（4）——递归下降</a></li>
<li><a href="http://thychan.cn/2017/03/12/write-a-C-interpreter-5/" target="_blank" rel="external">手把手教你构建 C 语言编译器（5）——变量定义</a></li>
<li><a href="http://thychan.cn/2017/03/12/write-a-C-interpreter-6/" target="_blank" rel="external">手把手教你构建 C 语言编译器（6）——函数定义</a></li>
<li><a href="http://thychan.cn/2017/03/12/write-a-C-interpreter-7/" target="_blank" rel="external">手把手教你构建 C 语言编译器（7）——语句</a></li>
<li><a href="http://thychan.cn/2017/03/12/write-a-C-interpreter-8/" target="_blank" rel="external">手把手教你构建 C 语言编译器（8）——表达式</a></li>
<li><a href="http://thychan.cn/2017/03/12/write-a-C-interpreter-9/" target="_blank" rel="external">手把手教你构建 C 语言编译器（9）——总结</a></li>
</ol>
<h1 id="运算符的优先级"><a href="#运算符的优先级" class="headerlink" title="运算符的优先级"></a>运算符的优先级</h1><p>运算符的优先级决定了表达式的运算顺序，如在普通的四则运算中，乘法 <code>*</code> 优先级高于加法 <code>+</code>，这就意味着表达式 <code>2 + 3 * 4</code> 的实际运行顺序是 <code>2 + (3 * 4)</code> 而不是 <code>(2 + 3) * 4</code>。</p>
<p>C 语言定义了各种表达式的优先级，可以参考 <a href="http://en.cppreference.com/w/c/language/operator_precedence" target="_blank" rel="external">C 语言运算符优先级</a>。</p>
<p>传统的编程书籍会用“逆波兰式”实现四则运算来讲解优先级问题。实际上，优先级关心的就是哪个运算符先计算，哪个运算符后计算（毕竟叫做“优先级”嘛）。而这就意味着我们需要决定先为哪个运算符生成目标代码（汇编），因为汇编代码是顺序排列的，我们必须先计算优先级高的运算符。</p>
<p>那么如何确定运算符的优先级呢？答曰：栈（递归调用的实质也是栈的处理）。</p>
<p>举一个例子：<code>2 + 3 - 4 * 5</code>，它的运算顺序是这样的：</p>
<ol>
<li>将 <code>2</code> 入栈</li>
<li>遇到运算符 <code>+</code>，入栈，此时我们期待的是<code>+</code>的另一个参数</li>
<li>遇到数字 <code>3</code>，原则上我们需要立即计算 <code>2+3</code>的值，但我们不确定数字 <code>3</code> 是否属于优先级更高的运算符，所以先将它入栈。</li>
<li>遇到运算符 <code>-</code>，它的优先级和 <code>+</code> 相同，此时判断参数 <code>3</code> 属于这前的 <code>+</code>。将运算符 <code>+</code> 出栈，并将之前的 <code>2</code> 和 <code>3</code> 出栈，计算 <code>2+3</code> 的结果，得到 <code>5</code> 入栈。同时将运算符 <code>-</code> 入栈。</li>
<li>遇到数字<code>4</code>，同样不能确定是否能立即计算，入栈</li>
<li>遇到运算符 <code>*</code> 优先级大于 <code>-</code>，入栈</li>
<li>遇到数字<code>5</code>，依旧不能确定是否立即计算，入栈</li>
<li>表达式结束，运算符出栈，为 <code>*</code>，将参数出栈，计算 <code>4*5</code> 得到结果 <code>20</code> 入栈。</li>
<li>运算符出栈，为 <code>-</code>，将参数出栈，计算 <code>5-20</code>，得到 <code>-15</code> 入栈。</li>
<li>此时运算符栈为空，因此得到结果 <code>-15</code>。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">// after step 1, 2</div><div class="line">|      |</div><div class="line">+------+</div><div class="line">| 3    |   |      |</div><div class="line">+------+   +------+</div><div class="line">| 2    |   | +    |</div><div class="line">+------+   +------+</div><div class="line"></div><div class="line">// after step 4</div><div class="line">|      |   |      |</div><div class="line">+------+   +------+</div><div class="line">| 5    |   | -    |</div><div class="line">+------+   +------+</div><div class="line"></div><div class="line">// after step 7</div><div class="line">|      |</div><div class="line">+------+</div><div class="line">| 5    |</div><div class="line">+------+   +------+</div><div class="line">| 4    |   | *    |</div><div class="line">+------+   +------+</div><div class="line">| 5    |   | -    |</div><div class="line">+------+   +------+</div></pre></td></tr></table></figure>
<p>综上，在计算一个运算符‘x’之前，必须先查看它的右方，找出并计算所有优先级大于‘x’的运算符，之后再计算运算符‘x’。</p>
<p>最后注意的是优先通常只与多元运算符相关，单元运算符往往没有这个问题（因为只有一个参数）。也可以认为“优先级”的实质就是两个运算符在抢参数。</p>
<h1 id="一元运算符"><a href="#一元运算符" class="headerlink" title="一元运算符"></a>一元运算符</h1><p>上节中说到了运算符的优先级，也提到了优先级一般只与多元运算符有关，这也意味着一元运算符的优先级总是高于多元运算符。因为我们需要先对它们进行解析。</p>
<p>当然，这部分也将同时解析参数本身（如变量、数字、字符串等等）。</p>
<p>关于表达式的解析，与语法分析相关的部分就是上文所说的优先级问题了，而剩下的较难较烦的部分是与目标代码的生成有关的。因此对于需要讲解的运算符，我们主要从它的目标代码入手。</p>
<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>首先是数字，用 <code>IMM</code> 指令将它加载到 <code>AX</code> 中即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">if (token == Num) &#123;</div><div class="line">    match(Num);</div><div class="line"></div><div class="line">    // emit code</div><div class="line">    *++text = IMM;</div><div class="line">    *++text = token_val;</div><div class="line">    expr_type = INT;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接着是字符串常量。它比较特殊的一点是 C 语言的字符串常量支持如下风格：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">char *p;</div><div class="line">p = &quot;first line&quot;</div><div class="line">    &quot;second line&quot;;</div></pre></td></tr></table></figure>
<p>即跨行的字符串拼接，它相当于：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">char *p;</div><div class="line">p = &quot;first linesecond line&quot;;</div></pre></td></tr></table></figure>
<p>所以解析的时候要注意这一点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">else if (token == &apos;&quot;&apos;) &#123;</div><div class="line">    // emit code</div><div class="line">    *++text = IMM;</div><div class="line">    *++text = token_val;</div><div class="line"></div><div class="line">    match(&apos;&quot;&apos;);</div><div class="line">    // store the rest strings</div><div class="line">    while (token == &apos;&quot;&apos;) &#123;</div><div class="line">        match(&apos;&quot;&apos;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // append the end of string character &apos;\0&apos;, all the data are default</div><div class="line">    // to 0, so just move data one position forward.</div><div class="line">    data = (char *)(((int)data + sizeof(int)) &amp; (-sizeof(int)));</div><div class="line">    expr_type = PTR;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="sizeof"><a href="#sizeof" class="headerlink" title="sizeof"></a>sizeof</h2><p><code>sizeof</code> 是一个一元运算符，我们需要知道后面参数的类型，类型的解析在前面的文章中我们已经很熟悉了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">else if (token == Sizeof) &#123;</div><div class="line">    // sizeof is actually an unary operator</div><div class="line">    // now only `sizeof(int)`, `sizeof(char)` and `sizeof(*...)` are</div><div class="line">    // supported.</div><div class="line">    match(Sizeof);</div><div class="line">    match(&apos;(&apos;);</div><div class="line">    expr_type = INT;</div><div class="line"></div><div class="line">    if (token == Int) &#123;</div><div class="line">        match(Int);</div><div class="line">    &#125; else if (token == Char) &#123;</div><div class="line">        match(Char);</div><div class="line">        expr_type = CHAR;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    while (token == Mul) &#123;</div><div class="line">        match(Mul);</div><div class="line">        expr_type = expr_type + PTR;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    match(&apos;)&apos;);</div><div class="line"></div><div class="line">    // emit code</div><div class="line">    *++text = IMM;</div><div class="line">    *++text = (expr_type == CHAR) ? sizeof(char) : sizeof(int);</div><div class="line"></div><div class="line">    expr_type = INT;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意的是只支持 <code>sizeof(int)</code>，<code>sizeof(char)</code> 及 <code>sizeof(pointer type...)</code>。并且它的结果是 <code>int</code>型。</p>
<h2 id="变量与函数调用"><a href="#变量与函数调用" class="headerlink" title="变量与函数调用"></a>变量与函数调用</h2><p>由于取变量的值与函数的调用都是以 <code>Id</code> 标记开头的，因此将它们放在一起处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div></pre></td><td class="code"><pre><div class="line">else if (token == Id) &#123;</div><div class="line">    // there are several type when occurs to Id</div><div class="line">    // but this is unit, so it can only be</div><div class="line">    // 1. function call</div><div class="line">    // 2. Enum variable</div><div class="line">    // 3. global/local variable</div><div class="line">    match(Id);</div><div class="line"></div><div class="line">    id = current_id;</div><div class="line"></div><div class="line">    if (token == &apos;(&apos;) &#123;</div><div class="line">        // function call</div><div class="line">        match(&apos;(&apos;);</div><div class="line"></div><div class="line">        // ①</div><div class="line">        // pass in arguments</div><div class="line">        tmp = 0; // number of arguments</div><div class="line">        while (token != &apos;)&apos;) &#123;</div><div class="line">            expression(Assign);</div><div class="line">            *++text = PUSH;</div><div class="line">            tmp ++;</div><div class="line"></div><div class="line">            if (token == &apos;,&apos;) &#123;</div><div class="line">                match(&apos;,&apos;);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        match(&apos;)&apos;);</div><div class="line"></div><div class="line">        // ②</div><div class="line">        // emit code</div><div class="line">        if (id[Class] == Sys) &#123;</div><div class="line">            // system functions</div><div class="line">            *++text = id[Value];</div><div class="line">        &#125;</div><div class="line">        else if (id[Class] == Fun) &#123;</div><div class="line">            // function call</div><div class="line">            *++text = CALL;</div><div class="line">            *++text = id[Value];</div><div class="line">        &#125;</div><div class="line">        else &#123;</div><div class="line">            printf(&quot;%d: bad function call\n&quot;, line);</div><div class="line">            exit(-1);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // ③</div><div class="line">        // clean the stack for arguments</div><div class="line">        if (tmp &gt; 0) &#123;</div><div class="line">            *++text = ADJ;</div><div class="line">            *++text = tmp;</div><div class="line">        &#125;</div><div class="line">        expr_type = id[Type];</div><div class="line">    &#125;</div><div class="line">    else if (id[Class] == Num) &#123;</div><div class="line">        // ④</div><div class="line">        // enum variable</div><div class="line">        *++text = IMM;</div><div class="line">        *++text = id[Value];</div><div class="line">        expr_type = INT;</div><div class="line">    &#125;</div><div class="line">    else &#123;</div><div class="line">        // ⑤</div><div class="line">        // variable</div><div class="line">        if (id[Class] == Loc) &#123;</div><div class="line">            *++text = LEA;</div><div class="line">            *++text = index_of_bp - id[Value];</div><div class="line">        &#125;</div><div class="line">        else if (id[Class] == Glo) &#123;</div><div class="line">            *++text = IMM;</div><div class="line">            *++text = id[Value];</div><div class="line">        &#125;</div><div class="line">        else &#123;</div><div class="line">            printf(&quot;%d: undefined variable\n&quot;, line);</div><div class="line">            exit(-1);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        //⑥</div><div class="line">        // emit code, default behaviour is to load the value of the</div><div class="line">        // address which is stored in `ax`</div><div class="line">        expr_type = id[Type];</div><div class="line">        *++text = (expr_type == Char) ? LC : LI;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>①中注意我们是顺序将参数入栈，这和第三章：虚拟机中讲解的指令是对应的。与之不同，标准 C 是逆序将参数入栈的。</p>
<p>②中判断函数的类型，同样在第三章：“虚拟机”中我们介绍过内置函数的支持，如 <code>printf</code>, <code>read</code>, <code>malloc</code> 等等。内置函数有对应的汇编指令，而普通的函数则编译成 <code>CALL &lt;addr&gt;</code> 的形式。</p>
<p>③用于清除入栈的参数。因为我们不在乎出栈的值，所以直接修改栈指针的大小即可。</p>
<p>④：当该标识符是全局定义的枚举类型时，直接将对应的值用 <code>IMM</code> 指令存入 <code>AX</code> 即可。</p>
<p>⑤则是用于加载变量的值，如果是局部变量则采用与 <code>bp</code> 指针相对位置的形式（参见第 7章函数定义）。而如果是全局变量则用 <code>IMM</code> 加载变量的地址。</p>
<p>⑥：无论是全局还是局部变量，最终都根据它们的类型用 <code>LC</code> 或 <code>LI</code> 指令加载对应的值。</p>
<p>关于变量，你可能有疑问，如果遇到标识符就用 <code>LC/LI</code> 载入相应的值，那诸如 <code>a[10]</code> 之类的表达式要如何实现呢？后面我们会看到，根据标识符后的运算符，我们可能会修改或删除现有的 <code>LC/LI</code> 指令。</p>
<h2 id="强制转换"><a href="#强制转换" class="headerlink" title="强制转换"></a>强制转换</h2><p>虽然我们前面没有提到，但我们一直用 <code>expr_type</code> 来保存一个表达式的类型，强制转换的作用是获取转换的类型，并直接修改 <code>expr_type</code> 的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">else if (token == &apos;(&apos;) &#123;</div><div class="line">    // cast or parenthesis</div><div class="line">    match(&apos;(&apos;);</div><div class="line">    if (token == Int || token == Char) &#123;</div><div class="line">        tmp = (token == Char) ? CHAR : INT; // cast type</div><div class="line">        match(token);</div><div class="line">        while (token == Mul) &#123;</div><div class="line">            match(Mul);</div><div class="line">            tmp = tmp + PTR;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        match(&apos;)&apos;);</div><div class="line"></div><div class="line">        expression(Inc); // cast has precedence as Inc(++)</div><div class="line"></div><div class="line">        expr_type  = tmp;</div><div class="line">    &#125; else &#123;</div><div class="line">        // normal parenthesis</div><div class="line">        expression(Assign);</div><div class="line">        match(&apos;)&apos;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="指针取值"><a href="#指针取值" class="headerlink" title="指针取值"></a>指针取值</h2><p>诸如 <code>*a</code> 的指针取值，关键是判断 <code>a</code> 的类型，而就像上节中提到的，当一个表达式解析结束时，它的类型保存在变量 <code>expr_type</code> 中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">else if (token == Mul) &#123;</div><div class="line">    // dereference *&lt;addr&gt;</div><div class="line">    match(Mul);</div><div class="line">    expression(Inc); // dereference has the same precedence as Inc(++)</div><div class="line"></div><div class="line">    if (expr_type &gt;= PTR) &#123;</div><div class="line">        expr_type = expr_type - PTR;</div><div class="line">    &#125; else &#123;</div><div class="line">        printf(&quot;%d: bad dereference\n&quot;, line);</div><div class="line">        exit(-1);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    *++text = (expr_type == CHAR) ? LC : LI;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="取址操作"><a href="#取址操作" class="headerlink" title="取址操作"></a>取址操作</h2><p>这里我们就能看到“变量与函数调用”一节中所说的修改或删除 <code>LC/LI</code> 指令了。前文中我们说到，对于变量，我们会先加载它的地址，并根据它们类型使用 <code>LC/LI</code> 指令加载实际内容，例如对变量 <code>a</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">IMM &lt;addr&gt;</div><div class="line">LI</div></pre></td></tr></table></figure>
<p>那么对变量 <code>a</code> 取址，其实只要不执行 <code>LC/LI</code> 即可。因此我们删除相应的指令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">else if (token == And) &#123;</div><div class="line">    // get the address of</div><div class="line">    match(And);</div><div class="line">    expression(Inc); // get the address of</div><div class="line">    if (*text == LC || *text == LI) &#123;</div><div class="line">        text --;</div><div class="line">    &#125; else &#123;</div><div class="line">        printf(&quot;%d: bad address of\n&quot;, line);</div><div class="line">        exit(-1);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    expr_type = expr_type + PTR;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="逻辑取反"><a href="#逻辑取反" class="headerlink" title="逻辑取反"></a>逻辑取反</h2><p>我们没有直接的逻辑取反指令，因此我们判断它是否与数字 0 相等。而数字 0 代表了逻辑 “False”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">else if (token == &apos;!&apos;) &#123;</div><div class="line">    // not</div><div class="line">    match(&apos;!&apos;);</div><div class="line">    expression(Inc);</div><div class="line"></div><div class="line">    // emit code, use &lt;expr&gt; == 0</div><div class="line">    *++text = PUSH;</div><div class="line">    *++text = IMM;</div><div class="line">    *++text = 0;</div><div class="line">    *++text = EQ;</div><div class="line"></div><div class="line">    expr_type = INT;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="按位取反"><a href="#按位取反" class="headerlink" title="按位取反"></a>按位取反</h2><p>同样我们没有相应的指令，所以我们用异或来实现，即 <code>~a = a ^ 0xFFFF</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">else if (token == &apos;~&apos;) &#123;</div><div class="line">    // bitwise not</div><div class="line">    match(&apos;~&apos;);</div><div class="line">    expression(Inc);</div><div class="line"></div><div class="line">    // emit code, use &lt;expr&gt; XOR -1</div><div class="line">    *++text = PUSH;</div><div class="line">    *++text = IMM;</div><div class="line">    *++text = -1;</div><div class="line">    *++text = XOR;</div><div class="line"></div><div class="line">    expr_type = INT;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="正负号"><a href="#正负号" class="headerlink" title="正负号"></a>正负号</h2><p>注意这里并不是四则运算中的加减法，而是单个数字的取正取负操作。同样，我们没有取负的操作，用 <code>0 - x</code> 来实现 <code>-x</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">else if (token == Add) &#123;</div><div class="line">    // +var, do nothing</div><div class="line">    match(Add);</div><div class="line">    expression(Inc);</div><div class="line"></div><div class="line">    expr_type = INT;</div><div class="line">&#125;</div><div class="line">else if (token == Sub) &#123;</div><div class="line">    // -var</div><div class="line">    match(Sub);</div><div class="line"></div><div class="line">    if (token == Num) &#123;</div><div class="line">        *++text = IMM;</div><div class="line">        *++text = -token_val;</div><div class="line">        match(Num);</div><div class="line">    &#125; else &#123;</div><div class="line"></div><div class="line">        *++text = IMM;</div><div class="line">        *++text = -1;</div><div class="line">        *++text = PUSH;</div><div class="line">        expression(Inc);</div><div class="line">        *++text = MUL;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    expr_type = INT;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="自增自减"><a href="#自增自减" class="headerlink" title="自增自减"></a>自增自减</h2><p>注意的是自增自减操作的优先级是和它的位置有关的。如 <code>++p</code> 的优先级高于 <code>p++</code>，这里我们解析的就是类似 <code>++p</code> 的操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">else if (token == Inc || token == Dec) &#123;</div><div class="line">    tmp = token;</div><div class="line">    match(token);</div><div class="line">    expression(Inc);</div><div class="line">    // ①</div><div class="line">    if (*text == LC) &#123;</div><div class="line">        *text = PUSH;  // to duplicate the address</div><div class="line">        *++text = LC;</div><div class="line">    &#125; else if (*text == LI) &#123;</div><div class="line">        *text = PUSH;</div><div class="line">        *++text = LI;</div><div class="line">    &#125; else &#123;</div><div class="line">        printf(&quot;%d: bad lvalue of pre-increment\n&quot;, line);</div><div class="line">        exit(-1);</div><div class="line">    &#125;</div><div class="line">    *++text = PUSH;</div><div class="line">    *++text = IMM;</div><div class="line">    // ②</div><div class="line">    *++text = (expr_type &gt; PTR) ? sizeof(int) : sizeof(char);</div><div class="line">    *++text = (tmp == Inc) ? ADD : SUB;</div><div class="line">    *++text = (expr_type == CHAR) ? SC : SI;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对应的汇编代码也比较直观，只是在实现 <code>++p</code>时，我们要使用变量 <code>p</code> 的地址两次，所以我们需要先 <code>PUSH</code> （①）。</p>
<p>②则是因为自增自减操作还需要处理是指针的情形。</p>
<h1 id="二元运算符"><a href="#二元运算符" class="headerlink" title="二元运算符"></a>二元运算符</h1><p>这里，我们需要处理多运算符的优先级问题，就如前文的“优先级”一节提到的，我们需要不断地向右扫描，直到遇到优先级 <strong>小于</strong> 当前优先级的运算符。</p>
<p>回想起我们之前定义过的各个标记，它们是以优先级从低到高排列的，即 <code>Assign</code> 的优先级最低，而 <code>Brak</code>（<code>[</code>） 的优先级最高。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">enum &#123;</div><div class="line">  Num = 128, Fun, Sys, Glo, Loc, Id,</div><div class="line">  Char, Else, Enum, If, Int, Return, Sizeof, While,</div><div class="line">  Assign, Cond, Lor, Lan, Or, Xor, And, Eq, Ne, Lt, Gt, Le, Ge, Shl, Shr, Add, Sub, Mul, Div, Mod, Inc, Dec, Brak</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>所以，当我们调用 <code>expression(level)</code> 进行解析的时候，我们其实通过了参数 <code>level</code> 指定了当前的优先级。在前文的一元运算符处理中也用到了这一点。</p>
<p>所以，此时的二元运算符的解析的框架为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">while (token &gt;= level) &#123;</div><div class="line">    // parse token for binary operator and postfix operator</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>解决了优先级的问题，让我们继续讲解如何把运算符编译成汇编代码吧。</p>
<h2 id="赋值操作"><a href="#赋值操作" class="headerlink" title="赋值操作"></a>赋值操作</h2><p>赋值操作是优先级最低的运算符。考虑诸如 <code>a = (expession)</code> 的表达式，在解析 <code>=</code> 之前，我们已经为变量 <code>a</code> 生成了如下的汇编代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">IMM &lt;addr&gt;</div><div class="line">LC/LI</div></pre></td></tr></table></figure>
<p>当解析完<code>=</code>右边的表达式后，相应的值会存放在 <code>ax</code> 中，此时，为了实际将这个值保存起来，我们需要类似下面的汇编代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">IMM &lt;addr&gt;</div><div class="line">PUSH</div><div class="line">SC/SI</div></pre></td></tr></table></figure>
<p>明白了这点，也就能理解下面的源代码了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">tmp = expr_type;</div><div class="line">if (token == Assign) &#123;</div><div class="line">    // var = expr;</div><div class="line">    match(Assign);</div><div class="line">    if (*text == LC || *text == LI) &#123;</div><div class="line">        *text = PUSH; // save the lvalue&apos;s pointer</div><div class="line">    &#125; else &#123;</div><div class="line">        printf(&quot;%d: bad lvalue in assignment\n&quot;, line);</div><div class="line">        exit(-1);</div><div class="line">    &#125;</div><div class="line">    expression(Assign);</div><div class="line"></div><div class="line">    expr_type = tmp;</div><div class="line">    *++text = (expr_type == CHAR) ? SC : SI;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h2><p>这是 C 语言中唯一的一个三元运算符： <code>? :</code>，它相当于一个小型的 If 语句，所以生成的代码也类似于 If 语句，这里就不多作解释。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">else if (token == Cond) &#123;</div><div class="line">    // expr ? a : b;</div><div class="line">    match(Cond);</div><div class="line">    *++text = JZ;</div><div class="line">    addr = ++text;</div><div class="line">    expression(Assign);</div><div class="line">    if (token == &apos;:&apos;) &#123;</div><div class="line">        match(&apos;:&apos;);</div><div class="line">    &#125; else &#123;</div><div class="line">        printf(&quot;%d: missing colon in conditional\n&quot;, line);</div><div class="line">        exit(-1);</div><div class="line">    &#125;</div><div class="line">    *addr = (int)(text + 3);</div><div class="line">    *++text = JMP;</div><div class="line">    addr = ++text;</div><div class="line">    expression(Cond);</div><div class="line">    *addr = (int)(text + 1);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p>这包括 <code>||</code> 和 <code>&amp;&amp;</code>。它们对应的汇编代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;expr1&gt; || &lt;expr2&gt;     &lt;expr1&gt; &amp;&amp; &lt;expr2&gt;</div><div class="line"></div><div class="line">  ...&lt;expr1&gt;...          ...&lt;expr1&gt;...</div><div class="line">  JNZ b                  JZ b</div><div class="line">  ...&lt;expr2&gt;...          ...&lt;expr2&gt;...</div><div class="line">b:                     b:</div></pre></td></tr></table></figure>
<p>所以源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">else if (token == Lor) &#123;</div><div class="line">    // logic or</div><div class="line">    match(Lor);</div><div class="line">    *++text = JNZ;</div><div class="line">    addr = ++text;</div><div class="line">    expression(Lan);</div><div class="line">    *addr = (int)(text + 1);</div><div class="line">    expr_type = INT;</div><div class="line">&#125;</div><div class="line">else if (token == Lan) &#123;</div><div class="line">    // logic and</div><div class="line">    match(Lan);</div><div class="line">    *++text = JZ;</div><div class="line">    addr = ++text;</div><div class="line">    expression(Or);</div><div class="line">    *addr = (int)(text + 1);</div><div class="line">    expr_type = INT;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="数学运算符"><a href="#数学运算符" class="headerlink" title="数学运算符"></a>数学运算符</h2><p>它们包括 <code>|</code>, <code>^</code>, <code>&amp;</code>, <code>==</code>, <code>!=</code> <code>&lt;=</code>, <code>&gt;=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;</code>, <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>。它们的实现都很类似，我们以异或 <code>^</code> 为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;expr1&gt; ^ &lt;expr2&gt;</div><div class="line"></div><div class="line">...&lt;expr1&gt;...          &lt;- now the result is on ax</div><div class="line">PUSH</div><div class="line">...&lt;expr2&gt;...          &lt;- now the value of &lt;expr2&gt; is on ax</div><div class="line">XOR</div></pre></td></tr></table></figure>
<p>所以它对应的代码为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">else if (token == Xor) &#123;</div><div class="line">    // bitwise xor</div><div class="line">    match(Xor);</div><div class="line">    *++text = PUSH;</div><div class="line">    expression(And);</div><div class="line">    *++text = XOR;</div><div class="line">    expr_type = INT;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其它的我们便不再详述。但这当中还有一个问题，就是指针的加减。在 C 语言中，指针加上数值等于将指针移位，且根据不同的类型移动的位移不同。如 <code>a + 1</code>，如果 <code>a</code> 是 <code>char *</code> 型，则移动一字节，而如果 <code>a</code> 是 <code>int *</code> 型，则移动 4 个字节（32位系统）。</p>
<p>另外，在作指针减法时，如果是两个指针相减（相同类型），则结果是两个指针间隔的元素个数。因此要有特殊的处理。</p>
<p>下面以加法为例，对应的汇编代码为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;expr1&gt; + &lt;expr2&gt;</div><div class="line"></div><div class="line">normal         pointer</div><div class="line"></div><div class="line">&lt;expr1&gt;        &lt;expr1&gt;</div><div class="line">PUSH           PUSH</div><div class="line">&lt;expr2&gt;        &lt;expr2&gt;     |</div><div class="line">ADD            PUSH        | &lt;expr2&gt; * &lt;unit&gt;</div><div class="line">               IMM &lt;unit&gt;  |</div><div class="line">               MUL         |</div><div class="line">               ADD</div></pre></td></tr></table></figure>
<p>即当 <code>&lt;expr1&gt;</code> 是指针时，要根据它的类型放大 <code>&lt;expr2&gt;</code> 的值，因此对应的源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">else if (token == Add) &#123;</div><div class="line">    // add</div><div class="line">    match(Add);</div><div class="line">    *++text = PUSH;</div><div class="line">    expression(Mul);</div><div class="line"></div><div class="line">    expr_type = tmp;</div><div class="line">    if (expr_type &gt; PTR) &#123;</div><div class="line">        // pointer type, and not `char *`</div><div class="line">        *++text = PUSH;</div><div class="line">        *++text = IMM;</div><div class="line">        *++text = sizeof(int);</div><div class="line">        *++text = MUL;</div><div class="line">    &#125;</div><div class="line">    *++text = ADD;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>相应的减法的代码就不贴了，可以自己实现看看，也可以看文末给出的链接。</p>
<h2 id="自增自减-1"><a href="#自增自减-1" class="headerlink" title="自增自减"></a>自增自减</h2><p>这次是后缀形式的，即 <code>p++</code> 或 <code>p--</code>。与前缀形式不同的是，在执行自增自减后， <code>ax</code>上需要保留原来的值。所以我们首先执行类似前缀自增自减的操作，再将 <code>ax</code> 中的值执行减/增的操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">// 前缀形式 生成汇编代码</div><div class="line">*++text = PUSH;</div><div class="line">*++text = IMM;</div><div class="line">*++text = (expr_type &gt; PTR) ? sizeof(int) : sizeof(char);</div><div class="line">*++text = (tmp == Inc) ? ADD : SUB;</div><div class="line">*++text = (expr_type == CHAR) ? SC : SI;</div><div class="line"></div><div class="line">// 后缀形式 生成汇编代码</div><div class="line">*++text = PUSH;</div><div class="line">*++text = IMM;</div><div class="line">*++text = (expr_type &gt; PTR) ? sizeof(int) : sizeof(char);</div><div class="line">*++text = (token == Inc) ? ADD : SUB;</div><div class="line">*++text = (expr_type == CHAR) ? SC : SI;</div><div class="line">*++text = PUSH;                                             //</div><div class="line">*++text = IMM;                                              // 执行相反的增/减操作</div><div class="line">*++text = (expr_type &gt; PTR) ? sizeof(int) : sizeof(char);   //</div><div class="line">*++text = (token == Inc) ? SUB : ADD;                       //</div></pre></td></tr></table></figure>
<h2 id="数组取值操作"><a href="#数组取值操作" class="headerlink" title="数组取值操作"></a>数组取值操作</h2><p>在学习 C 语言的时候你可能已经知道了，诸如 <code>a[10]</code> 的操作等价于 <code>*(a + 10)</code>。因此我们要做的就是生成类似的汇编代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">else if (token == Brak) &#123;</div><div class="line">    // array access var[xx]</div><div class="line">    match(Brak);</div><div class="line">    *++text = PUSH;</div><div class="line">    expression(Assign);</div><div class="line">    match(&apos;]&apos;);</div><div class="line"></div><div class="line">    if (tmp &gt; PTR) &#123;</div><div class="line">        // pointer, `not char *`</div><div class="line">        *++text = PUSH;</div><div class="line">        *++text = IMM;</div><div class="line">        *++text = sizeof(int);</div><div class="line">        *++text = MUL;</div><div class="line">    &#125;</div><div class="line">    else if (tmp &lt; PTR) &#123;</div><div class="line">        printf(&quot;%d: pointer type expected\n&quot;, line);</div><div class="line">        exit(-1);</div><div class="line">    &#125;</div><div class="line">    expr_type = tmp - PTR;</div><div class="line">    *++text = ADD;</div><div class="line">    *++text = (expr_type == CHAR) ? LC : LI;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>除了上述对表达式的解析外，我们还需要初始化虚拟机的栈，我们可以正确调用 <code>main</code> 函数，且当 <code>main</code>函数结束时退出进程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">int *tmp;</div><div class="line">// setup stack</div><div class="line">sp = (int *)((int)stack + poolsize);</div><div class="line">*--sp = EXIT; // call exit if main returns</div><div class="line">*--sp = PUSH; tmp = sp;</div><div class="line">*--sp = argc;</div><div class="line">*--sp = (int)argv;</div><div class="line">*--sp = (int)tmp;</div></pre></td></tr></table></figure>
<p>当然，最后要注意的一点是：所有的变量定义必须放在语句之前。</p>
<p>本章的代码可以在 <a href="https://github.com/lotabout/write-a-C-interpreter/tree/step-6" target="_blank" rel="external">Github</a> 上下载，也可以直接 clone</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git clone -b step-6 https://github.com/lotabout/write-a-C-interpreter</div></pre></td></tr></table></figure>
<p>通过 <code>gcc -o xc-tutor xc-tutor.c</code> 进行编译。并执行 <code>./xc-tutor hello.c</code> 查看结果。</p>
<p>正如我们保证的那样，我们的代码是自举的，能自己编译自己，所以你可以执行 <code>./xc-tutor xc-tutor.c hello.c</code>。可以看到和之前有同样的输出。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本章我们进行了最后的解析，解析表达式。本章有两个难点：</p>
<ol>
<li>如何通过递归调用 <code>expression</code> 来实现运算符的优先级。</li>
<li>如何为每个运算符生成对应的汇编代码。</li>
</ol>
<p>尽管代码看起来比较简单（虽然多），但其中用到的原理还是需要仔细推敲的。</p>
<p>最后，恭喜你！通过一步步的学习，自己实现了一个C语言的编译器（好吧，是解释器）。</p>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> 编译器 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[手把手教你构建 C 语言编译器（7）——语句]]></title>
      <url>/2017/03/12/write-a-C-interpreter-7/</url>
      <content type="html"><![CDATA[<p>整个编译器还剩下最后两个部分：语句和表达式的解析。它们的内容比较多，主要涉及如何将语句和表达式编译成汇编代码。这章讲解语句的解析，相对于表达式来说它还是较为容易的。</p>
<p>[注: 该系列转载自<a href="http://lotabout.me" target="_blank" rel="external">三点水</a>]</p>
<p>手把手教你构建 C 语言编译器系列共有10个部分：</p>
<ol>
<li><a href="http://thychan.cn/2017/03/12/write-a-C-interpreter-0/" target="_blank" rel="external">手把手教你构建 C 语言编译器（0）——前言</a></li>
<li><a href="http://thychan.cn/2017/03/12/write-a-C-interpreter-1/" target="_blank" rel="external">手把手教你构建 C 语言编译器（1）——设计</a></li>
<li><a href="http://thychan.cn/2017/03/12/write-a-C-interpreter-2/" target="_blank" rel="external">手把手教你构建 C 语言编译器（2）——虚拟机</a></li>
<li><a href="http://thychan.cn/2017/03/12/write-a-C-interpreter-3/" target="_blank" rel="external">手把手教你构建 C 语言编译器（3）——词法分析器</a></li>
<li><a href="http://thychan.cn/2017/03/12/write-a-C-interpreter-4/" target="_blank" rel="external">手把手教你构建 C 语言编译器（4）——递归下降</a></li>
<li><a href="http://thychan.cn/2017/03/12/write-a-C-interpreter-5/" target="_blank" rel="external">手把手教你构建 C 语言编译器（5）——变量定义</a></li>
<li><a href="http://thychan.cn/2017/03/12/write-a-C-interpreter-6/" target="_blank" rel="external">手把手教你构建 C 语言编译器（6）——函数定义</a></li>
<li><a href="http://thychan.cn/2017/03/12/write-a-C-interpreter-7/" target="_blank" rel="external">手把手教你构建 C 语言编译器（7）——语句</a></li>
<li><a href="http://thychan.cn/2017/03/12/write-a-C-interpreter-8/" target="_blank" rel="external">手把手教你构建 C 语言编译器（8）——表达式</a></li>
<li><a href="http://thychan.cn/2017/03/12/write-a-C-interpreter-9/" target="_blank" rel="external">手把手教你构建 C 语言编译器（9）——总结</a></li>
</ol>
<h1 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h1><p>C 语言区分“语句”（statement）和“表达式”（expression）两个概念。简单地说，可以认为语句就是表达式加上末尾的分号。</p>
<p>在我们的编译器中共识别 6 种语句：</p>
<ol>
<li><code>if (...) &lt;statement&gt; [else &lt;statement&gt;]</code></li>
<li><code>while (...) &lt;statement&gt;</code></li>
<li><code>{ &lt;statement&gt; }</code></li>
<li><code>return xxx;</code></li>
<li><code>&lt;empty statement&gt;</code>;</li>
<li><code>expression;</code> (expression end with semicolon)</li>
</ol>
<p>它们的语法分析都相对容易，重要的是去理解如何将这些语句编译成汇编代码，下面我们逐一解释。</p>
<h2 id="IF-语句"><a href="#IF-语句" class="headerlink" title="IF 语句"></a>IF 语句</h2><p>IF 语句的作用是跳转，跟据条件表达式决定跳转的位置。我们看看下面的伪代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">if (...) &lt;statement&gt; [else &lt;statement&gt;]</div><div class="line"></div><div class="line">  if (&lt;cond&gt;)                   &lt;cond&gt;</div><div class="line">                                JZ a</div><div class="line">    &lt;true_statement&gt;   ===&gt;     &lt;true_statement&gt;</div><div class="line">  else:                         JMP b</div><div class="line">a:                           a:</div><div class="line">    &lt;false_statement&gt;           &lt;false_statement&gt;</div><div class="line">b:                           b:</div></pre></td></tr></table></figure>
<p>对应的汇编代码流程为：</p>
<ol>
<li>执行条件表达式 <code>&lt;cond&gt;</code>。</li>
<li>如果条件失败，则跳转到 <code>a</code> 的位置，执行 <code>else</code> 语句。这里 <code>else</code> 语句是可以省略的，此时 <code>a</code> 和 <code>b</code> 都指向 IF 语句后方的代码。</li>
<li>因为汇编代码是顺序排列的，所以如果执行了 <code>true_statement</code>，为了防止因为顺序排列而执行了 <code>false_statement</code>，所以需要无条件跳转 <code>JMP b</code>。</li>
</ol>
<p>对应的 C 代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">if (token == If) &#123;</div><div class="line">    match(If);</div><div class="line">    match(&apos;(&apos;);</div><div class="line">    expression(Assign);  // parse condition</div><div class="line">    match(&apos;)&apos;);</div><div class="line"></div><div class="line">    *++text = JZ;</div><div class="line">    b = ++text;</div><div class="line"></div><div class="line">    statement();         // parse statement</div><div class="line">    if (token == Else) &#123; // parse else</div><div class="line">        match(Else);</div><div class="line"></div><div class="line">        // emit code for JMP B</div><div class="line">        *b = (int)(text + 3);</div><div class="line">        *++text = JMP;</div><div class="line">        b = ++text;</div><div class="line"></div><div class="line">        statement();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    *b = (int)(text + 1);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="While-语句"><a href="#While-语句" class="headerlink" title="While 语句"></a>While 语句</h2><p>While 语句比 If 语句简单，它对应的汇编代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">a:                     a:</div><div class="line">   while (&lt;cond&gt;)        &lt;cond&gt;</div><div class="line">                         JZ b</div><div class="line">    &lt;statement&gt;          &lt;statement&gt;</div><div class="line">                         JMP a</div><div class="line">b:                     b:</div></pre></td></tr></table></figure>
<p>没有什么值得说明的内容，它的 C 代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">else if (token == While) &#123;</div><div class="line">    match(While);</div><div class="line"></div><div class="line">    a = text + 1;</div><div class="line"></div><div class="line">    match(&apos;(&apos;);</div><div class="line">    expression(Assign);</div><div class="line">    match(&apos;)&apos;);</div><div class="line"></div><div class="line">    *++text = JZ;</div><div class="line">    b = ++text;</div><div class="line"></div><div class="line">    statement();</div><div class="line"></div><div class="line">    *++text = JMP;</div><div class="line">    *++text = (int)a;</div><div class="line">    *b = (int)(text + 1);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Return-语句"><a href="#Return-语句" class="headerlink" title="Return 语句"></a>Return 语句</h2><p>Return 唯一特殊的地方是：一旦遇到了 Return 语句，则意味着函数要退出了，所以需要生成汇编代码 <code>LEV</code> 来表示退出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">else if (token == Return) &#123;</div><div class="line">    // return [expression];</div><div class="line">    match(Return);</div><div class="line"></div><div class="line">    if (token != &apos;;&apos;) &#123;</div><div class="line">        expression(Assign);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    match(&apos;;&apos;);</div><div class="line"></div><div class="line">    // emit code for return</div><div class="line">    *++text = LEV;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="其它语句"><a href="#其它语句" class="headerlink" title="其它语句"></a>其它语句</h2><p>其它语句并不直接生成汇编代码，所以不多做说明，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">else if (token == &apos;&#123;&apos;) &#123;</div><div class="line">    // &#123; &lt;statement&gt; ... &#125;</div><div class="line">    match(&apos;&#123;&apos;);</div><div class="line"></div><div class="line">    while (token != &apos;&#125;&apos;) &#123;</div><div class="line">        statement();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    match(&apos;&#125;&apos;);</div><div class="line">&#125;</div><div class="line">else if (token == &apos;;&apos;) &#123;</div><div class="line">    // empty statement</div><div class="line">    match(&apos;;&apos;);</div><div class="line">&#125;</div><div class="line">else &#123;</div><div class="line">    // a = b; or function_call();</div><div class="line">    expression(Assign);</div><div class="line">    match(&apos;;&apos;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>本章的代码可以在 <a href="https://github.com/lotabout/write-a-C-interpreter/tree/step-5" target="_blank" rel="external">Github</a> 上下载，也可以直接 clone</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git clone -b step-5 https://github.com/lotabout/write-a-C-interpreter</div></pre></td></tr></table></figure>
<p>本章的代码依旧无法运行，还剩最后一部分没有完成：<code>expression</code>。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本章讲解了如何将语句编译成汇编代码，内容相对容易一些，关键就是去理解汇编代码的执行原理。</p>
<p>同时值得一提的是，编译器的语法分析部分其实是很简单的，而真正的难点是如何在语法分析时收集足够多的信息，最终把源代码转换成目标代码（汇编）。我认为这也是初学者实现编译器的一大难点，往往比词法分析/语法分析更困难。</p>
<p>所以建议如果没有学过汇编，可以学习学习，它本身不难，但对理解计算机的原理有很大帮助。</p>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> 编译器 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[手把手教你构建 C 语言编译器（6）——函数定义]]></title>
      <url>/2017/03/12/write-a-C-interpreter-6/</url>
      <content type="html"><![CDATA[<p>由于语法分析本身比较复杂，所以我们将它拆分成 3 个部分进行讲解，分别是：变量定义、函数定义、表达式。本章讲解函数定义相关的内容。</p>
<p>[注: 该系列转载自<a href="http://lotabout.me" target="_blank" rel="external">三点水</a>]</p>
<p>手把手教你构建 C 语言编译器系列共有10个部分：</p>
<ol>
<li><a href="http://thychan.cn/2017/03/12/write-a-C-interpreter-0/" target="_blank" rel="external">手把手教你构建 C 语言编译器（0）——前言</a></li>
<li><a href="http://thychan.cn/2017/03/12/write-a-C-interpreter-1/" target="_blank" rel="external">手把手教你构建 C 语言编译器（1）——设计</a></li>
<li><a href="http://thychan.cn/2017/03/12/write-a-C-interpreter-2/" target="_blank" rel="external">手把手教你构建 C 语言编译器（2）——虚拟机</a></li>
<li><a href="http://thychan.cn/2017/03/12/write-a-C-interpreter-3/" target="_blank" rel="external">手把手教你构建 C 语言编译器（3）——词法分析器</a></li>
<li><a href="http://thychan.cn/2017/03/12/write-a-C-interpreter-4/" target="_blank" rel="external">手把手教你构建 C 语言编译器（4）——递归下降</a></li>
<li><a href="http://thychan.cn/2017/03/12/write-a-C-interpreter-5/" target="_blank" rel="external">手把手教你构建 C 语言编译器（5）——变量定义</a></li>
<li><a href="http://thychan.cn/2017/03/12/write-a-C-interpreter-6/" target="_blank" rel="external">手把手教你构建 C 语言编译器（6）——函数定义</a></li>
<li><a href="http://thychan.cn/2017/03/12/write-a-C-interpreter-7/" target="_blank" rel="external">手把手教你构建 C 语言编译器（7）——语句</a></li>
<li><a href="http://thychan.cn/2017/03/12/write-a-C-interpreter-8/" target="_blank" rel="external">手把手教你构建 C 语言编译器（8）——表达式</a></li>
<li><a href="http://thychan.cn/2017/03/12/write-a-C-interpreter-9/" target="_blank" rel="external">手把手教你构建 C 语言编译器（9）——总结</a></li>
</ol>
<h1 id="EBNF-表示"><a href="#EBNF-表示" class="headerlink" title="EBNF 表示"></a>EBNF 表示</h1><p>这是上一章的 EBNF 方法中与函数定义相关的内容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">variable_decl ::= type &#123;&apos;*&apos;&#125; id &#123; &apos;,&apos; &#123;&apos;*&apos;&#125; id &#125; &apos;;&apos;</div><div class="line"></div><div class="line">function_decl ::= type &#123;&apos;*&apos;&#125; id &apos;(&apos; parameter_decl &apos;)&apos; &apos;&#123;&apos; body_decl &apos;&#125;&apos;</div><div class="line"></div><div class="line">parameter_decl ::= type &#123;&apos;*&apos;&#125; id &#123;&apos;,&apos; type &#123;&apos;*&apos;&#125; id&#125;</div><div class="line"></div><div class="line">body_decl ::= &#123;variable_decl&#125;, &#123;statement&#125;</div><div class="line"></div><div class="line">statement ::= non_empty_statement | empty_statement</div><div class="line"></div><div class="line">non_empty_statement ::= if_statement | while_statement | &apos;&#123;&apos; statement &apos;&#125;&apos;</div><div class="line">                     | &apos;return&apos; expression | expression &apos;;&apos;</div><div class="line"></div><div class="line">if_statement ::= &apos;if&apos; &apos;(&apos; expression &apos;)&apos; statement [&apos;else&apos; non_empty_statement]</div><div class="line"></div><div class="line">while_statement ::= &apos;while&apos; &apos;(&apos; expression &apos;)&apos; non_empty_statement</div></pre></td></tr></table></figure>
<h1 id="解析函数的定义"><a href="#解析函数的定义" class="headerlink" title="解析函数的定义"></a>解析函数的定义</h1><p>上一章的代码中，我们已经知道了什么时候开始解析函数的定义，相关的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">if (token == &apos;(&apos;) &#123;</div><div class="line">    current_id[Class] = Fun;</div><div class="line">    current_id[Value] = (int)(text + 1); // the memory address of function</div><div class="line">    function_declaration();</div><div class="line">&#125; else &#123;</div><div class="line">...</div></pre></td></tr></table></figure>
<p>即在这断代码之前，我们已经为当前的标识符（identifier）设置了正确的类型，上面这断代码为当前的标识符设置了正确的类别（Fun），以及该函数在代码段（text segment）中的位置。接下来开始解析函数定义相关的内容：<code>parameter_decl</code> 及 <code>body_decl</code>。</p>
<h2 id="函数参数与汇编代码"><a href="#函数参数与汇编代码" class="headerlink" title="函数参数与汇编代码"></a>函数参数与汇编代码</h2><p>现在我们要回忆如何将“函数”转换成对应的汇编代码，因为这决定了在解析时我们需要哪些相关的信息。考虑下列函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">int demo(int param_a, int *param_b) &#123;</div><div class="line">    int local_1;</div><div class="line">    char local_2;</div><div class="line"></div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>那么它应该被转换成什么样的汇编代码呢？在思考这个问题之前，我们需要了解当 <code>demo</code>函数被调用时，计算机的栈的状态，如下（参照第三章讲解的虚拟机）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">|    ....       | high address</div><div class="line">+---------------+</div><div class="line">| arg: param_a  |    new_bp + 3</div><div class="line">+---------------+</div><div class="line">| arg: param_b  |    new_bp + 2</div><div class="line">+---------------+</div><div class="line">|return address |    new_bp + 1</div><div class="line">+---------------+</div><div class="line">| old BP        | &lt;- new BP</div><div class="line">+---------------+</div><div class="line">| local_1       |    new_bp - 1</div><div class="line">+---------------+</div><div class="line">| local_2       |    new_bp - 2</div><div class="line">+---------------+</div><div class="line">|    ....       |  low address</div></pre></td></tr></table></figure>
<p>这里最为重要的一点是，无论是函数的参数（如 <code>param_a</code>）还是函数的局部变量（如 <code>local_1</code>）都是存放在计算机的 <strong>栈</strong> 上的。因此，与存放在 <strong>数据段</strong> 中的全局变量不同，在函数内访问它们是通过 <code>new_bp</code> 指针和对应的位移量进行的。因此，在解析的过程中，我们需要知道参数的个数，各个参数的位移量。</p>
<h2 id="函数定义的解析"><a href="#函数定义的解析" class="headerlink" title="函数定义的解析"></a>函数定义的解析</h2><p>这相当于是整个函数定义的语法解析的框架，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">void function_declaration() &#123;</div><div class="line">    // type func_name (...) &#123;...&#125;</div><div class="line">    //               | this part</div><div class="line"></div><div class="line">    match(&apos;(&apos;);</div><div class="line">    function_parameter();</div><div class="line">    match(&apos;)&apos;);</div><div class="line">    match(&apos;&#123;&apos;);</div><div class="line">    function_body();</div><div class="line">    //match(&apos;&#125;&apos;);                 //  ①</div><div class="line"></div><div class="line">    // ②</div><div class="line">    // unwind local variable declarations for all local variables.</div><div class="line">    current_id = symbols;</div><div class="line">    while (current_id[Token]) &#123;</div><div class="line">        if (current_id[Class] == Loc) &#123;</div><div class="line">            current_id[Class] = current_id[BClass];</div><div class="line">            current_id[Type]  = current_id[BType];</div><div class="line">            current_id[Value] = current_id[BValue];</div><div class="line">        &#125;</div><div class="line">        current_id = current_id + IdSize;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中①中我们没有消耗最后的<code>}</code>字符。这么做的原因是：<code>variable_decl</code> 与 <code>function_decl</code> 是放在一起解析的，而 <code>variable_decl</code> 是以字符 <code>;</code> 结束的。而 <code>function_decl</code> 是以字符 <code>}</code> 结束的，若在此通过 <code>match</code> 消耗了 ‘;’ 字符，那么外层的 <code>while</code> 循环就没法准确地知道函数定义已经结束。所以我们将结束符的解析放在了外层的 <code>while</code> 循环中。</p>
<p>而②中的代码是用于将符号表中的信息恢复成全局的信息。这是因为，局部变量是可以和全局变量同名的，一旦同名，在函数体内局部变量就会覆盖全局变量，出了函数体，全局变量就恢复了原先的作用。这段代码线性地遍历所有标识符，并将保存在 <code>BXXX</code> 中的信息还原。</p>
<h2 id="解析参数"><a href="#解析参数" class="headerlink" title="解析参数"></a>解析参数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">parameter_decl ::= type &#123;&apos;*&apos;&#125; id &#123;&apos;,&apos; type &#123;&apos;*&apos;&#125; id&#125;</div></pre></td></tr></table></figure>
<p>解析函数的参数就是解析以逗号分隔的一个个标识符，同时记录它们的位置与类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">int index_of_bp; // index of bp pointer on stack</div><div class="line"></div><div class="line">void function_parameter() &#123;</div><div class="line">    int type;</div><div class="line">    int params;</div><div class="line">    params = 0;</div><div class="line">    while (token != &apos;)&apos;) &#123;</div><div class="line">        // ①</div><div class="line"></div><div class="line">        // int name, ...</div><div class="line">        type = INT;</div><div class="line">        if (token == Int) &#123;</div><div class="line">            match(Int);</div><div class="line">        &#125; else if (token == Char) &#123;</div><div class="line">            type = CHAR;</div><div class="line">            match(Char);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // pointer type</div><div class="line">        while (token == Mul) &#123;</div><div class="line">            match(Mul);</div><div class="line">            type = type + PTR;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // parameter name</div><div class="line">        if (token != Id) &#123;</div><div class="line">            printf(&quot;%d: bad parameter declaration\n&quot;, line);</div><div class="line">            exit(-1);</div><div class="line">        &#125;</div><div class="line">        if (current_id[Class] == Loc) &#123;</div><div class="line">            printf(&quot;%d: duplicate parameter declaration\n&quot;, line);</div><div class="line">            exit(-1);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        match(Id);</div><div class="line"></div><div class="line">        //②</div><div class="line">        // store the local variable</div><div class="line">        current_id[BClass] = current_id[Class]; current_id[Class]  = Loc;</div><div class="line">        current_id[BType]  = current_id[Type];  current_id[Type]   = type;</div><div class="line">        current_id[BValue] = current_id[Value]; current_id[Value]  = params++;   // index of current parameter</div><div class="line"></div><div class="line">        if (token == &apos;,&apos;) &#123;</div><div class="line">            match(&apos;,&apos;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // ③</div><div class="line">    index_of_bp = params+1;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中①与全局变量定义的解析十分一样，用于解析该参数的类型。</p>
<p>而②则与上节中提到的“局部变量覆盖全局变量”相关，先将全局变量的信息保存（无论是是否真的在全局中用到了这个变量）在 <code>BXXX</code> 中，再赋上局部变量相关的信息，如 <code>Value</code> 中存放的是参数的位置（是第几个参数）。</p>
<p>③则与汇编代码的生成有关，<code>index_of_bp</code> 就是前文提到的 <code>new_bp</code> 的位置。</p>
<h2 id="函数体的解析"><a href="#函数体的解析" class="headerlink" title="函数体的解析"></a>函数体的解析</h2><p>我们实现的 C 语言与现代的 C 语言不太一致，我们需要所有的变量定义出现在所有的语句之前。函数体的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line">void function_body() &#123;</div><div class="line">    // type func_name (...) &#123;...&#125;</div><div class="line">    //                   --&gt;|   |&lt;--</div><div class="line"></div><div class="line">    // ... &#123;</div><div class="line">    // 1. local declarations</div><div class="line">    // 2. statements</div><div class="line">    // &#125;</div><div class="line"></div><div class="line">    int pos_local; // position of local variables on the stack.</div><div class="line">    int type;</div><div class="line">    pos_local = index_of_bp;</div><div class="line"></div><div class="line">    // ①</div><div class="line">    while (token == Int || token == Char) &#123;</div><div class="line">        // local variable declaration, just like global ones.</div><div class="line">        basetype = (token == Int) ? INT : CHAR;</div><div class="line">        match(token);</div><div class="line"></div><div class="line">        while (token != &apos;;&apos;) &#123;</div><div class="line">            type = basetype;</div><div class="line">            while (token == Mul) &#123;</div><div class="line">                match(Mul);</div><div class="line">                type = type + PTR;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            if (token != Id) &#123;</div><div class="line">                // invalid declaration</div><div class="line">                printf(&quot;%d: bad local declaration\n&quot;, line);</div><div class="line">                exit(-1);</div><div class="line">            &#125;</div><div class="line">            if (current_id[Class] == Loc) &#123;</div><div class="line">                // identifier exists</div><div class="line">                printf(&quot;%d: duplicate local declaration\n&quot;, line);</div><div class="line">                exit(-1);</div><div class="line">            &#125;</div><div class="line">            match(Id);</div><div class="line"></div><div class="line">            // store the local variable</div><div class="line">            current_id[BClass] = current_id[Class]; current_id[Class]  = Loc;</div><div class="line">            current_id[BType]  = current_id[Type];  current_id[Type]   = type;</div><div class="line">            current_id[BValue] = current_id[Value]; current_id[Value]  = ++pos_local;   // index of current parameter</div><div class="line"></div><div class="line">            if (token == &apos;,&apos;) &#123;</div><div class="line">                match(&apos;,&apos;);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        match(&apos;;&apos;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // ②</div><div class="line">    // save the stack size for local variables</div><div class="line">    *++text = ENT;</div><div class="line">    *++text = pos_local - index_of_bp;</div><div class="line"></div><div class="line">    // statements</div><div class="line">    while (token != &apos;&#125;&apos;) &#123;</div><div class="line">        statement();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // emit code for leaving the sub function</div><div class="line">    *++text = LEV;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中①用于解析函数体内的局部变量的定义，代码与全局的变量定义几乎一样。</p>
<p>而②则用于生成汇编代码，我们在第三章的虚拟机中提到过，我们需要在栈上为局部变量预留空间，这两行代码起的就是这个作用。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>本章的代码可以在 <a href="https://github.com/lotabout/write-a-C-interpreter/tree/step-4" target="_blank" rel="external">Github</a> 上下载，也可以直接 clone</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git clone -b step-4 https://github.com/lotabout/write-a-C-interpreter</div></pre></td></tr></table></figure>
<p>本章的代码依旧无法运行，还有两个重要函数没有完成：<code>statement</code> 及 <code>expression</code>，感兴趣的话可以尝试自己实现它们。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本章中我们用了不多的代码完成了函数定义的解析。大部分的代码依旧是用于解析变量：参数和局部变量，而它们的逻辑和全局变量的解析几乎一致，最大的区别就是保存的信息不同。</p>
<p>当然，要理解函数定义的解析过程，最重要的是理解我们会为函数生成怎样的汇编代码，因为这决定了我们需要从解析中获取什么样的信息（例如参数的位置，个数等），而这些可能需要你重新回顾一下“虚拟机”这一章，或是重新学习学习汇编相关的知识。</p>
<p>下一章中我们将讲解语句的解析，敬请期待。</p>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> 编译器 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[手把手教你构建 C 语言编译器（5）——变量定义]]></title>
      <url>/2017/03/12/write-a-C-interpreter-5/</url>
      <content type="html"><![CDATA[<p>本章中我们用 EBNF 来大致描述我们实现的 C 语言的文法，并实现其中解析变量定义部分。</p>
<p>由于语法分析本身比较复杂，所以我们将它拆分成 3 个部分进行讲解，分别是：变量定义、函数定义、表达式。</p>
<p>[注: 该系列转载自<a href="http://lotabout.me" target="_blank" rel="external">三点水</a>]</p>
<p>手把手教你构建 C 语言编译器系列共有10个部分：</p>
<ol>
<li><a href="http://thychan.cn/2017/03/12/write-a-C-interpreter-0/" target="_blank" rel="external">手把手教你构建 C 语言编译器（0）——前言</a></li>
<li><a href="http://thychan.cn/2017/03/12/write-a-C-interpreter-1/" target="_blank" rel="external">手把手教你构建 C 语言编译器（1）——设计</a></li>
<li><a href="http://thychan.cn/2017/03/12/write-a-C-interpreter-2/" target="_blank" rel="external">手把手教你构建 C 语言编译器（2）——虚拟机</a></li>
<li><a href="http://thychan.cn/2017/03/12/write-a-C-interpreter-3/" target="_blank" rel="external">手把手教你构建 C 语言编译器（3）——词法分析器</a></li>
<li><a href="http://thychan.cn/2017/03/12/write-a-C-interpreter-4/" target="_blank" rel="external">手把手教你构建 C 语言编译器（4）——递归下降</a></li>
<li><a href="http://thychan.cn/2017/03/12/write-a-C-interpreter-5/" target="_blank" rel="external">手把手教你构建 C 语言编译器（5）——变量定义</a></li>
<li><a href="http://thychan.cn/2017/03/12/write-a-C-interpreter-6/" target="_blank" rel="external">手把手教你构建 C 语言编译器（6）——函数定义</a></li>
<li><a href="http://thychan.cn/2017/03/12/write-a-C-interpreter-7/" target="_blank" rel="external">手把手教你构建 C 语言编译器（7）——语句</a></li>
<li><a href="http://thychan.cn/2017/03/12/write-a-C-interpreter-8/" target="_blank" rel="external">手把手教你构建 C 语言编译器（8）——表达式</a></li>
<li><a href="http://thychan.cn/2017/03/12/write-a-C-interpreter-9/" target="_blank" rel="external">手把手教你构建 C 语言编译器（9）——总结</a></li>
</ol>
<h1 id="EBNF-表示"><a href="#EBNF-表示" class="headerlink" title="EBNF 表示"></a>EBNF 表示</h1><p>EBNF 是对前一章提到的 BNF 的扩展，它的语法更容易理解，实现起来也更直观。但真正看起来还是很烦，如果不想看可以跳过。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">program ::= &#123;global_declaration&#125;+</div><div class="line"></div><div class="line">global_declaration ::= enum_decl | variable_decl | function_decl</div><div class="line"></div><div class="line">enum_decl ::= &apos;enum&apos; [id] &apos;&#123;&apos; id [&apos;=&apos; &apos;num&apos;] &#123;&apos;,&apos; id [&apos;=&apos; &apos;num&apos;] &apos;&#125;&apos;</div><div class="line"></div><div class="line">variable_decl ::= type &#123;&apos;*&apos;&#125; id &#123; &apos;,&apos; &#123;&apos;*&apos;&#125; id &#125; &apos;;&apos;</div><div class="line"></div><div class="line">function_decl ::= type &#123;&apos;*&apos;&#125; id &apos;(&apos; parameter_decl &apos;)&apos; &apos;&#123;&apos; body_decl &apos;&#125;&apos;</div><div class="line"></div><div class="line">parameter_decl ::= type &#123;&apos;*&apos;&#125; id &#123;&apos;,&apos; type &#123;&apos;*&apos;&#125; id&#125;</div><div class="line"></div><div class="line">body_decl ::= &#123;variable_decl&#125;, &#123;statement&#125;</div><div class="line"></div><div class="line">statement ::= non_empty_statement | empty_statement</div><div class="line"></div><div class="line">non_empty_statement ::= if_statement | while_statement | &apos;&#123;&apos; statement &apos;&#125;&apos;</div><div class="line">                     | &apos;return&apos; expression | expression &apos;;&apos;</div><div class="line"></div><div class="line">if_statement ::= &apos;if&apos; &apos;(&apos; expression &apos;)&apos; statement [&apos;else&apos; non_empty_statement]</div><div class="line"></div><div class="line">while_statement ::= &apos;while&apos; &apos;(&apos; expression &apos;)&apos; non_empty_statement</div></pre></td></tr></table></figure>
<p>其中 <code>expression</code> 相关的内容我们放到后面解释，主要原因是我们的语言不支持跨函数递归，而为了实现自举，实际上我们也不能使用递归（亏我们说了一章的递归下降）。</p>
<p>P.S. 我是先写程序再总结上面的文法，所以实际上它们间的对应关系并不是特别明显。</p>
<h1 id="解析变量的定义"><a href="#解析变量的定义" class="headerlink" title="解析变量的定义"></a>解析变量的定义</h1><p>本章要讲解的就是上节文法中的 <code>enum_decl</code> 和 <code>variable_decl</code> 部分。</p>
<h2 id="program"><a href="#program" class="headerlink" title="program()"></a>program()</h2><p>首先是之前定义过的 <code>program</code> 函数，将它改成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">void program() &#123;</div><div class="line">    // get next token</div><div class="line">    next();</div><div class="line">    while (token &gt; 0) &#123;</div><div class="line">        global_declaration();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我知道 <code>global_declaration</code> 函数还没有出现过，但没有关系，采用自顶向下的编写方法就是要不断地实现我们需要的内容。下面是 <code>global_declaration</code> 函数的内容：</p>
<h2 id="global-declaration"><a href="#global-declaration" class="headerlink" title="global_declaration()"></a>global_declaration()</h2><p>即全局的定义语句，包括变量定义，类型定义（只支持枚举）及函数定义。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div></pre></td><td class="code"><pre><div class="line">int basetype;    // the type of a declaration, make it global for convenience</div><div class="line">int expr_type;   // the type of an expression</div><div class="line"></div><div class="line">void global_declaration() &#123;</div><div class="line">    // global_declaration ::= enum_decl | variable_decl | function_decl</div><div class="line">    //</div><div class="line">    // enum_decl ::= &apos;enum&apos; [id] &apos;&#123;&apos; id [&apos;=&apos; &apos;num&apos;] &#123;&apos;,&apos; id [&apos;=&apos; &apos;num&apos;&#125; &apos;&#125;&apos;</div><div class="line">    //</div><div class="line">    // variable_decl ::= type &#123;&apos;*&apos;&#125; id &#123; &apos;,&apos; &#123;&apos;*&apos;&#125; id &#125; &apos;;&apos;</div><div class="line">    //</div><div class="line">    // function_decl ::= type &#123;&apos;*&apos;&#125; id &apos;(&apos; parameter_decl &apos;)&apos; &apos;&#123;&apos; body_decl &apos;&#125;&apos;</div><div class="line"></div><div class="line"></div><div class="line">    int type; // tmp, actual type for variable</div><div class="line">    int i; // tmp</div><div class="line"></div><div class="line">    basetype = INT;</div><div class="line"></div><div class="line">    // parse enum, this should be treated alone.</div><div class="line">    if (token == Enum) &#123;</div><div class="line">        // enum [id] &#123; a = 10, b = 20, ... &#125;</div><div class="line">        match(Enum);</div><div class="line">        if (token != &apos;&#123;&apos;) &#123;</div><div class="line">            match(Id); // skip the [id] part</div><div class="line">        &#125;</div><div class="line">        if (token == &apos;&#123;&apos;) &#123;</div><div class="line">            // parse the assign part</div><div class="line">            match(&apos;&#123;&apos;);</div><div class="line">            enum_declaration();</div><div class="line">            match(&apos;&#125;&apos;);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        match(&apos;;&apos;);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // parse type information</div><div class="line">    if (token == Int) &#123;</div><div class="line">        match(Int);</div><div class="line">    &#125;</div><div class="line">    else if (token == Char) &#123;</div><div class="line">        match(Char);</div><div class="line">        basetype = CHAR;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // parse the comma seperated variable declaration.</div><div class="line">    while (token != &apos;;&apos; &amp;&amp; token != &apos;&#125;&apos;) &#123;</div><div class="line">        type = basetype;</div><div class="line">        // parse pointer type, note that there may exist `int ****x;`</div><div class="line">        while (token == Mul) &#123;</div><div class="line">            match(Mul);</div><div class="line">            type = type + PTR;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (token != Id) &#123;</div><div class="line">            // invalid declaration</div><div class="line">            printf(&quot;%d: bad global declaration\n&quot;, line);</div><div class="line">            exit(-1);</div><div class="line">        &#125;</div><div class="line">        if (current_id[Class]) &#123;</div><div class="line">            // identifier exists</div><div class="line">            printf(&quot;%d: duplicate global declaration\n&quot;, line);</div><div class="line">            exit(-1);</div><div class="line">        &#125;</div><div class="line">        match(Id);</div><div class="line">        current_id[Type] = type;</div><div class="line"></div><div class="line">        if (token == &apos;(&apos;) &#123;</div><div class="line">            current_id[Class] = Fun;</div><div class="line">            current_id[Value] = (int)(text + 1); // the memory address of function</div><div class="line">            function_declaration();</div><div class="line">        &#125; else &#123;</div><div class="line">            // variable declaration</div><div class="line">            current_id[Class] = Glo; // global variable</div><div class="line">            current_id[Value] = (int)data; // assign memory address</div><div class="line">            data = data + sizeof(int);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (token == &apos;,&apos;) &#123;</div><div class="line">            match(&apos;,&apos;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    next();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看了上面的代码，能大概理解吗？这里我们讲解其中的一些细节。</p>
<p><strong>向前看标记</strong> ：其中的 <code>if (token == xxx)</code> 语句就是用来向前查看标记以确定使用哪一个产生式，例如只要遇到 <code>enum</code> 我们就知道是需要解析枚举类型。而如果只解析到类型，如 <code>int identifier</code> 时我们并不能确定 <code>identifier</code> 是一个普通的变量还是一个函数，所以还需要继续查看后续的标记，如果遇到 <code>(</code> 则可以断定是函数了，反之则是变量。</p>
<p><strong>变量类型的表示</strong> ：我们的编译器支持指针类型，那意味着也支持指针的指针，如 <code>int **data;</code>。那么我们如何表示指针类型呢？前文中我们定义了支持的类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// types of variable/function</div><div class="line">enum &#123; CHAR, INT, PTR &#125;;</div></pre></td></tr></table></figure>
<p>所以一个类型首先有基本类型，如 <code>CHAR</code> 或 <code>INT</code>，当它是一个指向基本类型的指针时，如 <code>int *data</code>，我们就将它的类型加上 <code>PTR</code> 即代码中的：<code>type = type + PTR;</code>。同理，如果是指针的指针，则再加上 <code>PTR</code>。</p>
<h2 id="enum-declaration"><a href="#enum-declaration" class="headerlink" title="enum_declaration()"></a>enum_declaration()</h2><p>用于解析枚举类型的定义。主要的逻辑用于解析用逗号（<code>,</code>）分隔的变量，值得注意的是在编译器中如何保存枚举变量的信息。</p>
<p>即我们将该变量的类别设置成了 <code>Num</code>，这样它就成了全局的常量了，而注意到上节中，正常的全局变量的类别则是 <code>Glo</code>，类别信息在后面章节中解析 <code>expression</code> 会使用到。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">void enum_declaration() &#123;</div><div class="line">    // parse enum [id] &#123; a = 1, b = 3, ...&#125;</div><div class="line">    int i;</div><div class="line">    i = 0;</div><div class="line">    while (token != &apos;&#125;&apos;) &#123;</div><div class="line">        if (token != Id) &#123;</div><div class="line">            printf(&quot;%d: bad enum identifier %d\n&quot;, line, token);</div><div class="line">            exit(-1);</div><div class="line">        &#125;</div><div class="line">        next();</div><div class="line">        if (token == Assign) &#123;</div><div class="line">            // like &#123;a=10&#125;</div><div class="line">            next();</div><div class="line">            if (token != Num) &#123;</div><div class="line">                printf(&quot;%d: bad enum initializer\n&quot;, line);</div><div class="line">                exit(-1);</div><div class="line">            &#125;</div><div class="line">            i = token_val;</div><div class="line">            next();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        current_id[Class] = Num;</div><div class="line">        current_id[Type] = INT;</div><div class="line">        current_id[Value] = i++;</div><div class="line"></div><div class="line">        if (token == &apos;,&apos;) &#123;</div><div class="line">            next();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>其中的 <code>function_declaration</code> 函数我们将放到下一章中讲解。<code>match</code> 函数是一个辅助函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">void match(int tk) &#123;</div><div class="line">    if (token == tk) &#123;</div><div class="line">        next();</div><div class="line">    &#125; else &#123;</div><div class="line">        printf(&quot;%d: expected token: %d\n&quot;, line, tk);</div><div class="line">        exit(-1);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>它将 <code>next</code> 函数包装起来，如果不是预期的标记则报错并退出。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>本章的代码可以在 <a href="https://github.com/lotabout/write-a-C-interpreter/tree/step-3" target="_blank" rel="external">Github</a> 上下载，也可以直接 clone</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git clone -b step-3 https://github.com/lotabout/write-a-C-interpreter</div></pre></td></tr></table></figure>
<p>本章的代码还无法正常运行，因为还有许多功能没有实现，但如果有兴趣的话，可以自己先试着去实现它。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本章的内容应该不难，除了开头的 EBNF 表达式可能相对不好理解一些，但如果你查看了 EBNF 的具体表示方法后就不难理解了。</p>
<p>剩下的内容就是按部就班地将 EBNF 的产生式转换成函数的过程，如果你理解了上一章中的内容，相信这部分也不难理解。</p>
<p>下一章中我们将介绍如何解析函数的定义，敬请期待。</p>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> 编译器 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[手把手教你构建 C 语言编译器（4）——递归下降]]></title>
      <url>/2017/03/12/write-a-C-interpreter-4/</url>
      <content type="html"><![CDATA[<p>本章我们将讲解递归下降的方法，并用它完成一个基本的四则运算的语法分析器。</p>
<p>[注: 该系列转载自<a href="http://lotabout.me" target="_blank" rel="external">三点水</a>]</p>
<p>手把手教你构建 C 语言编译器系列共有10个部分：</p>
<ol>
<li><a href="http://thychan.cn/2017/03/12/write-a-C-interpreter-0/" target="_blank" rel="external">手把手教你构建 C 语言编译器（0）——前言</a></li>
<li><a href="http://thychan.cn/2017/03/12/write-a-C-interpreter-1/" target="_blank" rel="external">手把手教你构建 C 语言编译器（1）——设计</a></li>
<li><a href="http://thychan.cn/2017/03/12/write-a-C-interpreter-2/" target="_blank" rel="external">手把手教你构建 C 语言编译器（2）——虚拟机</a></li>
<li><a href="http://thychan.cn/2017/03/12/write-a-C-interpreter-3/" target="_blank" rel="external">手把手教你构建 C 语言编译器（3）——词法分析器</a></li>
<li><a href="http://thychan.cn/2017/03/12/write-a-C-interpreter-4/" target="_blank" rel="external">手把手教你构建 C 语言编译器（4）——递归下降</a></li>
<li><a href="http://thychan.cn/2017/03/12/write-a-C-interpreter-5/" target="_blank" rel="external">手把手教你构建 C 语言编译器（5）——变量定义</a></li>
<li><a href="http://thychan.cn/2017/03/12/write-a-C-interpreter-6/" target="_blank" rel="external">手把手教你构建 C 语言编译器（6）——函数定义</a></li>
<li><a href="http://thychan.cn/2017/03/12/write-a-C-interpreter-7/" target="_blank" rel="external">手把手教你构建 C 语言编译器（7）——语句</a></li>
<li><a href="http://thychan.cn/2017/03/12/write-a-C-interpreter-8/" target="_blank" rel="external">手把手教你构建 C 语言编译器（8）——表达式</a></li>
<li><a href="http://thychan.cn/2017/03/12/write-a-C-interpreter-9/" target="_blank" rel="external">手把手教你构建 C 语言编译器（9）——总结</a></li>
</ol>
<h1 id="什么是递归下降"><a href="#什么是递归下降" class="headerlink" title="什么是递归下降"></a>什么是递归下降</h1><p>传统上，编写语法分析器有两种方法，一种是自顶向下，一种是自底向上。自顶向下是从起始非终结符开始，不断地对非终结符进行分解，直到匹配输入的终结符；自底向上是不断地将终结符进行合并，直到合并成起始的非终结符。</p>
<p>其中的自顶向下方法就是我们所说的递归下降。</p>
<h1 id="终结符与非终结符"><a href="#终结符与非终结符" class="headerlink" title="终结符与非终结符"></a>终结符与非终结符</h1><p>没有学过编译原理的话可能并不知道什么是“终结符”，“非终结符”。这里我简单介绍一下。首先是 <a href="https://zh.wikipedia.org/wiki/%E5%B7%B4%E7%A7%91%E6%96%AF%E8%8C%83%E5%BC%8F" target="_blank" rel="external">BNF</a> 范式，就是一种用来描述语法的语言，例如，四则运算的规则可以表示如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;expr&gt; ::= &lt;expr&gt; + &lt;term&gt;</div><div class="line">         | &lt;expr&gt; - &lt;term&gt;</div><div class="line">         | &lt;term&gt;</div><div class="line"></div><div class="line">&lt;term&gt; ::= &lt;term&gt; * &lt;factor&gt;</div><div class="line">         | &lt;term&gt; / &lt;factor&gt;</div><div class="line">         | &lt;factor&gt;</div><div class="line"></div><div class="line">&lt;factor&gt; ::= ( &lt;expr&gt; )</div><div class="line">           | Num</div></pre></td></tr></table></figure>
<p>用尖括号 <code>&lt;&gt;</code> 括起来的就称作 <strong>非终结符</strong> ，因为它们可以用 <code>::=</code> 右侧的式子代替。<code>|</code> 表示选择，如 <code>&lt;expr&gt;</code> 可以是 <code>&lt;expr&gt; + &lt;term&gt;</code>、<code>&lt;expr&gt; - &lt;term&gt;</code>或 <code>&lt;term&gt;</code> 中的一种。而没有出现在<code>::=</code>左边的就称作 <strong>终结符</strong> ，一般终结符对应于词法分析器输出的标记。</p>
<h1 id="四则运算的递归下降"><a href="#四则运算的递归下降" class="headerlink" title="四则运算的递归下降"></a>四则运算的递归下降</h1><p>例如，我们对 <code>3 * (4 + 2)</code> 进行语法分析。我们假设词法分析器已经正确地将其中的数字识别成了标记 <code>Num</code>。</p>
<p>递归下降是从起始的非终结符开始（顶），本例中是 <code>&lt;expr&gt;</code>，实际中可以自己指定，不指定的话一般认为是第一个出现的非终结符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">1. &lt;expr&gt; =&gt; &lt;expr&gt;</div><div class="line">2.           =&gt; &lt;term&gt;        * &lt;factor&gt;</div><div class="line">3.              =&gt; &lt;factor&gt;     |</div><div class="line">4.                 =&gt; Num (3)   |</div><div class="line">5.                              =&gt; ( &lt;expr&gt; )</div><div class="line">6.                                   =&gt; &lt;expr&gt;           + &lt;term&gt;</div><div class="line">7.                                      =&gt; &lt;term&gt;          |</div><div class="line">8.                                         =&gt; &lt;factor&gt;     |</div><div class="line">9.                                            =&gt; Num (4)   |</div><div class="line">10.                                                        =&gt; &lt;factor&gt;</div><div class="line">11.                                                           =&gt; Num (2)</div></pre></td></tr></table></figure>
<p>可以看到，整个解析的过程是在不断对非终结符进行替换（向下），直到遇见了终结符（底）。而我们可以从解析的过程中看出，一些非终结符如<code>&lt;expr&gt;</code>被递归地使用了。</p>
<h1 id="为什么选择递归下降"><a href="#为什么选择递归下降" class="headerlink" title="为什么选择递归下降"></a>为什么选择递归下降</h1><p>从上小节对四则运算的递归下降解析可以看出，整个解析的过程和语法的 BNF 表示是十分接近的，更为重要的是，我们可以很容易地直接将 BNF 表示转换成实际的代码。方法是为每个产生式（即 <code>非终结符 ::= ...</code>）生成一个同名的函数。</p>
<p>这里会有一个疑问，就是上例中，当一个终结符有多个选择时，如何确定具体选择哪一个？如为什么用 <code>&lt;expr&gt; ::= &lt;term&gt; * &lt;factor&gt;</code> 而不是 <code>&lt;expr&gt; ::= &lt;term&gt; / &lt;factor&gt;</code> ？这就用到了上一章中提到的“向前看 k 个标记”的概念了。我们向前看一个标记，发现是 <code>*</code>，而这个标记足够让我们确定用哪个表达式了。</p>
<p>另外，递归下下降方法对 BNF 方法本身有一定的要求，否则会有一些问题，如经典的“左递归”问题。</p>
<h1 id="左递归"><a href="#左递归" class="headerlink" title="左递归"></a>左递归</h1><p>原则上我们是不讲这么深入，但我们上面的四则运算的文法就是左递归的，而左递归的语法是没法直接使用递归下降的方法实现的。因此我们要消除左递归，消除后的文法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;expr&gt; ::= &lt;term&gt; &lt;expr_tail&gt;</div><div class="line">&lt;expr_tail&gt; ::= + &lt;term&gt; &lt;expr_tail&gt;</div><div class="line">              | - &lt;term&gt; &lt;expr_tail&gt;</div><div class="line">              | &lt;empty&gt;</div><div class="line"></div><div class="line">&lt;term&gt; ::= &lt;factor&gt; &lt;term_tail&gt;</div><div class="line">&lt;term_tail&gt; ::= * &lt;factor&gt; &lt;term_tail&gt;</div><div class="line">              | / &lt;factor&gt; &lt;term_tail&gt;</div><div class="line">              | &lt;empty&gt;</div><div class="line"></div><div class="line">&lt;factor&gt; ::= ( &lt;expr&gt; )</div><div class="line">           | Num</div></pre></td></tr></table></figure>
<p>消除左递归的相关方法，这里不再多说，请自行查阅相关的资料。</p>
<h1 id="四则运算的实现"><a href="#四则运算的实现" class="headerlink" title="四则运算的实现"></a>四则运算的实现</h1><p>本节中我们专注语法分析器部分的实现，具体实现很容易，我们直接贴上代码，就是上述的消除左递归后的文法直接转换而来的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">int expr();</div><div class="line"></div><div class="line">int factor() &#123;</div><div class="line">    int value = 0;</div><div class="line">    if (token == &apos;(&apos;) &#123;</div><div class="line">        match(&apos;(&apos;);</div><div class="line">        value = expr();</div><div class="line">        match(&apos;)&apos;);</div><div class="line">    &#125; else &#123;</div><div class="line">        value = token_val;</div><div class="line">        match(Num);</div><div class="line">    &#125;</div><div class="line">    return value;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int term_tail(int lvalue) &#123;</div><div class="line">    if (token == &apos;*&apos;) &#123;</div><div class="line">        match(&apos;*&apos;);</div><div class="line">        int value = lvalue * factor();</div><div class="line">        return term_tail(value);</div><div class="line">    &#125; else if (token == &apos;/&apos;) &#123;</div><div class="line">        match(&apos;/&apos;);</div><div class="line">        int value = lvalue / factor();</div><div class="line">        return term_tail(value);</div><div class="line">    &#125; else &#123;</div><div class="line">        return lvalue;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int term() &#123;</div><div class="line">    int lvalue = factor();</div><div class="line">    return term_tail(lvalue);</div><div class="line">&#125;</div><div class="line"></div><div class="line">int expr_tail(int lvalue) &#123;</div><div class="line">    if (token == &apos;+&apos;) &#123;</div><div class="line">        match(&apos;+&apos;);</div><div class="line">        int value = lvalue + term();</div><div class="line">        return expr_tail(value);</div><div class="line">    &#125; else if (token == &apos;-&apos;) &#123;</div><div class="line">        match(&apos;-&apos;);</div><div class="line">        int value = lvalue - term();</div><div class="line">        return expr_tail(value);</div><div class="line">    &#125; else &#123;</div><div class="line">        return lvalue;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int expr() &#123;</div><div class="line">    int lvalue = term();</div><div class="line">    return expr_tail(lvalue);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，有了BNF方法后，采用递归向下的方法来实现编译器是很直观的。</p>
<p>我们把词法分析器的代码一并贴上：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;stdlib.h&gt;</div><div class="line"></div><div class="line">enum &#123;Num&#125;;</div><div class="line">int token;</div><div class="line">int token_val;</div><div class="line">char *line = NULL;</div><div class="line">char *src = NULL;</div><div class="line"></div><div class="line">void next() &#123;</div><div class="line">    // skip white space</div><div class="line">    while (*src == &apos; &apos; || *src == &apos;\t&apos;) &#123;</div><div class="line">        src ++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    token = *src++;</div><div class="line"></div><div class="line">    if (token &gt;= &apos;0&apos; &amp;&amp; token &lt;= &apos;9&apos; ) &#123;</div><div class="line">        token_val = token - &apos;0&apos;;</div><div class="line">        token = Num;</div><div class="line"></div><div class="line">        while (*src &gt;= &apos;0&apos; &amp;&amp; *src &lt;= &apos;9&apos;) &#123;</div><div class="line">            token_val = token_val*10 + *src - &apos;0&apos;;</div><div class="line">            src ++;</div><div class="line">        &#125;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void match(int tk) &#123;</div><div class="line">    if (token != tk) &#123;</div><div class="line">        printf(&quot;expected token: %d(%c), got: %d(%c)\n&quot;, tk, tk, token, token);</div><div class="line">        exit(-1);</div><div class="line">    &#125;</div><div class="line">    next();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后是<code>main</code>函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">int main(int argc, char *argv[])</div><div class="line">&#123;</div><div class="line">    size_t linecap = 0;</div><div class="line">    ssize_t linelen;</div><div class="line">    while ((linelen = getline(&amp;line, &amp;linecap, stdin)) &gt; 0) &#123;</div><div class="line">        src = line;</div><div class="line">        next();</div><div class="line">        printf(&quot;%d\n&quot;, expr());</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本章中我们介绍了递归下降的方法，并用它来实现了四则运算的语法分析器。</p>
<p>花这么大精力讲解递归下降方法，是因为几乎所有手工编写的语法分析器都或多或少地有它的影子。换句话说，掌握了递归下降的方法，就可以应付大多数的语法分析器编写。</p>
<p>同时我们也用实例看到了理论（BNF 语法，左递归的消除）是如何帮助我们的工程实现的。尽管理论不是必需的，但如果能掌握它，对于提高我们的水平还是很有帮助的。</p>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> 编译器 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[手把手教你构建 C 语言编译器（3）——词法分析器]]></title>
      <url>/2017/03/12/write-a-C-interpreter-3/</url>
      <content type="html"><![CDATA[<p>本章我们要讲解如何构建词法分析器。</p>
<p>[注: 该系列转载自<a href="http://lotabout.me" target="_blank" rel="external">三点水</a>]</p>
<p>手把手教你构建 C 语言编译器系列共有10个部分：</p>
<ol>
<li><a href="http://thychan.cn/2017/03/12/write-a-C-interpreter-0/" target="_blank" rel="external">手把手教你构建 C 语言编译器（0）——前言</a></li>
<li><a href="http://thychan.cn/2017/03/12/write-a-C-interpreter-1/" target="_blank" rel="external">手把手教你构建 C 语言编译器（1）——设计</a></li>
<li><a href="http://thychan.cn/2017/03/12/write-a-C-interpreter-2/" target="_blank" rel="external">手把手教你构建 C 语言编译器（2）——虚拟机</a></li>
<li><a href="http://thychan.cn/2017/03/12/write-a-C-interpreter-3/" target="_blank" rel="external">手把手教你构建 C 语言编译器（3）——词法分析器</a></li>
<li><a href="http://thychan.cn/2017/03/12/write-a-C-interpreter-4/" target="_blank" rel="external">手把手教你构建 C 语言编译器（4）——递归下降</a></li>
<li><a href="http://thychan.cn/2017/03/12/write-a-C-interpreter-5/" target="_blank" rel="external">手把手教你构建 C 语言编译器（5）——变量定义</a></li>
<li><a href="http://thychan.cn/2017/03/12/write-a-C-interpreter-6/" target="_blank" rel="external">手把手教你构建 C 语言编译器（6）——函数定义</a></li>
<li><a href="http://thychan.cn/2017/03/12/write-a-C-interpreter-7/" target="_blank" rel="external">手把手教你构建 C 语言编译器（7）——语句</a></li>
<li><a href="http://thychan.cn/2017/03/12/write-a-C-interpreter-8/" target="_blank" rel="external">手把手教你构建 C 语言编译器（8）——表达式</a></li>
<li><a href="http://thychan.cn/2017/03/12/write-a-C-interpreter-9/" target="_blank" rel="external">手把手教你构建 C 语言编译器（9）——总结</a></li>
</ol>
<h1 id="什么是词法分析器"><a href="#什么是词法分析器" class="headerlink" title="什么是词法分析器"></a>什么是词法分析器</h1><p>简而言之，词法分析器用于对源码字符串做预处理，以减少语法分析器的复杂程度。</p>
<p>词法分析器以源码字符串为输入，输出为标记流（token stream），即一连串的标记，每个标记通常包括： <code>(token, token value)</code> 即标记本身和标记的值。例如，源码中若包含一个数字 <code>&#39;998&#39;</code> ，词法分析器将输出 <code>(Number, 998)</code>，即（数字，998）。再例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">2 + 3 * (4 - 5)</div><div class="line">=&gt;</div><div class="line">(Number, 2) Add (Number, 3) Multiply Left-Bracket (Number, 4) Subtract (Number, 5) Right-Bracket</div></pre></td></tr></table></figure>
<p>通过词法分析器的预处理，语法分析器的复杂度会大大降低，这点在后面的语法分析器我们就能体会。</p>
<h1 id="词法分析器与编译器"><a href="#词法分析器与编译器" class="headerlink" title="词法分析器与编译器"></a>词法分析器与编译器</h1><p>要是深入词法分析器，你就会发现，它的本质上也是编译器。我们的编译器是以标记流为输入，输出汇编代码，而词法分析器则是以源码字符串为输入，输出标记流。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">                   +-------+                      +--------+</div><div class="line">-- source code --&gt; | lexer | --&gt; token stream --&gt; | parser | --&gt; assembly</div><div class="line">                   +-------+                      +--------+</div></pre></td></tr></table></figure>
<p>在这个前提下，我们可以这样认为：直接从源代码编译成汇编代码是很困难的，因为输入的字符串比较难处理。所以我们先编写一个较为简单的编译器（词法分析器）来将字符串转换成标记流，而标记流对于语法分析器而言就容易处理得多了。</p>
<h1 id="词法分析器的实现"><a href="#词法分析器的实现" class="headerlink" title="词法分析器的实现"></a>词法分析器的实现</h1><p>由于词法分析的工作很常见，但又枯燥且容易出错，所以人们已经开发出了许多工具来生成词法分析器，如 <code>lex, flex</code>。这些工具允许我们通过正则表达式来识别标记。</p>
<p>这里注意的是，我们并不会一次性地将所有源码全部转换成标记流，原因有二：</p>
<ol>
<li>字符串转换成标记流有时是有状态的，即与代码的上下文是有关系的。</li>
<li>保存所有的标记流没有意义且浪费空间。</li>
</ol>
<p>所以实际的处理方法是提供一个函数（即前几篇中提到的 <code>next()</code>），每次调用该函数则返回下一个标记。</p>
<h2 id="支持的标记"><a href="#支持的标记" class="headerlink" title="支持的标记"></a>支持的标记</h2><p>在全局中添加如下定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// tokens and classes (operators last and in precedence order)</div><div class="line">enum &#123;</div><div class="line">  Num = 128, Fun, Sys, Glo, Loc, Id,</div><div class="line">  Char, Else, Enum, If, Int, Return, Sizeof, While,</div><div class="line">  Assign, Cond, Lor, Lan, Or, Xor, And, Eq, Ne, Lt, Gt, Le, Ge, Shl, Shr, Add, Sub, Mul, Div, Mod, Inc, Dec, Brak</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这些就是我们要支持的标记符。例如，我们会将 <code>=</code> 解析为 <code>Assign</code>；将 <code>==</code> 解析为 <code>Eq</code>；将 <code>!=</code> 解析为 <code>Ne</code> 等等。</p>
<p>所以这里我们会有这样的印象，一个标记（token）可能包含多个字符，且多数情况下如此。而词法分析器能减小语法分析复杂度的原因，正是因为它相当于通过一定的编码（更多的标记）来压缩了源码字符串。</p>
<p>当然，上面这些标记是有顺序的，跟它们在 C 语言中的优先级有关，如 <code>*(Mul)</code> 的优先级就要高于 <code>+(Add)</code>。它们的具体使用在后面的语法分析中会提到。</p>
<p>最后要注意的是还有一些字符，它们自己就构成了标记，如右方括号 <code>]</code> 或波浪号 <code>~</code> 等。我们不另外处理它们的原因是：</p>
<ol>
<li>它们是单字符的，即并不是多个字符共同构成标记（如 <code>==</code> 需要两个字符）；</li>
<li>它们不涉及优先级关系。</li>
</ol>
<h2 id="词法分析器的框架"><a href="#词法分析器的框架" class="headerlink" title="词法分析器的框架"></a>词法分析器的框架</h2><p>即 <code>next()</code> 函数的主体：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">void next() &#123;</div><div class="line">    char *last_pos;</div><div class="line">    int hash;</div><div class="line"></div><div class="line">    while (token = *src) &#123;</div><div class="line">        ++src;</div><div class="line">        // parse token here</div><div class="line">    &#125;</div><div class="line">    return;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里的一个问题是，为什么要用 <code>while</code> 循环呢？这就涉及到编译器（记得我们说过词法分析器也是某种意义上的编译器）的一个问题：如何处理错误？</p>
<p>对词法分析器而言，若碰到了一个我们不认识的字符该怎么处理？一般处理的方法有两种：</p>
<ol>
<li>指出错误发生的位置，并退出整个程序</li>
<li>指出错误发生的位置，跳过当前错误并继续编译</li>
</ol>
<p>这个 <code>while</code> 循环的作用就是跳过这些我们不识别的字符，我们同时还用它来处理空白字符。我们知道，C 语言中空格是用来作为分隔用的，并不作为语法的一部分。因此在实现中我们将它作为“不识别”的字符，这个 <code>while</code> 循环可以用来跳过它。</p>
<h2 id="换行符"><a href="#换行符" class="headerlink" title="换行符"></a>换行符</h2><p>换行符和空格类似，但有一点不同，每次遇到换行符，我们需要将当前的行号加一：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// parse token here</div><div class="line">...</div><div class="line"></div><div class="line">if (token == &apos;\n&apos;) &#123;</div><div class="line">    ++line;</div><div class="line">&#125;</div><div class="line">...</div></pre></td></tr></table></figure>
<h2 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h2><p>C 语言的宏定义以字符 <code>#</code> 开头，如 <code># include &lt;stdio.h&gt;</code>。我们的编译器并不支持宏定义，所以直接跳过它们。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">else if (token == &apos;#&apos;) &#123;</div><div class="line">    // skip macro, because we will not support it</div><div class="line">    while (*src != 0 &amp;&amp; *src != &apos;\n&apos;) &#123;</div><div class="line">        src++;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="标识符与符号表"><a href="#标识符与符号表" class="headerlink" title="标识符与符号表"></a>标识符与符号表</h2><p>标识符（identifier）可以理解为变量名。对于语法分析而言，我们并不关心一个变量具体叫什么名字，而只关心这个变量名代表的唯一标识。例如 <code>int a;</code> 定义了变量 <code>a</code>，而之后的语句 <code>a = 10</code>，我们需要知道这两个 <code>a</code> 指向的是同一个变量。</p>
<p>基于这个理由，词法分析器会把扫描到的标识符全都保存到一张表中，遇到新的标识符就去查这张表，如果标识符已经存在，就返回它的唯一标识。</p>
<p>那么我们怎么表示标识符呢？如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">struct identifier &#123;</div><div class="line">    int token;</div><div class="line">    int hash;</div><div class="line">    char * name;</div><div class="line">    int class;</div><div class="line">    int type;</div><div class="line">    int value;</div><div class="line">    int Bclass;</div><div class="line">    int Btype;</div><div class="line">    int Bvalue;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里解释一下具体的含义：</p>
<ol>
<li><code>token</code>：该标识符返回的标记，理论上所有的变量返回的标记都应该是 <code>Id</code>，但实际上由于我们还将在符号表中加入关键字如 <code>if</code>, <code>while</code> 等，它们都有对应的标记。</li>
<li><code>hash</code>：顾名思义，就是这个标识符的哈希值，用于标识符的快速比较。</li>
<li><code>name</code>：存放标识符本身的字符串。</li>
<li><code>class</code>：该标识符的类别，如数字，全局变量或局部变量等。</li>
<li><code>type</code>：标识符的类型，即如果它是个变量，变量是 <code>int</code> 型、<code>char</code> 型还是指针型。</li>
<li><code>value</code>：存放这个标识符的值，如标识符是函数，刚存放函数的地址。</li>
<li><code>BXXXX</code>：C 语言中标识符可以是全局的也可以是局部的，当局部标识符的名字与全局标识符相同时，用作保存全局标识符的信息。</li>
</ol>
<p>由上可以看出，我们实现的词法分析器与传统意义上的词法分析器不太相同。传统意义上的符号表只需要知道标识符的唯一标识即可，而我们还存放了一些只有语法分析器才会得到的信息，如 <code>type</code> 。</p>
<p>由于我们的目标是能自举，而我们定义的语法不支持 <code>struct</code>，故而使用下列方式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Symbol table:</div><div class="line">----+-----+----+----+----+-----+-----+-----+------+------+----</div><div class="line"> .. |token|hash|name|type|class|value|btype|bclass|bvalue| ..</div><div class="line">----+-----+----+----+----+-----+-----+-----+------+------+----</div><div class="line">    |&lt;---       one single identifier                ---&gt;|</div></pre></td></tr></table></figure>
<p>即用一个整型数组来保存相关的ID信息。每个ID占用数组中的9个空间，分析标识符的相关代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">int token_val;                // value of current token (mainly for number)</div><div class="line">int *current_id,              // current parsed ID</div><div class="line">    *symbols;                 // symbol table</div><div class="line"></div><div class="line">// fields of identifier</div><div class="line">enum &#123;Token, Hash, Name, Type, Class, Value, BType, BClass, BValue, IdSize&#125;;</div><div class="line"></div><div class="line"></div><div class="line">void next() &#123;</div><div class="line">        ...</div><div class="line"></div><div class="line">        else if ((token &gt;= &apos;a&apos; &amp;&amp; token &lt;= &apos;z&apos;) || (token &gt;= &apos;A&apos; &amp;&amp; token &lt;= &apos;Z&apos;) || (token == &apos;_&apos;)) &#123;</div><div class="line"></div><div class="line">            // parse identifier</div><div class="line">            last_pos = src - 1;</div><div class="line">            hash = token;</div><div class="line"></div><div class="line">            while ((*src &gt;= &apos;a&apos; &amp;&amp; *src &lt;= &apos;z&apos;) || (*src &gt;= &apos;A&apos; &amp;&amp; *src &lt;= &apos;Z&apos;) || (*src &gt;= &apos;0&apos; &amp;&amp; *src &lt;= &apos;9&apos;) || (*src == &apos;_&apos;)) &#123;</div><div class="line">                hash = hash * 147 + *src;</div><div class="line">                src++;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            // look for existing identifier, linear search</div><div class="line">            current_id = symbols;</div><div class="line">            while (current_id[Token]) &#123;</div><div class="line">                if (current_id[Hash] == hash &amp;&amp; !memcmp((char *)current_id[Name], last_pos, src - last_pos)) &#123;</div><div class="line">                    //found one, return</div><div class="line">                    token = current_id[Token];</div><div class="line">                    return;</div><div class="line">                &#125;</div><div class="line">                current_id = current_id + IdSize;</div><div class="line">            &#125;</div><div class="line"></div><div class="line"></div><div class="line">            // store new ID</div><div class="line">            current_id[Name] = (int)last_pos;</div><div class="line">            current_id[Hash] = hash;</div><div class="line">            token = current_id[Token] = Id;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>查找已有标识符的方法是线性查找 <code>symbols</code> 表。</p>
<h2 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h2><p>数字中较为复杂的一点是需要支持十进制、十六进制及八进制。逻辑也较为直接，可能唯一不好理解的是获取十六进制的值相关的代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">token_val = token_val * 16 + (token &amp; 15) + (token &gt;= &apos;A&apos; ? 9 : 0);</div></pre></td></tr></table></figure>
<p>这里要注意的是在ASCII码中，字符<code>a</code>对应的十六进制值是 <code>61</code>, <code>A</code>是<code>41</code>，故通过 <code>(token &amp; 15)</code> 可以得到个位数的值。其它就不多说了，这里这样写的目的是装B（其实是抄 c4 的源代码的）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">void next() &#123;</div><div class="line">        ...</div><div class="line"></div><div class="line"></div><div class="line">        else if (token &gt;= &apos;0&apos; &amp;&amp; token &lt;= &apos;9&apos;) &#123;</div><div class="line">            // parse number, three kinds: dec(123) hex(0x123) oct(017)</div><div class="line">            token_val = token - &apos;0&apos;;</div><div class="line">            if (token_val &gt; 0) &#123;</div><div class="line">                // dec, starts with [1-9]</div><div class="line">                while (*src &gt;= &apos;0&apos; &amp;&amp; *src &lt;= &apos;9&apos;) &#123;</div><div class="line">                    token_val = token_val*10 + *src++ - &apos;0&apos;;</div><div class="line">                &#125;</div><div class="line">            &#125; else &#123;</div><div class="line">                // starts with number 0</div><div class="line">                if (*src == &apos;x&apos; || *src == &apos;X&apos;) &#123;</div><div class="line">                    //hex</div><div class="line">                    token = *++src;</div><div class="line">                    while ((token &gt;= &apos;0&apos; &amp;&amp; token &lt;= &apos;9&apos;) || (token &gt;= &apos;a&apos; &amp;&amp; token &lt;= &apos;f&apos;) || (token &gt;= &apos;A&apos; &amp;&amp; token &lt;= &apos;F&apos;)) &#123;</div><div class="line">                        token_val = token_val * 16 + (token &amp; 15) + (token &gt;= &apos;A&apos; ? 9 : 0);</div><div class="line">                        token = *++src;</div><div class="line">                    &#125;</div><div class="line">                &#125; else &#123;</div><div class="line">                    // oct</div><div class="line">                    while (*src &gt;= &apos;0&apos; &amp;&amp; *src &lt;= &apos;7&apos;) &#123;</div><div class="line">                        token_val = token_val*8 + *src++ - &apos;0&apos;;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            token = Num;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>在分析时，如果分析到字符串，我们需要将它存放到前一篇文章中说的 <code>data</code> 段中。然后返回它在 <code>data</code>段中的地址。另一个特殊的地方是我们需要支持转义符。例如用 <code>\n</code> 表示换行符。由于本编译器的目的是达到自己编译自己，所以代码中并没有支持除 <code>\n</code> 的转义符，如 <code>\t</code>, <code>\r</code> 等，但仍支持 <code>\a</code> 表示字符 <code>a</code>的语法，如 <code>\&quot;</code> 表示 <code>&quot;</code>。</p>
<p>在分析时，我们将同时分析单个字符如 <code>&#39;a&#39;</code> 和字符串如 <code>&quot;a string&quot;</code>。若得到的是单个字符，我们以 <code>Num</code> 的形式返回。相关代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">void next() &#123;</div><div class="line">        ...</div><div class="line"></div><div class="line">        else if (token == &apos;&quot;&apos; || token == &apos;\&apos;&apos;) &#123;</div><div class="line">            // parse string literal, currently, the only supported escape</div><div class="line">            // character is &apos;\n&apos;, store the string literal into data.</div><div class="line">            last_pos = data;</div><div class="line">            while (*src != 0 &amp;&amp; *src != token) &#123;</div><div class="line">                token_val = *src++;</div><div class="line">                if (token_val == &apos;\\&apos;) &#123;</div><div class="line">                    // escape character</div><div class="line">                    token_val = *src++;</div><div class="line">                    if (token_val == &apos;n&apos;) &#123;</div><div class="line">                        token_val = &apos;\n&apos;;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                if (token == &apos;&quot;&apos;) &#123;</div><div class="line">                    *data++ = token_val;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            src++;</div><div class="line">            // if it is a single character, return Num token</div><div class="line">            if (token == &apos;&quot;&apos;) &#123;</div><div class="line">                token_val = (int)last_pos;</div><div class="line">            &#125; else &#123;</div><div class="line">                token = Num;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>在我们的 C 语言中，只支持 <code>//</code> 类型的注释，不支持 <code>/* comments */</code> 的注释。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">void next() &#123;</div><div class="line">        ...</div><div class="line"></div><div class="line">        else if (token == &apos;/&apos;) &#123;</div><div class="line">            if (*src == &apos;/&apos;) &#123;</div><div class="line">                // skip comments</div><div class="line">                while (*src != 0 &amp;&amp; *src != &apos;\n&apos;) &#123;</div><div class="line">                    ++src;</div><div class="line">                &#125;</div><div class="line">            &#125; else &#123;</div><div class="line">                // divide operator</div><div class="line">                token = Div;</div><div class="line">                return;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里我们要额外介绍 <code>lookahead</code> 的概念，即提前看多个字符。上述代码中我们看到，除了跳过注释，我们还可能返回除号 <code>/(Div)</code> 标记。</p>
<p>提前看字符的原理是：有一个或多个标记是以同样的字符开头的（如本小节中的注释与除号），因此只凭当前的字符我们并无法确定具体应该解释成哪一个标记，所以只能再向前查看字符，如本例需向前查看一个字符，若是 <code>/</code> 则说明是注释，反之则是除号。</p>
<p>我们之前说过，词法分析器本质上也是编译器，其实提前看字符的概念也存在于编译器，只是这时就是提前看k个“标记”而不是“字符”了。平时听到的 <code>LL(k)</code> 中的 <code>k</code> 就是需要向前看的标记的个数了。</p>
<p>另外，我们用词法分析器将源码转换成标记流，能减小语法分析复杂度，原因之一就是减少了语法分析器需要“向前看”的字符个数。</p>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>其它的标记的解析就相对容易一些了，我们直接贴上代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div></pre></td><td class="code"><pre><div class="line">void next() &#123;</div><div class="line">        ...</div><div class="line"></div><div class="line">        else if (token == &apos;=&apos;) &#123;</div><div class="line">            // parse &apos;==&apos; and &apos;=&apos;</div><div class="line">            if (*src == &apos;=&apos;) &#123;</div><div class="line">                src ++;</div><div class="line">                token = Eq;</div><div class="line">            &#125; else &#123;</div><div class="line">                token = Assign;</div><div class="line">            &#125;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        else if (token == &apos;+&apos;) &#123;</div><div class="line">            // parse &apos;+&apos; and &apos;++&apos;</div><div class="line">            if (*src == &apos;+&apos;) &#123;</div><div class="line">                src ++;</div><div class="line">                token = Inc;</div><div class="line">            &#125; else &#123;</div><div class="line">                token = Add;</div><div class="line">            &#125;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        else if (token == &apos;-&apos;) &#123;</div><div class="line">            // parse &apos;-&apos; and &apos;--&apos;</div><div class="line">            if (*src == &apos;-&apos;) &#123;</div><div class="line">                src ++;</div><div class="line">                token = Dec;</div><div class="line">            &#125; else &#123;</div><div class="line">                token = Sub;</div><div class="line">            &#125;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        else if (token == &apos;!&apos;) &#123;</div><div class="line">            // parse &apos;!=&apos;</div><div class="line">            if (*src == &apos;=&apos;) &#123;</div><div class="line">                src++;</div><div class="line">                token = Ne;</div><div class="line">            &#125;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        else if (token == &apos;&lt;&apos;) &#123;</div><div class="line">            // parse &apos;&lt;=&apos;, &apos;&lt;&lt;&apos; or &apos;&lt;&apos;</div><div class="line">            if (*src == &apos;=&apos;) &#123;</div><div class="line">                src ++;</div><div class="line">                token = Le;</div><div class="line">            &#125; else if (*src == &apos;&lt;&apos;) &#123;</div><div class="line">                src ++;</div><div class="line">                token = Shl;</div><div class="line">            &#125; else &#123;</div><div class="line">                token = Lt;</div><div class="line">            &#125;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        else if (token == &apos;&gt;&apos;) &#123;</div><div class="line">            // parse &apos;&gt;=&apos;, &apos;&gt;&gt;&apos; or &apos;&gt;&apos;</div><div class="line">            if (*src == &apos;=&apos;) &#123;</div><div class="line">                src ++;</div><div class="line">                token = Ge;</div><div class="line">            &#125; else if (*src == &apos;&gt;&apos;) &#123;</div><div class="line">                src ++;</div><div class="line">                token = Shr;</div><div class="line">            &#125; else &#123;</div><div class="line">                token = Gt;</div><div class="line">            &#125;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        else if (token == &apos;|&apos;) &#123;</div><div class="line">            // parse &apos;|&apos; or &apos;||&apos;</div><div class="line">            if (*src == &apos;|&apos;) &#123;</div><div class="line">                src ++;</div><div class="line">                token = Lor;</div><div class="line">            &#125; else &#123;</div><div class="line">                token = Or;</div><div class="line">            &#125;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        else if (token == &apos;&amp;&apos;) &#123;</div><div class="line">            // parse &apos;&amp;&apos; and &apos;&amp;&amp;&apos;</div><div class="line">            if (*src == &apos;&amp;&apos;) &#123;</div><div class="line">                src ++;</div><div class="line">                token = Lan;</div><div class="line">            &#125; else &#123;</div><div class="line">                token = And;</div><div class="line">            &#125;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        else if (token == &apos;^&apos;) &#123;</div><div class="line">            token = Xor;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        else if (token == &apos;%&apos;) &#123;</div><div class="line">            token = Mod;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        else if (token == &apos;*&apos;) &#123;</div><div class="line">            token = Mul;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        else if (token == &apos;[&apos;) &#123;</div><div class="line">            token = Brak;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        else if (token == &apos;?&apos;) &#123;</div><div class="line">            token = Cond;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        else if (token == &apos;~&apos; || token == &apos;;&apos; || token == &apos;&#123;&apos; || token == &apos;&#125;&apos; || token == &apos;(&apos; || token == &apos;)&apos; || token == &apos;]&apos; || token == &apos;,&apos; || token == &apos;:&apos;) &#123;</div><div class="line">            // directly return the character as token;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码较多，但主要逻辑就是向前看一个字符来确定真正的标记。</p>
<h2 id="关键字与内置函数"><a href="#关键字与内置函数" class="headerlink" title="关键字与内置函数"></a>关键字与内置函数</h2><p>虽然上面写完了词法分析器，但还有一个问题需要考虑，那就是“关键字”，例如 <code>if</code>, <code>while</code>, <code>return</code>等。它们不能被作为普通的标识符，因为有特殊的含义。</p>
<p>一般有两种处理方法：</p>
<ol>
<li>词法分析器中直接解析这些关键字。</li>
<li>在语法分析前将关键字提前加入符号表。</li>
</ol>
<p>这里我们就采用第二种方法，将它们加入符号表，并提前为它们赋予必要的信息（还记得前面说的标识符 <code>Token</code> 字段吗？）。这样当源代码中出现关键字时，它们会被解析成标识符，但由于符号表中已经有了相关的信息，我们就能知道它们是特殊的关键字。</p>
<p>内置函数的行为也和关键字类似，不同的只是赋值的信息，在<code>main</code>函数中进行初始化如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">// types of variable/function</div><div class="line">enum &#123; CHAR, INT, PTR &#125;;</div><div class="line">int *idmain;                  // the `main` function</div><div class="line"></div><div class="line">void main() &#123;</div><div class="line">    ...</div><div class="line"></div><div class="line">    src = &quot;char else enum if int return sizeof while &quot;</div><div class="line">          &quot;open read close printf malloc memset memcmp exit void main&quot;;</div><div class="line"></div><div class="line">     // add keywords to symbol table</div><div class="line">    i = Char;</div><div class="line">    while (i &lt;= While) &#123;</div><div class="line">        next();</div><div class="line">        current_id[Token] = i++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // add library to symbol table</div><div class="line">    i = OPEN;</div><div class="line">    while (i &lt;= EXIT) &#123;</div><div class="line">        next();</div><div class="line">        current_id[Class] = Sys;</div><div class="line">        current_id[Type] = INT;</div><div class="line">        current_id[Value] = i++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    next(); current_id[Token] = Char; // handle void type</div><div class="line">    next(); idmain = current_id; // keep track of main</div><div class="line"></div><div class="line">    ...</div><div class="line">    program();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>本章的代码可以在 <a href="https://github.com/lotabout/write-a-C-interpreter/tree/step-2" target="_blank" rel="external">Github</a> 上下载，也可以直接 clone</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git clone -b step-2 https://github.com/lotabout/write-a-C-interpreter</div></pre></td></tr></table></figure>
<p>上面的代码运行后会出现 ‘Segmentation Falt’，这是正常的，因为它会尝试运行我们上一章创建的虚拟机，但其中并没有任何汇编代码。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本章我们为我们的编译器构建了词法分析器，通过本章的学习，我认为有几个要点需要强调：</p>
<ol>
<li>词法分析器的作用是对源码字符串进行预处理，作用是减小语法分析器的复杂程度。</li>
<li>词法分析器本身可以认为是一个编译器，输入是源码，输出是标记流。</li>
<li><code>lookahead(k)</code> 的概念，即向前看 <code>k</code> 个字符或标记。</li>
<li>词法分析中如何处理标识符与符号表。</li>
</ol>
<p>下一章中，我们将介绍递归下降的语法分析器。我们下一章见。</p>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> 编译器 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[手把手教你构建 C 语言编译器（2）- 虚拟机]]></title>
      <url>/2017/03/12/write-a-C-interpreter-2/</url>
      <content type="html"><![CDATA[<h1 id="手把手教你构建-C-语言编译器（2）-虚拟机"><a href="#手把手教你构建-C-语言编译器（2）-虚拟机" class="headerlink" title="手把手教你构建 C 语言编译器（2）- 虚拟机"></a>手把手教你构建 C 语言编译器（2）- 虚拟机</h1><p>本章是“手把手教你构建 C 语言编译器”系列的第三篇，本章我们要构建一台虚拟的电脑，设计我们自己的指令集，运行我们的指令集，说得通俗一点就是自己实现一套汇编语言。它们将作为我们的编译器最终输出的目标代码。</p>
<p>[注: 该系列转载自<a href="http://lotabout.me" target="_blank" rel="external">三点水</a>]</p>
<p>手把手教你构建 C 语言编译器系列共有10个部分：</p>
<ol>
<li><a href="http://thychan.cn/2017/03/12/write-a-C-interpreter-0/" target="_blank" rel="external">手把手教你构建 C 语言编译器（0）——前言</a></li>
<li><a href="http://thychan.cn/2017/03/12/write-a-C-interpreter-1/" target="_blank" rel="external">手把手教你构建 C 语言编译器（1）——设计</a></li>
<li><a href="http://thychan.cn/2017/03/12/write-a-C-interpreter-2/" target="_blank" rel="external">手把手教你构建 C 语言编译器（2）——虚拟机</a></li>
<li><a href="http://thychan.cn/2017/03/12/write-a-C-interpreter-3/" target="_blank" rel="external">手把手教你构建 C 语言编译器（3）——词法分析器</a></li>
<li><a href="http://thychan.cn/2017/03/12/write-a-C-interpreter-4/" target="_blank" rel="external">手把手教你构建 C 语言编译器（4）——递归下降</a></li>
<li><a href="http://thychan.cn/2017/03/12/write-a-C-interpreter-5/" target="_blank" rel="external">手把手教你构建 C 语言编译器（5）——变量定义</a></li>
<li><a href="http://thychan.cn/2017/03/12/write-a-C-interpreter-6/" target="_blank" rel="external">手把手教你构建 C 语言编译器（6）——函数定义</a></li>
<li><a href="http://thychan.cn/2017/03/12/write-a-C-interpreter-7/" target="_blank" rel="external">手把手教你构建 C 语言编译器（7）——语句</a></li>
<li><a href="http://thychan.cn/2017/03/12/write-a-C-interpreter-8/" target="_blank" rel="external">手把手教你构建 C 语言编译器（8）——表达式</a></li>
<li><a href="http://thychan.cn/2017/03/12/write-a-C-interpreter-9/" target="_blank" rel="external">手把手教你构建 C 语言编译器（9）——总结</a></li>
</ol>
<p>计算机中有三个基本部件需要我们关注：CPU、寄存器及内存。代码（汇编指令）以二进制的形式保存在内存中；CPU 从中一条条地加载指令执行；程序运行的状态保存在寄存器中。</p>
<h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p>内存用于存储数据，这里的数据可以是代码，也可以是其它的数据。现代操作系统在操作内存时，并不是直接处理”物理内存“，而是操作”虚拟内存“。虚拟内存可以理解为一种映射，它的作用是屏蔽了物理的细节。例如 32 位的机器中，我们可以使用的内存地址为 <code>2^32 = 4G</code>，而电脑上的实际内存可能只有 <code>256 M</code>。操作系统将我们使用的虚拟地址映射到了到实际的内存上。</p>
<p>当然，我们这里并不需要了解太多，但需要了解的是：进程的内存会被分成几个段：</p>
<ol>
<li>代码段（text）用于存放代码（指令）。</li>
<li>数据段（data）用于存放初始化了的数据，如<code>int i = 10;</code>，就需要存放到数据段中。</li>
<li>未初始化数据段（bss）用于存放未初始化的数据，如 <code>int i[1000];</code>，因为不关心其中的真正数值，所以单独存放可以节省空间，减少程序的体积。</li>
<li>栈（stack）用于处理函数调用相关的数据，如调用帧（calling frame）或是函数的局部变量等。</li>
<li>堆（heap）用于为程序动态分配内存。</li>
</ol>
<p>它们在内存中的位置类似于下图：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">+------------------+</div><div class="line">|    stack   |     |      high address</div><div class="line">|    ...     v     |</div><div class="line">|                  |</div><div class="line">|                  |</div><div class="line">|                  |</div><div class="line">|                  |</div><div class="line">|    ...     ^     |</div><div class="line">|    heap    |     |</div><div class="line">+------------------+</div><div class="line">| bss  segment     |</div><div class="line">+------------------+</div><div class="line">| data segment     |</div><div class="line">+------------------+</div><div class="line">| text segment     |      low address</div><div class="line">+------------------+</div></pre></td></tr></table></figure>
<p>我们的虚拟机并不打算模拟完整的计算机，因此简单起见，我们只关心三个内容：代码段、数据段以及栈。其中的数据段我们只用来存放字符串，因为我们的编译器并不支持初始化变量，因此我们也不需要未初始化数据段。</p>
<p>当用户的程序需要分配内存时，理论上我们的虚拟机需要维护一个堆用于内存分配，但实际实现上较为复杂且与编译无关，故我们引入一个指令<code>MSET</code>，使我们能直接使用编译器（解释器）中的内存。</p>
<p>综上，我们需要首先在全局添加如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">int *text,            // text segment</div><div class="line">    *old_text,        // for dump text segment</div><div class="line">    *stack;           // stack</div><div class="line">char *data;           // data segment</div></pre></td></tr></table></figure>
<p>注意这里的类型，虽然是<code>int</code>型，但理解起来应该作为无符号的整型，因为我们会在代码段（text）中存放如指针/内存地址的数据，它们就是无符号的。其中数据段（data）由于只存放字符串，所以是 <code>char *</code> 型的。</p>
<p>接着，在<code>main</code>函数中加入初始化代码，真正为其分配内存：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">int main() &#123;</div><div class="line">    close(fd);</div><div class="line">    ...</div><div class="line"></div><div class="line">    // allocate memory for virtual machine</div><div class="line">    if (!(text = old_text = malloc(poolsize))) &#123;</div><div class="line">        printf(&quot;could not malloc(%d) for text area\n&quot;, poolsize);</div><div class="line">        return -1;</div><div class="line">    &#125;</div><div class="line">    if (!(data = malloc(poolsize))) &#123;</div><div class="line">        printf(&quot;could not malloc(%d) for data area\n&quot;, poolsize);</div><div class="line">        return -1;</div><div class="line">    &#125;</div><div class="line">    if (!(stack = malloc(poolsize))) &#123;</div><div class="line">        printf(&quot;could not malloc(%d) for stack area\n&quot;, poolsize);</div><div class="line">        return -1;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    memset(text, 0, poolsize);</div><div class="line">    memset(data, 0, poolsize);</div><div class="line">    memset(stack, 0, poolsize);</div><div class="line"></div><div class="line">    ...</div><div class="line">    program();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><p>计算机中的寄存器用于存放计算机的运行状态，真正的计算机中有许多不同种类的寄存器，但我们的虚拟机中只使用 4 个寄存器，分别如下：</p>
<ol>
<li><code>PC</code> 程序计数器，它存放的是一个内存地址，该地址中存放着 <strong>下一条</strong> 要执行的计算机指令。</li>
<li><code>SP</code> 指针寄存器，永远指向当前的栈顶。注意的是由于栈是位于高地址并向低地址增长的，所以入栈时 <code>SP</code> 的值减小。</li>
<li><code>BP</code> 基址指针。也是用于指向栈的某些位置，在调用函数时会使用到它。</li>
<li><code>AX</code> 通用寄存器，我们的虚拟机中，它用于存放一条指令执行后的结果。</li>
</ol>
<p>要理解这些寄存器的作用，需要去理解程序运行中会有哪些状态。而这些寄存器只是用于保存这些状态的。</p>
<p>在全局中加入如下定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int *pc, *bp, *sp, ax, cycle; // virtual machine registers</div></pre></td></tr></table></figure>
<p>在 <code>main</code> 函数中加入初始化代码，注意的是<code>PC</code>在初始应指向目标代码中的<code>main</code>函数，但我们还没有写任何编译相关的代码，因此先不处理。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">memset(stack, 0, poolsize);</div><div class="line">...</div><div class="line"></div><div class="line">bp = sp = (int *)((int)stack + poolsize);</div><div class="line">ax = 0;</div><div class="line"></div><div class="line">...</div><div class="line">program();</div></pre></td></tr></table></figure>
<p>与 CPU 相关的是指令集，我们将专门作为一个小节。</p>
<h2 id="指令集"><a href="#指令集" class="headerlink" title="指令集"></a>指令集</h2><p>指令集是 CPU 能识别的命令的集合，也可以说是 CPU 能理解的语言。这里我们要为我们的虚拟机构建自己的指令集。它们基于 x86 的指令集，但更为简单。</p>
<p>首先在全局变量中加入一个枚举类型，这是我们要支持的全部指令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// instructions</div><div class="line">enum &#123; LEA ,IMM ,JMP ,CALL,JZ  ,JNZ ,ENT ,ADJ ,LEV ,LI  ,LC  ,SI  ,SC  ,PUSH,</div><div class="line">       OR  ,XOR ,AND ,EQ  ,NE  ,LT  ,GT  ,LE  ,GE  ,SHL ,SHR ,ADD ,SUB ,MUL ,DIV ,MOD ,</div><div class="line">       OPEN,READ,CLOS,PRTF,MALC,MSET,MCMP,EXIT &#125;;</div></pre></td></tr></table></figure>
<p>这些指令的顺序安排是有意的，稍后你会看到，带有参数的指令在前，没有参数的指令在后。这种顺序的唯一作用就是在打印调试信息时更加方便。但我们讲解的顺序并不依据它。</p>
<h3 id="MOV"><a href="#MOV" class="headerlink" title="MOV"></a>MOV</h3><p><code>MOV</code> 是所有指令中最基础的一个，它用于将数据放进寄存器或内存地址，有点类似于 C 语言中的赋值语句。x86 的 <code>MOV</code> 指令有两个参数，分别是源地址和目标地址：<code>MOV dest, source</code> （Intel 风格），表示将 <code>source</code> 的内容放在 <code>dest</code> 中，它们可以是一个数、寄存器或是一个内存地址。</p>
<p>一方面，我们的虚拟机只有一个寄存器，另一方面，识别这些参数的类型（是数据还是地址）是比较困难的，因此我们将 <code>MOV</code> 指令拆分成 5 个指令，这些指令只接受一个参数，如下：</p>
<ol>
<li><code>IMM &lt;num&gt;</code> 将 <code>&lt;num&gt;</code> 放入寄存器 <code>ax</code> 中。</li>
<li><code>LC</code> 将对应地址中的字符载入 <code>ax</code> 中，要求 <code>ax</code> 中存放地址。</li>
<li><code>LI</code> 将对应地址中的整数载入 <code>ax</code> 中，要求 <code>ax</code> 中存放地址。</li>
<li><code>SC</code> 将 <code>ax</code> 中的数据作为字符存放入地址中，要求栈顶存放地址。</li>
<li><code>SI</code> 将 <code>ax</code> 中的数据作为整数存放入地址中，要求栈顶存放地址。</li>
</ol>
<p>你可能会觉得将一个指令变成了许多指令，整个系统就变得复杂了，但实际情况并非如此。首先是 x86 的 <code>MOV</code> 指令其实有许多变种，根据类型的不同有 <code>MOVB</code>, <code>MOVW</code> 等指令，我们这里的 <code>LC/SC</code> 和 <code>LI/SI</code> 就是对应字符型和整型的存取操作。</p>
<p>但最为重要的是，通过将 <code>MOV</code> 指令拆分成这些指令，只有 <code>IMM</code> 需要有参数，且不需要判断类型，所以大大简化了实现的难度。</p>
<p>在 <code>eval()</code> 函数中加入下列代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">void eval() &#123;</div><div class="line">    int op, *tmp;</div><div class="line">    while (1) &#123;</div><div class="line">        if (op == IMM)       &#123;ax = *pc++;&#125;                                     // load immediate value to ax</div><div class="line">        else if (op == LC)   &#123;ax = *(char *)ax;&#125;                               // load character to ax, address in ax</div><div class="line">        else if (op == LI)   &#123;ax = *(int *)ax;&#125;                                // load integer to ax, address in ax</div><div class="line">        else if (op == SC)   &#123;ax = *(char *)*sp++ = ax;&#125;                       // save character to address, value in ax, address on stack</div><div class="line">        else if (op == SI)   &#123;*(int *)*sp++ = ax;&#125;                             // save integer to address, value in ax, address on stack</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ...</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中的 <code>*sp++</code> 的作用是退栈，相当于 <code>POP</code> 操作。</p>
<p>这里要解释的一点是，为什么 <code>SI/SC</code> 指令中，地址存放在栈中，而 <code>LI/LC</code> 中，地址存放在 <code>ax</code> 中？原因是默认计算的结果是存放在 <code>ax</code> 中的，而地址通常是需要通过计算获得，所以执行 <code>LI/LC</code> 时直接从 <code>ax</code>取值会更高效。另一点是我们的 <code>PUSH</code> 指令只能将 <code>ax</code> 的值放到栈上，而不能以值作为参数，详细见下文。</p>
<h3 id="PUSH"><a href="#PUSH" class="headerlink" title="PUSH"></a>PUSH</h3><p>在 x86 中，<code>PUSH</code> 的作用是将值或寄存器，而在我们的虚拟机中，它的作用是将 <code>ax</code> 的值放入栈中。这样做的主要原因是为了简化虚拟机的实现，并且我们也只有一个寄存器 <code>ax</code> 。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">else if (op == PUSH) &#123;*--sp = ax;&#125;                                     // push the value of ax onto the stack</div></pre></td></tr></table></figure>
<h3 id="JMP"><a href="#JMP" class="headerlink" title="JMP"></a>JMP</h3><p><code>JMP &lt;addr&gt;</code> 是跳转指令，无条件地将当前的 <code>PC</code> 寄存器设置为指定的 <code>&lt;addr&gt;</code>，实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">else if (op == JMP)  &#123;pc = (int *)*pc;&#125;                                // jump to the address</div></pre></td></tr></table></figure>
<p>需要注意的是，<code>pc</code> 寄存器指向的是 <strong>下一条</strong> 指令。所以此时它存放的是 <code>JMP</code> 指令的参数，即 <code>&lt;addr&gt;</code> 的值。</p>
<h3 id="JZ-JNZ"><a href="#JZ-JNZ" class="headerlink" title="JZ/JNZ"></a>JZ/JNZ</h3><p>为了实现 <code>if</code> 语句，我们需要条件判断相关的指令。这里我们只实现两个最简单的条件判断，即结果（<code>ax</code>）为零或不为零情况下的跳转。</p>
<p>实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">else if (op == JZ)   &#123;pc = ax ? pc + 1 : (int *)*pc;&#125;                   // jump if ax is zero</div><div class="line">else if (op == JNZ)  &#123;pc = ax ? (int *)*pc : pc + 1;&#125;                   // jump if ax is zero</div></pre></td></tr></table></figure>
<h3 id="子函数调用"><a href="#子函数调用" class="headerlink" title="子函数调用"></a>子函数调用</h3><p>这是汇编中最难理解的部分，所以合在一起说，要引入的命令有 <code>CALL</code>, <code>ENT</code>, <code>ADJ</code> 及 <code>LEV</code>。</p>
<p>首先我们介绍 <code>CALL &lt;addr&gt;</code> 与 <code>RET</code> 指令，<code>CALL</code> 的作用是跳转到地址为 <code>&lt;addr&gt;</code> 的子函数，<code>RET</code> 则用于从子函数中返回。</p>
<p>为什么不能直接使用 <code>JMP</code> 指令呢？原因是当我们从子函数中返回时，程序需要回到跳转之前的地方继续运行，这就需要事先将这个位置信息存储起来。反过来，子函数要返回时，就需要获取并恢复这个信息。因此实际中我们将 <code>PC</code> 保存在栈中。如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">else if (op == CALL) &#123;*--sp = (int)(pc+1); pc = (int *)*pc;&#125;           // call subroutine</div><div class="line">//else if (op == RET)  &#123;pc = (int *)*sp++;&#125;                              // return from subroutine;</div></pre></td></tr></table></figure>
<p>这里我们把 <code>RET</code> 相关的内容注释了，是因为之后我们将用 <code>LEV</code> 指令来代替它。</p>
<p>在实际调用函数时，不仅要考虑函数的地址，还要考虑如何传递参数和如何返回结果。这里我们约定，如果子函数有返回结果，那么就在返回时保存在 <code>ax</code> 中，它可以是一个值，也可以是一个地址。那么参数的传递呢？</p>
<p>各种编程语言关于如何调用子函数有不同的约定，例如 C 语言的调用标准是：</p>
<ol>
<li>由调用者将参数入栈。</li>
<li>调用结束时，由调用者将参数出栈。</li>
<li>参数逆序入栈。</li>
</ol>
<p>事先声明一下，我们的编译器参数是顺序入栈的，下面的例子（C 语言调用标准）取自 <a href="https://en.wikipedia.org/wiki/X86_calling_conventions" target="_blank" rel="external">维基百科</a>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">int callee(int, int, int);</div><div class="line"></div><div class="line">int caller(void)</div><div class="line">&#123;</div><div class="line">	int i, ret;</div><div class="line"></div><div class="line">	ret = callee(1, 2, 3);</div><div class="line">	ret += 5;</div><div class="line">	return ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>会生成如下的 x86 汇编代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">caller:</div><div class="line">	; make new call frame</div><div class="line">	push    ebp</div><div class="line">	mov     ebp, esp</div><div class="line">        sub     1, esp       ; save stack for variable: i</div><div class="line">	; push call arguments</div><div class="line">	push    3</div><div class="line">	push    2</div><div class="line">	push    1</div><div class="line">	; call subroutine &apos;callee&apos;</div><div class="line">	call    callee</div><div class="line">	; remove arguments from frame</div><div class="line">	add     esp, 12</div><div class="line">	; use subroutine result</div><div class="line">	add     eax, 5</div><div class="line">	; restore old call frame</div><div class="line">        mov     esp, ebp</div><div class="line">	pop     ebp</div><div class="line">	; return</div><div class="line">	ret</div></pre></td></tr></table></figure>
<p>上面这段代码在我们自己的虚拟机里会有几个问题：</p>
<ol>
<li><code>push ebp</code>，但我们的 <code>PUSH</code> 指令并无法指定寄存器。</li>
<li><code>mov ebp, esp</code>，我们的 <code>MOV</code> 指令同样功能不足。</li>
<li><code>add esp, 12</code>，也是一样的问题（尽管我们还没定义）。</li>
</ol>
<p>也就是说由于我们的指令过于简单（如只能操作<code>ax</code>寄存器），所以用上面提到的指令，我们连函数调用都无法实现。而我们又不希望扩充现有指令的功能，因为这样实现起来就会变得复杂，因此我们采用的方法是增加指令集。毕竟我们不是真正的计算机，增加指令会消耗许多资源（钱）。</p>
<h3 id="ENT"><a href="#ENT" class="headerlink" title="ENT"></a>ENT</h3><p><code>ENT &lt;size&gt;</code> 指的是 <code>enter</code>，用于实现 ‘make new call frame’ 的功能，即保存当前的栈指针，同时在栈上保留一定的空间，用以存放局部变量。对应的汇编代码为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">; make new call frame</div><div class="line">push    ebp</div><div class="line">mov     ebp, esp</div><div class="line">       sub     1, esp       ; save stack for variable: i</div></pre></td></tr></table></figure>
<p>实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">else if (op == ENT)  &#123;*--sp = (int)bp; bp = sp; sp = sp - *pc++;&#125;      // make new stack frame</div></pre></td></tr></table></figure>
<h3 id="ADJ"><a href="#ADJ" class="headerlink" title="ADJ"></a>ADJ</h3><p><code>ADJ &lt;size&gt;</code> 用于实现 ‘remove arguments from frame’。在将调用子函数时压入栈中的数据清除，本质上是因为我们的 <code>ADD</code> 指令功能有限。对应的汇编代码为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">; remove arguments from frame</div><div class="line">add     esp, 12</div></pre></td></tr></table></figure>
<p>实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">else if (op == ADJ)  &#123;sp = sp + *pc++;&#125;                                // add esp, &lt;size&gt;</div></pre></td></tr></table></figure>
<h3 id="LEV"><a href="#LEV" class="headerlink" title="LEV"></a>LEV</h3><p>本质上这个指令并不是必需的，只是我们的指令集中并没有 <code>POP</code> 指令。并且三条指令写来比较麻烦且浪费空间，所以用一个指令代替。对应的汇编指令为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">; restore old call frame</div><div class="line">       mov     esp, ebp</div><div class="line">pop     ebp</div><div class="line">; return</div><div class="line">ret</div></pre></td></tr></table></figure>
<p>具体的实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">else if (op == LEV)  &#123;sp = bp; bp = (int *)*sp++; pc = (int *)*sp++;&#125;  // restore call frame and PC</div></pre></td></tr></table></figure>
<p>注意的是，<code>LEV</code> 已经把 <code>RET</code> 的功能包含了，所以我们不再需要 <code>RET</code> 指令。</p>
<h3 id="LEA"><a href="#LEA" class="headerlink" title="LEA"></a>LEA</h3><p>上面的一些指令解决了调用帧的问题，但还有一个问题是如何在子函数中获得传入的参数。这里我们首先要了解的是当参数调用时，栈中的调用帧是什么样的。我们依旧用上面的例子（只是现在用“顺序”调用参数）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">sub_function(arg1, arg2, arg3);</div><div class="line"></div><div class="line">|    ....       | high address</div><div class="line">+---------------+</div><div class="line">| arg: 1        |    new_bp + 4</div><div class="line">+---------------+</div><div class="line">| arg: 2        |    new_bp + 3</div><div class="line">+---------------+</div><div class="line">| arg: 3        |    new_bp + 2</div><div class="line">+---------------+</div><div class="line">|return address |    new_bp + 1</div><div class="line">+---------------+</div><div class="line">| old BP        | &lt;- new BP</div><div class="line">+---------------+</div><div class="line">| local var 1   |    new_bp - 1</div><div class="line">+---------------+</div><div class="line">| local var 2   |    new_bp - 2</div><div class="line">+---------------+</div><div class="line">|    ....       |  low address</div></pre></td></tr></table></figure>
<p>所以为了获取第一个参数，我们需要得到 <code>new_bp + 4</code>，但就如上面的说，我们的 <code>ADD</code> 指令无法操作除 <code>ax</code> 外的寄存器，所以我们提供了一个新的指令：<code>LEA &lt;offset&gt;</code></p>
<p>实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">else if (op == LEA)  &#123;ax = (int)(bp + *pc++);&#125;                         // load address for arguments.</div></pre></td></tr></table></figure>
<p>以上就是我们为了实现函数调用需要的指令了。</p>
<h3 id="运算符指令"><a href="#运算符指令" class="headerlink" title="运算符指令"></a>运算符指令</h3><p>我们为 C 语言中支持的运算符都提供对应汇编指令。每个运算符都是二元的，即有两个参数，第一个参数放在栈顶，第二个参数放在 <code>ax</code> 中。这个顺序要特别注意。因为像 <code>-</code>，<code>/</code> 之类的运算符是与参数顺序有关的。计算后会将栈顶的参数退栈，结果存放在寄存器 <code>ax</code> 中。因此计算结束后，两个参数都无法取得了（汇编的意义上，存在内存地址上就另当别论）。</p>
<p>实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">else if (op == OR)  ax = *sp++ | ax;</div><div class="line">else if (op == XOR) ax = *sp++ ^ ax;</div><div class="line">else if (op == AND) ax = *sp++ &amp; ax;</div><div class="line">else if (op == EQ)  ax = *sp++ == ax;</div><div class="line">else if (op == NE)  ax = *sp++ != ax;</div><div class="line">else if (op == LT)  ax = *sp++ &lt; ax;</div><div class="line">else if (op == LE)  ax = *sp++ &lt;= ax;</div><div class="line">else if (op == GT)  ax = *sp++ &gt;  ax;</div><div class="line">else if (op == GE)  ax = *sp++ &gt;= ax;</div><div class="line">else if (op == SHL) ax = *sp++ &lt;&lt; ax;</div><div class="line">else if (op == SHR) ax = *sp++ &gt;&gt; ax;</div><div class="line">else if (op == ADD) ax = *sp++ + ax;</div><div class="line">else if (op == SUB) ax = *sp++ - ax;</div><div class="line">else if (op == MUL) ax = *sp++ * ax;</div><div class="line">else if (op == DIV) ax = *sp++ / ax;</div><div class="line">else if (op == MOD) ax = *sp++ % ax;</div></pre></td></tr></table></figure>
<h3 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h3><p>写的程序要”有用“，除了核心的逻辑外还需要输入输出，例如 C 语言中我们经常使用的 <code>printf</code> 函数就是用于输出。但是 <code>printf</code> 函数的实现本身就十分复杂，如果我们的编译器要达到自举，就势必要实现 <code>printf</code> 之类的函数，但它又与编译器没有太大的联系，因此我们继续实现新的指令，从虚拟机的角度予以支持。</p>
<p>编译器中我们需要用到的函数有：<code>exit</code>, <code>open</code>, <code>close</code>, <code>read</code>, <code>printf</code>, <code>malloc</code>, <code>memset</code> 及 <code>memcmp</code>。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">else if (op == EXIT) &#123; printf(&quot;exit(%d)&quot;, *sp); return *sp;&#125;</div><div class="line">else if (op == OPEN) &#123; ax = open((char *)sp[1], sp[0]); &#125;</div><div class="line">else if (op == CLOS) &#123; ax = close(*sp);&#125;</div><div class="line">else if (op == READ) &#123; ax = read(sp[2], (char *)sp[1], *sp); &#125;</div><div class="line">else if (op == PRTF) &#123; tmp = sp + pc[1]; ax = printf((char *)tmp[-1], tmp[-2], tmp[-3], tmp[-4], tmp[-5], tmp[-6]); &#125;</div><div class="line">else if (op == MALC) &#123; ax = (int)malloc(*sp);&#125;</div><div class="line">else if (op == MSET) &#123; ax = (int)memset((char *)sp[2], sp[1], *sp);&#125;</div><div class="line">else if (op == MCMP) &#123; ax = memcmp((char *)sp[2], (char *)sp[1], *sp);&#125;</div></pre></td></tr></table></figure>
<p>这里的原理是，我们的电脑上已经有了这些函数的实现，因此编译编译器时，这些函数的二进制代码就被编译进了我们的编译器，因此在我们的编译器/虚拟机上运行我们提供的这些指令时，这些函数就是可用的。换句话说就是不需要我们自己去实现了。</p>
<p>最后再加上一个错误判断：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">else &#123;</div><div class="line">    printf(&quot;unknown instruction:%d\n&quot;, op);</div><div class="line">    return -1;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>下面我们用我们的汇编写一小段程序，来计算 <code>10+20</code>，在 <code>main</code> 函数中加入下列代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">int main(int argc, char *argv[])</div><div class="line">&#123;</div><div class="line">    ax = 0;</div><div class="line">    ...</div><div class="line"></div><div class="line">    i = 0;</div><div class="line">    text[i++] = IMM;</div><div class="line">    text[i++] = 10;</div><div class="line">    text[i++] = PUSH;</div><div class="line">    text[i++] = IMM;</div><div class="line">    text[i++] = 20;</div><div class="line">    text[i++] = ADD;</div><div class="line">    text[i++] = PUSH;</div><div class="line">    text[i++] = EXIT;</div><div class="line">    pc = text;</div><div class="line"></div><div class="line">    ...</div><div class="line">    program();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译程序 <code>gcc xc-tutor.c</code>，运行程序：<code>./a.out hello.c</code>。输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">exit(30)</div></pre></td></tr></table></figure>
<p>注意我们的之前的程序需要指令一个源文件，只是现在还用不着，但从结果可以看出，我们的虚拟机还是工作良好的。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本章中我们回顾了计算机的内部运行原理，并仿照 x86 汇编指令设计并实现了我们自己的指令集。希望通过本章的学习，你能对计算机程序的原理有一定的了解，同时能对汇编语言有一定的概念，因为汇编语言就是 C 编译器的输出。</p>
<p>本章的代码可以在 <a href="https://github.com/lotabout/write-a-C-interpreter/tree/step-1" target="_blank" rel="external">Github</a> 上下载，也可以直接 clone</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git clone -b step-1 https://github.com/lotabout/write-a-C-interpreter</div></pre></td></tr></table></figure>
<p>实际计算机中，添加一个新的指令需要设计许多新的电路，会增加许多的成本，但我们的虚拟机中，新的指令几乎不消耗资源，因此我们可以利用这一点，用更多的指令来完成更多的功能，从而简化具体的实现。</p>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> 编译器 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[手把手教你构建 C 语言编译器（1）—设计]]></title>
      <url>/2017/03/12/write-a-C-interpreter-1/</url>
      <content type="html"><![CDATA[<p>本章是“手把手教你构建 C 语言编译器”系列的第二篇，我们要从整体上讲解如何设计我们的 C 语言编译器。</p>
<p>[注: 该系列转载自<a href="http://lotabout.me" target="_blank" rel="external">三点水</a>]</p>
<p>手把手教你构建 C 语言编译器系列共有10个部分：</p>
<ol>
<li><a href="http://thychan.cn/2017/03/12/write-a-C-interpreter-0/" target="_blank" rel="external">手把手教你构建 C 语言编译器（0）——前言</a></li>
<li><a href="http://thychan.cn/2017/03/12/write-a-C-interpreter-1/" target="_blank" rel="external">手把手教你构建 C 语言编译器（1）——设计</a></li>
<li><a href="http://thychan.cn/2017/03/12/write-a-C-interpreter-2/" target="_blank" rel="external">手把手教你构建 C 语言编译器（2）——虚拟机</a></li>
<li><a href="http://thychan.cn/2017/03/12/write-a-C-interpreter-3/" target="_blank" rel="external">手把手教你构建 C 语言编译器（3）——词法分析器</a></li>
<li><a href="http://thychan.cn/2017/03/12/write-a-C-interpreter-4/" target="_blank" rel="external">手把手教你构建 C 语言编译器（4）——递归下降</a></li>
<li><a href="http://thychan.cn/2017/03/12/write-a-C-interpreter-5/" target="_blank" rel="external">手把手教你构建 C 语言编译器（5）——变量定义</a></li>
<li><a href="http://thychan.cn/2017/03/12/write-a-C-interpreter-6/" target="_blank" rel="external">手把手教你构建 C 语言编译器（6）——函数定义</a></li>
<li><a href="http://thychan.cn/2017/03/12/write-a-C-interpreter-7/" target="_blank" rel="external">手把手教你构建 C 语言编译器（7）——语句</a></li>
<li><a href="http://thychan.cn/2017/03/12/write-a-C-interpreter-8/" target="_blank" rel="external">手把手教你构建 C 语言编译器（8）——表达式</a></li>
<li><a href="http://thychan.cn/2017/03/12/write-a-C-interpreter-9/" target="_blank" rel="external">手把手教你构建 C 语言编译器（9）——总结</a></li>
</ol>
<p>首先要说明的是，虽然标题是编译器，但实际上我们构建的是 C 语言的解释器，这意味着我们可以像运行脚本一样去运行 C 语言的源代码文件。这么做的理由有两点：</p>
<ol>
<li>解释器与编译器仅在代码生成阶段有区别，而其它方面如词法分析、语法分析是一样的。</li>
<li>解释器需要我们实现自己的虚拟机与指令集，而这部分能帮助我们了解计算机的工作原理。</li>
</ol>
<h2 id="编译器的构建流程"><a href="#编译器的构建流程" class="headerlink" title="编译器的构建流程"></a>编译器的构建流程</h2><p>一般而言，编译器的编写分为 3 个步骤：</p>
<ol>
<li>词法分析器，用于将字符串转化成内部的表示结构。</li>
<li>语法分析器，将词法分析得到的标记流（token）生成一棵语法树。</li>
<li>目标代码的生成，将语法树转化成目标代码。</li>
</ol>
<p>已经有许多工具能帮助我们处理阶段1和2，如 flex 用于词法分析，bison 用于语法分析。只是它们的功能都过于强大，屏蔽了许多实现上的细节，对于学习构建编译器帮助不大。所以我们要完全手写这些功能。</p>
<p>所以我们会依照以下步骤来构建我们的编译器：</p>
<ol>
<li>构建我们自己的虚拟机以及指令集。这后生成的目标代码便是我们的指令集。</li>
<li>构建我们的词法分析器</li>
<li>构建语法分析器</li>
</ol>
<h2 id="编译器框架"><a href="#编译器框架" class="headerlink" title="编译器框架"></a>编译器框架</h2><p>我们的编译器主要包括 4 个函数：</p>
<ol>
<li><code>next()</code> 用于词法分析，获取下一个标记，它将自动忽略空白字符。</li>
<li><code>program()</code> 语法分析的入口，分析整个 C 语言程序。</li>
<li><code>expression(level)</code> 用于解析一个表达式。</li>
<li><code>eval()</code> 虚拟机的入口，用于解释目标代码。</li>
</ol>
<p>这里有一个单独用于解析“表达式”的函数 <code>expression</code> 是因为表达式在语法分析中相对独立并且比较复杂，所以我们将它单独作为一个模块（函数）。下面是相应的源代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;stdlib.h&gt;</div><div class="line">#include &lt;memory.h&gt;</div><div class="line">#include &lt;string.h&gt;</div><div class="line"></div><div class="line">int token;            // current token</div><div class="line">char *src, *old_src;  // pointer to source code string;</div><div class="line">int poolsize;         // default size of text/data/stack</div><div class="line">int line;             // line number</div><div class="line"></div><div class="line">void next() &#123;</div><div class="line">    token = *src++;</div><div class="line">    return;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void expression(int level) &#123;</div><div class="line">    // do nothing</div><div class="line">&#125;</div><div class="line"></div><div class="line">void program() &#123;</div><div class="line">    next();                  // get next token</div><div class="line">    while (token &gt; 0) &#123;</div><div class="line">        printf(&quot;token is: %c\n&quot;, token);</div><div class="line">        next();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">int eval() &#123; // do nothing yet</div><div class="line">    return 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main(int argc, char **argv)</div><div class="line">&#123;</div><div class="line">    int i, fd;</div><div class="line"></div><div class="line">    argc--;</div><div class="line">    argv++;</div><div class="line"></div><div class="line">    poolsize = 256 * 1024; // arbitrary size</div><div class="line">    line = 1;</div><div class="line"></div><div class="line">    if ((fd = open(*argv, 0)) &lt; 0) &#123;</div><div class="line">        printf(&quot;could not open(%s)\n&quot;, *argv);</div><div class="line">        return -1;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (!(src = old_src = malloc(poolsize))) &#123;</div><div class="line">        printf(&quot;could not malloc(%d) for source area\n&quot;, poolsize);</div><div class="line">        return -1;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // read the source file</div><div class="line">    if ((i = read(fd, src, poolsize-1)) &lt;= 0) &#123;</div><div class="line">        printf(&quot;read() returned %d\n&quot;, i);</div><div class="line">        return -1;</div><div class="line">    &#125;</div><div class="line">    src[i] = 0; // add EOF character</div><div class="line">    close(fd);</div><div class="line"></div><div class="line">    program();</div><div class="line">    return eval();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的代码看上去挺复杂，但其实内容不多。它的流程为：读取一个文件（内容为 C 语言代码），逐个读取文件中的字符，并输出。这里需要的是注意每个函数的作用，后面的文章中，我们将逐个填充每个函数的功能，最终构建起我们的编译器。</p>
<p>本节的代码可以在 <a href="https://github.com/lotabout/write-a-C-interpreter/tree/step-0" target="_blank" rel="external">Github</a> 上下载，也可以直接 clone</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git clone -b step-0 https://github.com/lotabout/write-a-C-interpreter</div></pre></td></tr></table></figure>
<p>这样我们就有了一个最简单的编译器：什么都不干的编译器，下一章中，我们将实现其中的<code>eval</code>函数，即我们自己的虚拟机。</p>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> 编译器 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[手把手教你构建 C 语言编译器（0）- 前言]]></title>
      <url>/2017/03/12/write-a-C-interpreter-0/</url>
      <content type="html"><![CDATA[<p>“手把手教你构建 C 语言编译器” 这一系列教程将带你从头编写一个 C 语言的编译器。希望通过这个系列，我们能对编译器的构建有一定的了解，同时，我们也将构建出一个能用的 C 语言编译器，尽管有许多语法并不支持。</p>
<p>[注: 该系列转载自<a href="http://lotabout.me" target="_blank" rel="external">三点水</a>]</p>
<p>手把手教你构建 C 语言编译器系列共有10个部分：</p>
<ol>
<li><a href="http://thychan.cn/2017/03/12/write-a-C-interpreter-0/" target="_blank" rel="external">手把手教你构建 C 语言编译器（0）——前言</a></li>
<li><a href="http://thychan.cn/2017/03/12/write-a-C-interpreter-1/" target="_blank" rel="external">手把手教你构建 C 语言编译器（1）——设计</a></li>
<li><a href="http://thychan.cn/2017/03/12/write-a-C-interpreter-2/" target="_blank" rel="external">手把手教你构建 C 语言编译器（2）——虚拟机</a></li>
<li><a href="http://thychan.cn/2017/03/12/write-a-C-interpreter-3/" target="_blank" rel="external">手把手教你构建 C 语言编译器（3）——词法分析器</a></li>
<li><a href="http://thychan.cn/2017/03/12/write-a-C-interpreter-4/" target="_blank" rel="external">手把手教你构建 C 语言编译器（4）——递归下降</a></li>
<li><a href="http://thychan.cn/2017/03/12/write-a-C-interpreter-5/" target="_blank" rel="external">手把手教你构建 C 语言编译器（5）——变量定义</a></li>
<li><a href="http://thychan.cn/2017/03/12/write-a-C-interpreter-6/" target="_blank" rel="external">手把手教你构建 C 语言编译器（6）——函数定义</a></li>
<li><a href="http://thychan.cn/2017/03/12/write-a-C-interpreter-7/" target="_blank" rel="external">手把手教你构建 C 语言编译器（7）——语句</a></li>
<li><a href="http://thychan.cn/2017/03/12/write-a-C-interpreter-8/" target="_blank" rel="external">手把手教你构建 C 语言编译器（8）——表达式</a></li>
<li><a href="http://thychan.cn/2017/03/12/write-a-C-interpreter-9/" target="_blank" rel="external">手把手教你构建 C 语言编译器（9）——总结</a></li>
</ol>
<p>在开始进入正题之前，本篇是一些闲聊，谈谈这个系列的初衷。如果你急切地想进入正篇，请跳过本章。</p>
<h2 id="为什么要学编译原理"><a href="#为什么要学编译原理" class="headerlink" title="为什么要学编译原理"></a>为什么要学编译原理</h2><p>如果要我说计算机专业最重要的三门课，我会说是《数据结构》、《算法》和《编译原理》。在我看来，能不能理解“递归”像是程序员的第一道门槛，而会不会写编译器则是第二道。</p>
<p>（当然，并不是说是没写过编译器就不是好程序员，只能说它是一个相当大的挑战吧）</p>
<p>以前人们会说，学习了编译原理，你就能写出更加高效的代码，但随着计算机性能的提升，代码是否高效显得就不那么重要了。那么为什么要学习编译原理呢？</p>
<p>原因只有一个：装B。</p>
<p>好吧，也许现在还想学习编译原理的人只可能是因为兴趣了。一方面想了解它的工作原理；另一方面希望挑战一下自己，看看自己能走多远。</p>
<h2 id="理论很复杂，实现也很复杂？"><a href="#理论很复杂，实现也很复杂？" class="headerlink" title="理论很复杂，实现也很复杂？"></a>理论很复杂，实现也很复杂？</h2><p>我对编译器一直心存敬佩。所以当学校开《编译原理》的课程后，我是抱着满腔热情去上课的，但是两节课后我就放弃了。原因是太复杂了，听不懂。</p>
<p>一般编译原理的课程会说一些：</p>
<ol>
<li>如何表示语法（BNF什么的）</li>
<li>词法分析，用什么有穷自动机和无穷自动机</li>
<li>语法分析，递归下降法，什么 <code>LL(k)</code>，LALR 分析。</li>
<li>中间代码的表示</li>
<li>代码的生成</li>
<li>代码优化</li>
</ol>
<p>我相信绝大多数（98％）的学生顶多学到语法分析就结束了。并且最重要的是，学了这么多也没用！依旧帮助不了我们学习编译器！这其中最主要的原因是《编译原理》试图教会我们的是如何构造“编译器生成器”，即构造一个工具，根据文法来生成编译器（如 lex/yacc）等等。</p>
<p>这些理论试图教会我们如何用通用的方法来自动解决问题，它们有很强的实际意义，只是对于一般的学生或程序员来说，它们过于强大，内容过于复杂。如果你尝试阅读 lex/yacc （或 flex/bison）的代码，就会发现太可怕了。</p>
<p>然而如果你能跟我一样，真正来实现一个简单的编译器，那么你会发现，比起可怕的《编译原理》，这点复杂度还是不算什么的（因为好多理论根本用不上）。</p>
<h2 id="项目的初衷"><a href="#项目的初衷" class="headerlink" title="项目的初衷"></a>项目的初衷</h2><p>有一次在 Github 上看到了一个项目（当时很火的），名叫 <a href="https://github.com/rswier/c4" target="_blank" rel="external">c4</a>，号称用 4 个函数来实现了一个小的 C 语言编译器。它最让我震惊的是能够自举，即能自己编译自己。并且它用很少的代码就完成了一个功能相当完善的 C 语言编译器。</p>
<p>一般的编译器相关的教程要么就十分简单（如实现四则运算），要么就是借助了自动生成的工具（如 flex/bison）。而 c4 的代码完全是手工实现的，不用外部工具。可惜的是它的代码初衷是代码最小化，所以写得很乱，很难懂。所以本项目的主要目的：</p>
<ol>
<li>实现一个功能完善的 C 语言编译器</li>
<li>通过教程来说明这个过程。</li>
</ol>
<p>c4 大致500+行。重写的代码历时一周，总共代码加注释1400行。项目地址: <a href="https://github.com/lotabout/write-a-C-interpreter" target="_blank" rel="external">Write a C Interpreter</a>。</p>
<p>声明：本项目中的代码逻辑绝大多数取自 c4 ，但确为自己重写。</p>
<h2 id="做好心理准备"><a href="#做好心理准备" class="headerlink" title="做好心理准备"></a>做好心理准备</h2><p>在写编译器的时候会遇到两个主要问题：</p>
<ol>
<li>繁琐，会有许多相似的代码，写起来很无聊。</li>
<li>难以调试，一方面没有很好的测试用例，另一方面需要对照生成的代码来调试（遇到的时候就知道了）。</li>
</ol>
<p>所以我希望你有足够的耐心和时间来学习，相信当你真正完成的时候会像我一样，十分有成就感。</p>
<p>PS. 第一篇完全没有正题相关的内容也是希望你能有所心理准备再开始学习。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>最后想介绍几个资料：</p>
<ol>
<li><a href="http://compilers.iecc.com/crenshaw/" target="_blank" rel="external">Let’s Build a Compiler</a> 很好的初学者教程，英文的。</li>
<li><a href="http://www.hwaci.com/sw/lemon/" target="_blank" rel="external">Lemon Parser Generator</a>，一个语法分析器生成器，对照《编译原理》观看效果更佳。</li>
</ol>
<p>由于本人水平一般，文章、代码难免会有错误，敬请批评指正！</p>
<p>最后祝你学得愉快。</p>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> 编译器 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Win下必备神器之Cmder]]></title>
      <url>/2017/03/11/Win%E4%B8%8B%E5%BF%85%E5%A4%87%E7%A5%9E%E5%99%A8%E4%B9%8BCmder/</url>
      <content type="html"><![CDATA[<p>[转载自<a href="http://www.jeffjade.com/About" target="_blank" rel="external">晚晴幽草轩轩主</a>]</p>
<p><a href="http://www.jeffjade.com/2016/01/13/2016-01-13-windows-software-cmder/#" target="_blank" rel="external">原文首链－晚晴幽草轩</a>or<a href="http://www.jianshu.com/p/b691b48bcee3" target="_blank" rel="external">简书</a></p>
<p>诚言，对于开发码字者，Mac和Linux果断要比Windows更贴心;但只要折腾下，Windows下也是有不少利器的。之前就有在<a href="http://www.jeffjade.com/2015/10/19/2015-10-18-Efficacious-win-software/" target="_blank" rel="external">Windows下效率必备软件</a>一文中对此做了下记载；其虽没<code>oh-my-zsh</code>那么逆天的存在，却也甚是好用，至少要比Windows原生Cmd好出了天际。因为<strong>好用</strong>，所以<strong>“必备”</strong>。</p>
<p><a href="http://7xoosr.com1.z0.glb.clouddn.com/cmder.jpg" target="_blank" rel="external"><img src="http://7xoosr.com1.z0.glb.clouddn.com/cmder.jpg" alt="Cmder"></a>Cmder</p>
<h2 id="安裝-cmder"><a href="#安裝-cmder" class="headerlink" title="安裝 cmder"></a><strong>安裝 cmder</strong></h2><p><a href="http://cmder.net/" target="_blank" rel="external">Cmder官网</a><code>http://cmder.net/</code>（她把conemu，msysgit和clink打包在一起，让你无需配置就能使用一个真正干净的Linux终端！她甚至还附带了漂亮的monokai配色主题。）;作为一个压缩档的存在, 可即压即用。你甚至可以放到USB就可以虽时带着走，连调整过的设定都会放在这个目录下，不会用到系统机码(Registry)，所以也很适合放在Dropbox / Google Drive / OneDrive共享于多台电脑。</p>
<p>下载的时候，有两个版本，分别是mini与full版；唯一的差别在于有没有内建msysgit工具，这是Git for Windows的标准配备；全安装版 cmder 自带了 msysgit, 压缩包 23M, 除了 git 本身这个命令之外, 里面可以使用大量的 linux 命令；比如 grep, curl(没有 wget)； 像vim, grep, tar, unzip, ssh, ls, bash, perl 对于爱折腾的Coder更是痛点需求。</p>
<p><a href="http://7xoosr.com1.z0.glb.clouddn.com/msysgit-bin.png" target="_blank" rel="external"><img src="http://7xoosr.com1.z0.glb.clouddn.com/msysgit-bin.png" alt="cmder强大自带命令"></a>cmder强大自带命令</p>
<h2 id="配置-Cmder"><a href="#配置-Cmder" class="headerlink" title="配置 Cmder"></a><strong>配置 Cmder</strong></h2><h3 id="启动Cmder"><a href="#启动Cmder" class="headerlink" title="启动Cmder"></a><strong>启动Cmder</strong></h3><p>因为她是即压即用的存在，所以点击<code>Cmder.exe</code>即可运行。很显然这般打开她，不怎么快捷，即便用<code>Listary</code>高效搜索到她，然后点击;我们可以这样做:</p>
<ol>
<li><p>把 <strong>cmder</strong> 加到环境变量<br>可以把<code>Cmder.exe</code>存放的目录添加到系统环境变量；加完之后,<code>Win+r</code>一下输入<code>cmder</code>,即可。</p>
</li>
<li><p><strong>添加 cmder 到右键菜单</strong><br>在某个文件夹中打开终端, 这个是一个(超级)痛点需求, 实际上上一步的把 <strong>cmder</strong> 加到环境变量就是为此服务的, 在管理员权限的终端输入以下语句即可:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Cmder.exe /REGISTER ALL</div></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>打开一个管理员权限终端:</strong><br>输入 Ctrl + t, 或者点击下面控制条的绿色加号, 勾选 Run as administrator<br><a href="http://7xoosr.com1.z0.glb.clouddn.com/cmderRunAdmin.jpg" target="_blank" rel="external"><img src="http://7xoosr.com1.z0.glb.clouddn.com/cmderRunAdmin.jpg" alt="Run as administrator"></a>Run as administrator<br>这就打开了一个管理员权限的终端, 在里面输入上述语句，就可在每个文件夹右键菜单中点击 <code>Cmder here</code>唤起Cmder，方便快捷。</p>
<p>不用打开文件夹就能打Cmder,并进入该目录;爽。</p>
<ol>
<li>借用Win下逆天神器：<code>AutoHotKey</code>（这个下篇要好好记载下）为Cmder配置自己喜欢的快捷键(个人用<code>Alt+r</code>)：<code>!r:: run, D:\**\cmder_mini\Cmder.exe</code></li>
</ol>
<p>个人比较推崇使用<code>AutoHotKey</code>；高效简洁，才是王道。</p>
<h3 id="默认开启设置"><a href="#默认开启设置" class="headerlink" title="默认开启设置"></a><strong>默认开启设置</strong></h3><p>作为强大的存在，必然支持私人定制。输入<code>win + alt + p</code>或者 在底部右击点击 settings, 进入设置页面；可以根据自己的所需进行各种配置(字体，皮肤等等等等)。</p>
<p>目前游走在前端，<code>Gulp</code>已离不开，<code>Cmder+PowerShell</code>这个组合无疑是运行gulp的利器。如下图所示，可以设置<code>PowerShell</code>作为默认开启的选项；也可以更改默认开启是所在目录。<br><a href="http://7xoosr.com1.z0.glb.clouddn.com/CmderSeting.jpg" target="_blank" rel="external"><img src="http://7xoosr.com1.z0.glb.clouddn.com/CmderSeting.jpg" alt="Cmder-Seting"></a>Cmder-Seting</p>
<h3 id="解决文字重叠问题"><a href="#解决文字重叠问题" class="headerlink" title="解决文字重叠问题"></a><strong>解决文字重叠问题</strong></h3><p>Win + ALT + P 唤出设置界面 &gt; mian &gt; font &gt; monospce,去掉那勾勾即可。</p>
<h3 id="修改命令提示符号·λ·"><a href="#修改命令提示符号·λ·" class="headerlink" title="修改命令提示符号·λ·"></a><strong>修改命令提示符号·λ·</strong></h3><p><a href="http://7xoosr.com1.z0.glb.clouddn.com/CmderChange.jpg" target="_blank" rel="external"><img src="http://7xoosr.com1.z0.glb.clouddn.com/CmderChange.jpg" alt="Cmder修改命令提示符号"></a>Cmder修改命令提示符号<br>Cmder预设的命列列提示符号是<strong>λ</strong>;如果用着不习惯，可以将这个字元改成Mac / Linux环境下常见的<strong>$</strong>符号，具体操作如下：<br>编辑Cmder安装目录下的vendor\init.bat批处理文件(min版本15行)，把：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@prompt $E[1;32;40m$P$S&#123;git&#125;&#123;hg&#125;$S$_$E[1;30;40m &#123;lamb&#125; $S$E[0m</div></pre></td></tr></table></figure>
<p>修改成以下即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@prompt $E[1;32;40m$P$S&#123;git&#125;&#123;hg&#125;$S$_$E[1;30;40m $$ $S$E[0m</div></pre></td></tr></table></figure>
<p>这个亲测在<code>cmder.exe</code>可以，但在<code>PowerShell.exe</code>需要另行设置:<br>打开文件config/cmder.lua（prompt.lua也有版本是这个），将第二行中的<strong>λ</strong>修改为Linux下常用的<strong>$</strong>即可；亲测可行(2016-01-13)。</p>
<h2 id="常用功能介绍"><a href="#常用功能介绍" class="headerlink" title="常用功能介绍"></a><strong>常用功能介绍</strong></h2><p>cmder 功能极为强大，功能也非常多，但从视窗画面上看不太出其强大实力，这里就先说下其「看的见」的功能：<br><a href="http://7xoosr.com1.z0.glb.clouddn.com/CmderFunction.png" target="_blank" rel="external"><img src="http://7xoosr.com1.z0.glb.clouddn.com/CmderFunction.png" alt="Cmder强大功能图示"></a>Cmder强大功能图示<br>如上图示编号的部分说明如下：<br>1, Cmder常用快捷键<br>跟一般浏览器页签操作习惯一致:</p>
<blockquote>
<p>可以利用<code>Tab</code>，自动路径补全(爽,赞！)；<br>可以利用<strong>Ctrl+T</strong>建立新页签；<br>利用<strong>Ctrl+W</strong>关闭页签;<br>还可以透过<strong>Ctrl+Tab</strong>切换页签;<br><strong>Alt+F4</strong>：关闭所有页签<br><strong>Alt+Shift+1</strong>：开启cmd.exe<br><strong>Alt+Shift+2</strong>：开启powershell.exe<br><strong>Alt+Shift+3</strong>：开启powershell.exe (系统管理员权限)<br><strong>Ctrl+1</strong>：快速切换到第1个页签<br><strong>Ctrl+n</strong>：快速切换到第n个页签( n值无上限)<br><strong>Alt + enter</strong>： 切换到全屏状态；<br><strong>Ctr+r</strong> 历史命令搜索;<br><strong>End, Home, Ctrl</strong> : Traversing text with as usual on Windows</p>
</blockquote>
<p>2, 可在视窗内搜寻画面上出现过的任意关键字。<br>3, 新增页签按钮，可透过滑鼠新增页签。<br>4, 切换页签按钮，可透过滑鼠切换页签。<br>5, 锁定视窗，让视窗无法再输入。<br>6, 切换视窗是否提供卷轴功能，启动时可查询之前显示过的内容。<br>7, 按下滑鼠左键可开启系统选单，滑鼠右键可开启工具选项视窗。 Win+Alt+P ：开启工具选项视窗</p>
<h2 id="cmder元件组成"><a href="#cmder元件组成" class="headerlink" title="cmder元件组成"></a><strong>cmder元件组成</strong></h2><p>cmder其实结合了多套软体，其中包括<a href="https://github.com/msysgit/msysgit" target="_blank" rel="external">msysgit</a>与最重要的<a href="http://conemu.github.io/" target="_blank" rel="external">ConEmu</a>与<a href="http://mridgers.github.io/clink/" target="_blank" rel="external">Clink</a>软体，而ConEmu与Clink这两套软体就是cmder真正的核心元件。</p>
<ul>
<li><strong>msysgit</strong>除了提供Git for Windows 相关工具外，其实还提供了多套Unix/Linux 环境下常用的指令列工具，例如less, ls, tar, unzip, md5sum, grep, sed, … 等多套工具。<br>光是一个grep 就不知道比Windows 内建的findstr 强几百倍了！</li>
<li><strong>ConEmu</strong>也可以是单独一款软件存在，曾经一度迷恋于它，然而其体验并不如<strong>cmder</strong>，便放弃它了。</li>
<li><strong>Clink</strong> 将GNU Readline 函式库整合进原生的Windows 命令提示字元视窗，提供命令列模式下强大的编辑与输入能力，这也是用了cmder 之后会这么像在Linux 环境下使用的感觉。</li>
</ul>
<p>上述功能,目前没怎么用，根据<strong>学以致用</strong>原理，也就还没去了解去折腾。</p>
<h3 id="Chocolatey软件包管理系统"><a href="#Chocolatey软件包管理系统" class="headerlink" title="Chocolatey软件包管理系统"></a><strong>Chocolatey软件包管理系统</strong></h3><p>在 Linux 下，大家喜欢用 apt-get(mac下用brew) 来安装应用程序，如今在 windows 下，大家可以使用 Chocolatey 来快速下载搭建一个开发环境。<code>Chocolatey</code>的哲学就是完全用命令行来安装应用程序， 它更像一个包管理工具（背后使用 Nuget ）</p>
<p>另外需要说明的是， Chocolatey 只是把官方下载路径封装到了 Chocolatey 中，所以下载源都是其官方路径，所以下载的一定是合法的，但是如果原软件是需要 Licence 注册的话，那么 Chocolatey 下载安装好的软件还是需要你去购买注册。不过 Chocolatey 一般还是会选用免费 Licence 可用的软件。</p>
<p>安装chocolatey , 运行如下命令即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@powershell -NoProfile -ExecutionPolicy unrestricted -Command &quot;iex ((new-object net.webclient).DownloadString(&apos;https://chocolatey.org/install.ps1&apos;))&quot; &amp;&amp; SET PATH=%PATH%;%ALLUSERSPROFILE%\chocolatey\bin</div></pre></td></tr></table></figure>
<p>安装软件命令 <code>choco install softwareName</code>, 短写是 <code>cinst softwareName</code><br>可安装的应用程序，可以参见其 <a href="https://chocolatey.org/packages" target="_blank" rel="external">Package列表</a><br>以下是window下开发常用的开发环境应用:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">choco install autohotkey.portable    #安装 AutoHotkey (Portable)</div><div class="line">choco install nodejs.install  #安装 node</div><div class="line">choco install git.install     #安装 git</div><div class="line">choco install ruby            #安装 ruby</div><div class="line">choco install python          #安装 python</div><div class="line">choco install jdk8            #安装 JDK8</div><div class="line">choco install googlechrome    #安装 Chrome</div><div class="line">choco install google-chrome-x64 #Google Chrome (64-bit only)</div><div class="line">choco install firefox         #安装 firefox</div><div class="line">choco install notepadplusplus.install #安装 notepad++</div><div class="line">choco install Atom                    #安装 Atom</div><div class="line">choco install SublimeText3            #安装 SublimeText3</div></pre></td></tr></table></figure>
<h2 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能"></a><strong>其他功能</strong></h2><ul>
<li><p>Cmder还增加了<strong>alias</strong>功能;他让你用短短的指令执行一些常见但指令超长又难以记忆的语法;比如 <code>ls</code> <code>cls</code>等等；在其控制台输入<code>alias</code>可以查看。</p>
</li>
<li><p>主控台文字自动放大缩小功能，你只要按<strong>下Ctrl+滑鼠滚轮</strong>就可以办到;果你用支援两点触控的笔电，也可以在触控板上用两指放大的手势调整文字大小。还有：<strong>up</strong>，向上翻历史命令;</p>
</li>
<li><p><strong>Cmder</strong>有极为简单的<strong>复制粘贴</strong>操作。<strong>Ctr+V</strong>直接粘贴;用鼠标选中你想拷贝的内容，自动就复制到剪切板；天神，这悉数的美感;点赞!</p>
</li>
<li><p><strong>自定义aliases</strong>:打开Cmder目录下的config文件夹，里面的aliases文件就是我们可以配置的别名文件，只需将里面ls命令的别名按下列方式修改就可以在ls命令下显示中文。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ls=ls --show-control-chars --color=auto $*</div></pre></td></tr></table></figure>
</li>
</ul>
<p>当然，别名文件还可以有许多其他配置，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">e.=explorer .</div><div class="line">gcc=cd D:\Document\gcc\</div><div class="line">gw=cd D:\Document\GitHub\work</div><div class="line">gl=git log --oneline --all --graph --decorate  $*</div><div class="line">ls=ls --show-control-chars --color=auto $*</div><div class="line">pwd=cd</div><div class="line">clear=cls</div></pre></td></tr></table></figure>
<p>这个在公司电脑上总不成功；问题<code>无效的宏定义。</code>;在写到这里时候，还未查明缘由【待探究，待更新】。</p>
<p>—2016-01-14 20:05更新:<br>感谢@V友(zongwan)可以修改Cmder目录下<code>vendor\profile.ps1</code>文件，Like This：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Set-Alias st &quot;C:\Program Files\Sublime Text 3\sublime_text.exe&quot;</div><div class="line"></div><div class="line">function Git-Status &#123; git status &#125;</div><div class="line">Set-Alias gs Git-Status</div><div class="line"></div><div class="line">function go-Work &#123;cd E:\work\web\cdn\&#125;</div><div class="line">Set-Alias gw go-Work</div></pre></td></tr></table></figure>
<p><code>st xxx</code>就用实现以sublimeText打开xxx文件；<code>gw</code>下就能进入所设置的目录;<code>gs</code>相当于在使用git文件目录下用<code>git status</code>;凡此种种,为常用命令设置下简短别名,真心不错。</p>
<p>Windows的cmd就是一个奇葩的存在…如果你愿意花时间去找，你能找到很多的可以替代它的软件，譬如：<code>Babun</code>, <code>Gow</code> ,<code>Conemu</code> , <code>clink</code>等等，任何一款都比原生Cmd来得快意。环境虽如是，体验却在你。</p>
<p>大概就这样，折腾让生活更美好，不止于编程码字。还是那句话，与君共勉：<br>“<strong>过一个平凡无趣的人生实在太容易了，你可以不读书，不冒险，不运动，不写作，不外出，不折腾……但是，人生最后悔的事情就是：我本可以。</strong>”——陈素封。</p>
<p>参考文章：<br><a href="http://cmder.net/" target="_blank" rel="external">Cmder官网</a><br><a href="https://phphub.org/topics/67" target="_blank" rel="external">利用 Chocolatey 快速在 Windows 下搭建一个开发环境</a><br><a href="http://blog.miniasp.com/post/2015/09/27/Useful-tool-Cmder.aspx" target="_blank" rel="external">介绍好用工具：Cmder ( 具有Linux 温度的Windows 命令提示字元工具 )</a></p>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> 工具 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[一个老鸟发的公司内部整理的 Android 学习路线图]]></title>
      <url>/2017/03/07/%E4%B8%80%E4%B8%AA%E8%80%81%E9%B8%9F%E5%8F%91%E7%9A%84%E5%85%AC%E5%8F%B8%E5%86%85%E9%83%A8%E6%95%B4%E7%90%86%E7%9A%84%20Android%20%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%E5%9B%BE/</url>
      <content type="html"><![CDATA[<blockquote>
<p>看到一篇不错的Android学习路线图,故转载分享之.</p>
<p>整理自<a href="https://www.diycode.cc/jerrysher" target="_blank" rel="external">jerrysher</a>的<a href="https://www.diycode.cc/topics/122" target="_blank" rel="external">一个老鸟发的公司内部整理的 Android 学习路线图 Markdown 版本</a></p>
</blockquote>
<p>原文不是表格，感觉看起来不是那么直观，所以就重新弄了一份表格版的，希望对大家有所帮助</p>
<hr>
<h1 id="程序设计"><a href="#程序设计" class="headerlink" title="程序设计"></a>程序设计</h1><table>
<thead>
<tr>
<th>知识点</th>
<th></th>
<th>链接或书籍</th>
<th>进阶</th>
</tr>
</thead>
<tbody>
<tr>
<td>Java</td>
<td>基本语法(如继承、异常、引用、泛型等)</td>
<td><a href="https://book.douban.com/subject/25762168/" target="_blank" rel="external">Java核心技术 卷I</a>（适合入门）</td>
<td><a href="https://book.douban.com/subject/3360807/" target="_blank" rel="external">Effective Java中文版</a>（如何写好的Java代码） <br> <a href="https://book.douban.com/subject/5362860" target="_blank" rel="external">Java解惑</a> （介绍烂Java代码是什么样的）</td>
</tr>
<tr>
<td></td>
<td>多线程、并发</td>
<td><a href="https://book.douban.com/subject/10484692/" target="_blank" rel="external">Java并发编程实战</a> （系统全面的介绍了Java的并发，如何设计支持并发的数据结构）</td>
<td></td>
</tr>
<tr>
<td></td>
<td>Java 7</td>
<td><a href="https://book.douban.com/subject/24841235/" target="_blank" rel="external">Java程序员修炼之道</a> （详细的介绍Java 7 的新特性）</td>
<td></td>
</tr>
<tr>
<td></td>
<td>Java 8</td>
<td><a href="https://book.douban.com/subject/26274206/" target="_blank" rel="external">写给大忙人看的Java SE 8</a> <br> <a href="https://book.douban.com/subject/26587213/" target="_blank" rel="external">函数式编程思维</a></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Java虚拟机</td>
<td><a href="https://book.douban.com/subject/24722612/" target="_blank" rel="external">深入理解Java虚拟机</a> （并不是那么难，Java程序员都该看看）</td>
<td></td>
</tr>
<tr>
<td></td>
<td>性能优化</td>
<td><a href="https://book.douban.com/subject/25828043/" target="_blank" rel="external">Java性能优化权威指南</a> （后面的章节好像用处不大，前面有些部分还是值得看）</td>
<td></td>
</tr>
<tr>
<td>算法与数据结构</td>
<td>算法时间复杂度、空间复杂度的基本认知; <br> 熟悉常用数据结构：链表、队列、散列表、树等； <br> 递归、分支等基本思想； <br> 常用算法应用：排序、查找、比较等</td>
<td><a href="https://book.douban.com/subject/1139426/" target="_blank" rel="external">数据结构与算法分析</a> （涵盖面比较全、示例是Java语言） <br> <a href="https://book.douban.com/subject/26337727/" target="_blank" rel="external">算法设计与分析基础</a> （实用主义的典型、偏算法设计） <br> <a href="https://book.douban.com/subject/3227098/" target="_blank" rel="external">编程珠玑</a> （实践型算法数据）</td>
<td></td>
</tr>
<tr>
<td>操作系统</td>
<td>对Linux/OS的基本认知 <br> Linux的常用命令</td>
<td><a href="https://book.douban.com/subject/4889838/" target="_blank" rel="external">鸟哥的Linux私房菜</a> <br> <a href="https://book.douban.com/subject/6097773/" target="_blank" rel="external">Linux内核设计与实现(原书第3版)</a> （很精炼的语言描述清楚了内核算法）</td>
<td></td>
</tr>
<tr>
<td>网络</td>
<td>Http/Https <br> TCP/IP</td>
<td><a href="https://book.douban.com/subject/25863515/" target="_blank" rel="external">图解HTTP</a> <br> <a href="https://book.douban.com/subject/24737674/" target="_blank" rel="external">图解TCP/IP</a></td>
<td><a href="https://book.douban.com/subject/1088054/" target="_blank" rel="external">TCP/IP详解</a></td>
</tr>
<tr>
<td>Android</td>
<td>四大组件（服务、广播、ContentProvider、页面容器） <br> 基础UI组件（ListView、ViewPager） <br> 异步任务机制（AsyncTask、Handler、线程池） <br> 布局优化（层级、绘制、碎片化处理） <br> 图片加载（Bitmap、缓冲区）</td>
<td><a href="https://github.com/googlesamples/android-UniversalMusicPlayer" target="_blank" rel="external">UniversalMusicePlayer</a> (通过学习一个音乐播放器的代码能很快了解四大组件) <br> <a href="http://hukai.me/android-training-course-in-chinese/index.html" target="_blank" rel="external">Android Training官方课程</a> <br> <a href="https://github.com/FX-Max/Point-of-Android" target="_blank" rel="external">Android一些重要知识点解析整理</a> <br> <a href="https://github.com/wasabeef/awesome-android-ui" target="_blank" rel="external">Android UI/UX库</a>（各类常用组件及扩展组件的集合） <br> <a href="http://square.github.io/picasso/" target="_blank" rel="external">Picasso</a> 、 <a href="https://github.com/bumptech/glide" target="_blank" rel="external">Glide</a> （两个图片加载库） <br> <a href="https://github.com/google/iosched" target="_blank" rel="external">The Google I/O 2015 Android App</a> (Google大会官方的App，适合学习各类实现) <br> <a href="http://www.devtf.cn/" target="_blank" rel="external">Android开发技术前线</a> （定期翻译、发布国内外Android优质的技术、开源库、软件架构设计、测试等文章）</td>
<td><a href="https://github.com/wasabeef/awesome-android-libraries" target="_blank" rel="external">第三方库集合</a> （列举了常见的各方向第三方库）</td>
</tr>
</tbody>
</table>
<hr>
<h1 id="软件工程"><a href="#软件工程" class="headerlink" title="软件工程"></a>软件工程</h1><table>
<thead>
<tr>
<th>知识点</th>
<th></th>
<th>链接或书籍</th>
<th>进阶</th>
</tr>
</thead>
<tbody>
<tr>
<td>基础工具</td>
<td>IDE、Git、Maven</td>
<td><a href="https://developer.android.com/studio/index.html" target="_blank" rel="external">AndroidStudio</a> <br> <a href="http://iissnan.com/progit/html/zh/ch1_0.html" target="_blank" rel="external">Git权威指南中文手册</a></td>
<td></td>
</tr>
<tr>
<td>软件质量</td>
<td>代码整洁 <br> 代码质量 <br> 代码重构</td>
<td><a href="https://book.douban.com/subject/10797189/" target="_blank" rel="external">编写可读代码的艺术</a> （来自Google工程师，专注于代码可读性） <br> <a href="https://book.douban.com/subject/4199741/" target="_blank" rel="external">代码整洁之道</a>（使用面向对象+敏捷开发原则编写清晰可维护的代码） <br> <a href="https://book.douban.com/subject/4262627/" target="_blank" rel="external">重构-改善既有代码的设计</a> （学习改善已有代码） <br> <a href="https://book.douban.com/subject/1173730/" target="_blank" rel="external">重构手册</a> （改善代码的实际操作）</td>
<td></td>
</tr>
<tr>
<td>设计模式</td>
<td>23种常见设计模式</td>
<td><a href="https://book.douban.com/subject/2334288/" target="_blank" rel="external">大话设计模式</a> <br> <a href="https://book.douban.com/subject/2243615/" target="_blank" rel="external">Head First设计模式</a>(两本入门级的设计模式书籍)</td>
<td><a href="https://book.douban.com/subject/1052241/" target="_blank" rel="external">设计模式-可复用面向对象软件的基础</a>（设计模式在实际中的应用）</td>
</tr>
<tr>
<td>敏捷开发</td>
<td></td>
<td><a href="https://book.douban.com/subject/1790225/" target="_blank" rel="external">解析极限编程</a> <br> <a href="https://book.douban.com/subject/4037534/" target="_blank" rel="external">敏捷开发的艺术</a></td>
<td><a href="http://book.douban.com/subject/5348122/" target="_blank" rel="external">敏捷软件开发-原则、模式与实践</a></td>
</tr>
<tr>
<td>专业开发</td>
<td>程序员职业素养 <br> 更高效、更实效</td>
<td><a href="程序员的是职业素养">程序员的是职业素养</a> <br> <a href="https://book.douban.com/subject/5387402/" target="_blank" rel="external">程序员修炼之道-从小工到专家</a></td>
<td></td>
</tr>
<tr>
<td>思考人生</td>
<td></td>
<td><a href="https://book.douban.com/subject/6021440/" target="_blank" rel="external">黑客与画家</a> (硅谷创业之父Paul Craham 的文集，主要介绍黑客及优秀程序员的爱好和动机)</td>
<td></td>
</tr>
</tbody>
</table>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> 学习路线 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android学习笔记-<1>Android应用和开发环境]]></title>
      <url>/2017/01/20/Android%E5%BA%94%E7%94%A8%E5%92%8C%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</url>
      <content type="html"><![CDATA[<h1 id="1-1-Android-的发展和历史"><a href="#1-1-Android-的发展和历史" class="headerlink" title="1.1 Android 的发展和历史"></a>1.1 Android 的发展和历史</h1><p>​    Android是由Andy Rubin创立的一个手机操作系统,后来被Google收购.Google希望与各方面共同建立一个标准化,开放式的移动电话软件平台,从而在移动产业内形成一个开放式的操作平台.</p>
<h2 id="1-1-1-Android-的发展和简介"><a href="#1-1-1-Android-的发展和简介" class="headerlink" title="1.1.1 Android 的发展和简介"></a>1.1.1 Android 的发展和简介</h2><p>​    Android并不是Google创造的,而是由Android公司所创造的,该公司的创始人是Andy Rubin. 该公司后来被Google收购,而Andy Rubin也成为Google公司的Android产品负责人.</p>
<p>​    Google于2007年11月5日发布了Android 1.0手机操作系统,这个版本的Android系统还没有赢得广泛的市场支持.</p>
<p>​    2009年5月份,Google发布了Android 1.5,该版本的Android提供了一个非常”豪华”的用户界面,而且提供了蓝牙连接支持.这个版本的Android吸引了大量的开发者的目光.接下来,Android的版本更新得较快.</p>
<p>​    事实上,Android已经超过了手机操作系统的范畴,Android系统已经广泛应用于TV,手表以及各种可穿戴设备.</p>
<p>​    从2008年9月22日, T-Mobile在纽约正式发布第一款Android手机–T-Mobile G1开始,Android系统不断地获得哥哥手机厂商的青睐.</p>
<p>​    2010年1月7日,Google在其美国总部正式向外界发布了旗下首款合作品牌手机Nexus One(HTC G5),同时开始对外发售.</p>
<h2 id="1-1-2-Android-平台架构及特性"><a href="#1-1-2-Android-平台架构及特性" class="headerlink" title="1.1.2 Android 平台架构及特性"></a>1.1.2 Android 平台架构及特性</h2><p>​    Android系统的底层建立在Linux系统上,该平台由操作系统,中间层,用户界面和应用软件4层组成,它采用一种被称为软件叠层(Software Stack)的方式进行构建.这种软件叠层结构使得层与层之间相互分离,明确各层的分工.这种分工保证了层与层之间的低耦合,当下层的层内或层下发生改变时,上层应用陈旭无须任何改变.</p>
<p>​    1. 应用程序层</p>
<p>​    Android系统将包含一系列的核心应用程序,包括电子邮件客户端,SMS程序,日历,地图,浏览器,联系人等.这些应用程序通常都是由Java编写的.</p>
<p>​    2. 应用程序框架</p>
<p>​    当我们开发Android应用程序时,就是面向底层的应用程序框架进行的.从这个意义上来看,Android系统上的应用程序是完全平等的,不管是Android系统提供的程序,还是普通开发者提供的程序,都可以访问Android提供的API框架.</p>
<p>​    Android应用程序框架提供了大量API供开发者使用.应用程序框架除了可作为应用程序开发的基础之外,也是软件复用的重要手段,任何一个应用程序都可以发布它的功能模块–只要发布时遵守了框架的约定,那么其他应用程序就可以使用这个功能模块.</p>
<p>​    3. 函数库</p>
<p>​    Android包含一套被不同组件所使用的C/C++库集合.一般来说,Android应用开发者不能直接调用这套C/C++库集,但可以通过它上面的应用程序框架来调用这些库.</p>
<p>下面列出一些核心库.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- 系统C库: 一个从BSD系统派生出来的标准C系统库(libc),并且专门为嵌入式Linux设备调整过.</div><div class="line">- 媒体库: 基于PacketVideo的OpenCORE,这套媒体库支持播放和录制许多流行的音频和视频格式,以及查看静态图片.主要包括MPEG4, H.264, MP3, AAC, AMR, JPG, PNG 等多媒体格式.</div><div class="line">- Surface Manager: 管理对显示子系统的访问,并且可以对多个应用程序的2D, 3D图层提供无缝整合.</div><div class="line">- LibWebCore: 一个全新的Web浏览器引擎,该引擎为Android浏览器提供支持,也为WebView提供支持,WebView完全可以嵌入开发者自己的应用程序中.</div><div class="line">- SGL: 底层的2D图形引擎.</div><div class="line">- 3D libraries: 基于OpenGL ES API实现的3D系统,这套3D库既可使用硬件3D加速(如果硬件系统支持),也可使用高度优化的软件3D加速.</div><div class="line">- FreeType: 位图和向量字体显示.</div><div class="line">- SQLite: 提供所有应用程序使用的功能强大的轻量级关系数据库.</div></pre></td></tr></table></figure>
<p>​    4. Android运行时</p>
<p>​    Android运行时由两部分组成: Android核心库集合ART.其中核心库集提供了Java语言核心库所能使用的绝大部分功能,而虚拟机则负责运行Android应用程序.</p>
<p>​    Android 5.0以前的Android运行时由Dalvik虚拟机和Android核心库集组成,但由于Dalvik虚拟机采用了一种被称为JIT(Just-in-time)的解释器进行动态编译并执行,因此导致Android App运行时比较慢;而ART模式则是在用户安装App是进行预编译(Ahead-of-time,简称AOT)的,将原本在程序运行时的编译动作提前到应用安装时,这样使得程序在运行时可以减少动态编译的开销,从而提升Android App的运行效率.</p>
<p>​    反过来, 由于ART需要在安装App时进行AOT处理,因此ART需要占用更多的存储空间,应用安装和系统启动时间会延长不少.</p>
<p>​    除此之外,ART还支持ARM,x86和MIPS架构,并且完全兼容64位系统,Android 5.0之后必然带来更好的用户体验.</p>
<p>​    5. Linux内核</p>
<p>​    Android系统建立在Linux2.6之上.Linux内核提供了安全性,内存管理,进程管理,网络协议栈和驱动模型等核心系统服务.除此之外,Linux内核也是系统硬件和软件叠层之间的抽象层.</p>
<h1 id="1-2-搭建Android开发环境"><a href="#1-2-搭建Android开发环境" class="headerlink" title="1.2 搭建Android开发环境"></a>1.2 搭建Android开发环境</h1><p>​    在开始搭建Android开发环境之前,Java编程基础等知识将不再说明.下面将从Android SDK的安装大致说明.(涉及的站点若无法访问,建议设置代理服务器来访问该站点)</p>
<h2 id="1-2-1-下载和安装Android-SDK"><a href="#1-2-1-下载和安装Android-SDK" class="headerlink" title="1.2.1 下载和安装Android SDK"></a>1.2.1 下载和安装Android SDK</h2><p>​    Android的官方站点是<a href="http://www.android.com" target="_blank" rel="external">http://www.android.com</a> , 登录该站点即可下载Android SDK.下载和安装Android SDK有如下步骤.</p>
<p>​    1.登录<a href="http://developer.android.com/sdk/index.html" target="_blank" rel="external">http://developer.android.com/sdk/index.html</a> 页面,滚动到”SDK Tools Only” 处,即可看到Android SDK的下载链接.</p>
<p>​    2.单击Android SDK的下载链接,即可下载Android SDK的压缩包.</p>
<p>​    3.下载完成后将压缩文件解压到任意路径下,得到的文件夹包含如下文件结构.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">(<span class="number">1</span>).add-one: 该目录下存放第三方公司为Android平台开发的附加功能系统.刚解压缩时为空.</div><div class="line"></div><div class="line">(<span class="number">2</span>).platforms: 该目录下存放不同版本的Android系统,刚解压缩时为空.</div><div class="line"></div><div class="line">(<span class="number">3</span>).tools: 该目录下存放了大量Android开发,调试的工具.</div><div class="line"></div><div class="line">(<span class="number">4</span>).AVD Manager.exe: 该程序是AVD(Android虚拟设备)管理器.通过该工具可以管理AVD.</div><div class="line"></div><div class="line">(<span class="number">5</span>).SDK Manager.exe: 该程序就是Android SDK管理器.通过该工具可以管理Android SDK.</div></pre></td></tr></table></figure>
<p>​    4.启动SDK Manager.exe, 在窗口列表中勾选需要安装的平台和工具,比如Android 6.0的工具和平台,其中Android文档, SDK Platform是必选的.若是想查看Android官方提供的实例程序,使用Android SDK源代码,则可以勾选”Samples for SDK”和”Source for Android SDK”两个列表项(最好将Android 6.0所包含的工具都安装上,若无须为Android TV,可穿戴设备开发应用,则可暂时不勾选以Android TV,Android Wear开头的选项).至于是否需要安装Android的早期的SDK,取决于个人需求.</p>
<p>​    5.选中所需安装的工具后,单击”Install XX package”按钮,出现确认窗口,单击”Accept License”单选按钮–确认安装之前所选择的所有的工具包,然后单击”Install”按钮,系统开始在线安装Android SDK及相关工具. 在线安装时间取决于用户的网络状态以及选中工具包的数量,多的话甚至可能花费数小时,耐心等待即可.</p>
<p>​    6.下载安装完成将可以看到在Android SDK目录下新增了如下的几个文件夹.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- docs: 该文件夹下存放了Android SDK开发文件和API文档等.</div><div class="line">- extras: 该文件夹下存放了Google提供的USB驱动,Intel提供的硬件加速等附加工具包.</div><div class="line">- platform-tools: 该文件夹下存放了Android平台相关工具.</div><div class="line">- samples: 该文件夹下存放了不同Android平台的实例程序.</div><div class="line">- source: 该文件夹下存放了Android的源代码</div><div class="line">- system-images: 该文件夹下存放了不同平台针对不同CPU架构提供的系统镜像.</div></pre></td></tr></table></figure>
<p>​    7.未来在命令行窗口可以使用Android SDK的各种工具,建议将Android SDK目录下的tools子目录,platform-tools子目录添加到系统的PATH环境变量中.</p>
<h2 id="1-2-2-安装Android-Studio"><a href="#1-2-2-安装Android-Studio" class="headerlink" title="1.2.2 安装Android Studio"></a>1.2.2 安装Android Studio</h2><p>​    Android Studio是Google为Android提供的官方IDE工具,Google建议广大Android开发者尽快从Eclipse+ADT的开发环境改为使用Android Studio.</p>
<p>​    Android Studio不再基于Eclipse,而是基于Intellij IDEA的Android开发环境.实际上,Intellij IDEA一直都是一款非常优秀的Java IDE工具,只是因为Intellij IDEA是一款商业的IDE工具(虽然也有免费的社区交流部,但功能相当有限),因此影响了Intellij IDEA的广泛应用.现在Google以Intellij IDEA为基础推出Android Studio同样可以免费使用,因此具有非常大的吸引力.</p>
<p>​    1.登录<a href="http://developer.android.com/sdk/index.html" target="_blank" rel="external">http://developer.android.com/sdk/index.html</a> 页面,滚动到最下方”All Android Studio Packages”处,即可看到下载链接.</p>
<p>​    2.单击下载链接,即可下载得到一个压缩包.</p>
<p>​    3.将压缩包解压到任意盘符路径下,然后双击解压路径下bin目录下的studio.exe(32位)或sudio64.exe(64位)文件.运行程序即可弹出对话框</p>
<p>​    4.对话框询问用户是否导入Android Studio设置,若以前用过Android Studio且保存了定制该IDE的设置信息,则可以选择第一个单选按钮,并通过下面的文件浏览框选择Android Studio设置信息的存储位置;否则选择第二个单选按钮.</p>
<p>​    5.接下来便是引导用户从网络上下载Android SDK(可以单独下载),选择”Custom”按钮,然后单击”Finish”按钮.</p>
<p>​    6.单击”Finish”按钮,即可看到开始下载Android SDK的进度对话框.下载完成后单击”Finish”按钮即可完成Android Studio的安装.</p>
<p>​    由于Android Studio是基于Intellij IDEA的IDE工具,因此Android Studio中的Project(项目)的概念与Eclipse的Project概念不同,Android Studio的项目相当于Eclipse的WorkSpace(工作空间),Android Studio的Module(模块)才相当于Eclipse的项目–由此可见,Android Studio的项目相当于一个工作空间,一个工作空间可包含多个模块,每个模块对应一个Android项目.即Android Studio的项目可以包含多个Android项目(模块).</p>
<p>​    7.使用Android Studio时,还需要为Android Studio设置Android SDK的路径.若是Android SDK已下载完成,则单击”File”-&gt;”Other Settings”-&gt;”Default Project Structure”菜单,设置Android SDK的安装路径.</p>
<h2 id="1-2-3-安装运行-调试环境"><a href="#1-2-3-安装运行-调试环境" class="headerlink" title="1.2.3 安装运行,调试环境"></a>1.2.3 安装运行,调试环境</h2><p>​    Android程序必须在Android手机上运行,因此Android开发时必须准备相关的运行,调试环境.准备Android程序运行,调试环境有如下3中方式.</p>
<p>(1).条件允许,则优先考虑购买Android真机(其调试速度更快,效果更好).</p>
<p>(2).配置Android虚拟设备(即AVD).</p>
<p>(3).使用第三方提供的Android模拟器(如Genymotion模拟器).</p>
<p>​    具体步骤过程自行网上查阅,不再详细叙述.</p>
<h1 id="1-3-Android常用开发工具用法"><a href="#1-3-Android常用开发工具用法" class="headerlink" title="1.3 Android常用开发工具用法"></a>1.3 Android常用开发工具用法</h1><p>​    前面主要介绍了Android SDK的安装,运行,调试环境的搭建,以及Android开发环境Android Studio的安装,但这些只是最基本的知识,还必须掌握Android开发的大量辅助的工具.</p>
<h2 id="1-3-1-在命令行创建-删除和浏览AVD"><a href="#1-3-1-在命令行创建-删除和浏览AVD" class="headerlink" title="1.3.1 在命令行创建,删除和浏览AVD"></a>1.3.1 在命令行创建,删除和浏览AVD</h2><p>​    在命令行下管理AVD需借助android命令(位于Android SDK安装目录的tools子目录下),若直接执行android命令将会启动Android SDK管理器,除此之外,该命令还支持如下子命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">-list: 列出机器上所有已经安装的Android版本和AVD设备.</div><div class="line">-list avd: 列出机器上所有已经安装的AVD设备.</div><div class="line">-list target: 列出机器上所有已经安装的Android版本.</div><div class="line">-create avd: 创建一个AVD设备.</div><div class="line">-move ave: 移动或重命名一个AVD设备.</div><div class="line">-delete avd:删除一个AVD设备.</div><div class="line">-update avd: 升级一个AVD设备使之符合新的SDK环境.</div><div class="line">-create project: 创建一个新的Android项目.</div><div class="line">-update project: 更新一个已有的Android项目.</div><div class="line">-create test-project: 创建一个新的Android测试项目.</div><div class="line">-update test-project: 更新一个已有的Android测试项目.</div></pre></td></tr></table></figure>
<p>若希望查看当前系统上已经安装的Android版本及已经安装的AVD设备,则运行android llist或者 android list avd命令即可.</p>
<p>若要创建一个全新的AVD设备,可以执行如下命令:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">android create avd -n &lt;avd名称&gt; -t &lt;Android版本&gt; -b &lt;CPU架构&gt; -p &lt;AVD设备保存位置&gt; -s &lt;选择AVD皮肤&gt;</div></pre></td></tr></table></figure>
<p>在上面的create avd子命令中,只有-n和-t选项是必需的,其余-b,-p,-s选项都是可选的.若无-p选项,创建的AVD设备默认保存在%ANDROID_SDK_HOOME%/android/avd路径下.</p>
<h2 id="1-3-2-使用Android模拟器-Emulator"><a href="#1-3-2-使用Android模拟器-Emulator" class="headerlink" title="1.3.2 使用Android模拟器(Emulator)"></a>1.3.2 使用Android模拟器(Emulator)</h2><p>​    Android模拟器就是一个运行在电脑上的”虚拟手机”.在Android SDK 和AVD管理器中选择指定的AVD设备,然后单击”Start…”按钮就可以启动模拟器来运行Android系统.</p>
<p>​    在Android SDK安装目录的tools子目录下有一个emulator.exe(另外还有emulator-arm.exe.emulator-mips.exe,emulator-x86.exe),它们都是Android模拟器.</p>
<p>使用emulator.exe启动模拟器有两种方法.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">emulator -avd &lt;AVD名称&gt;</div></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">emulator -data &lt;镜像文件名称&gt;</div></pre></td></tr></table></figure>
<p>第一种用法是运行指定的AVD设备.第二种用法是直接使用指定的镜像文件来运行AVD.</p>
<h2 id="1-3-3-使用Monitor进行调试"><a href="#1-3-3-使用Monitor进行调试" class="headerlink" title="1.3.3 使用Monitor进行调试"></a>1.3.3 使用Monitor进行调试</h2><p>党Android应用在模拟器上运行时,Android提供了一个Monitor工具,该工具可以用于监视Android设备的运行.它是一个功能非常强大的调试环境,运行如下命令即可启动.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">monitor.bat</div></pre></td></tr></table></figure>
<p>实际上,Android Studio已经将Monitor集成进来.</p>
<h2 id="1-3-4-Android-Debug-Bridge-ADB-的用法"><a href="#1-3-4-Android-Debug-Bridge-ADB-的用法" class="headerlink" title="1.3.4 Android Debug Bridge (ADB)的用法"></a>1.3.4 Android Debug Bridge (ADB)的用法</h2><p>​    Android Debug Bridge (ADB)是一个功能非常强大的工具,它位于Android SDK安装目录的platform-tools子目录下. ADB工具既可以完成模拟器文件与电脑文件的相互复制,也可以安装APK应用,甚至可以直接切换到Android系统中执行Linux命令.</p>
<p>​    ADB工具的功能很多,此处仅对几个常用的命令略作说明.</p>
<h3 id="1-查看当前运行的模拟器"><a href="#1-查看当前运行的模拟器" class="headerlink" title="1.查看当前运行的模拟器"></a>1.查看当前运行的模拟器</h3><p>​    输入如下命令,即可查看当前运行的模拟器:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb devices</div></pre></td></tr></table></figure>
<h3 id="2-电脑与手机之间文件的相互复制"><a href="#2-电脑与手机之间文件的相互复制" class="headerlink" title="2.电脑与手机之间文件的相互复制"></a>2.电脑与手机之间文件的相互复制</h3><p>​    在默认情况下    ,ADB工具总是操作当前正在运行的模拟器.</p>
<p>​    若需要将电脑文件复制到模拟器中,则可以使用adb push命令:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb push d:\temp.txt /sdcard/</div></pre></td></tr></table></figure>
<p>​    若需要将模拟器中的文件复制到电脑,则可以使用adb pull命令:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb pull /sdcard/temp.txt d:\</div></pre></td></tr></table></figure>
<h3 id="3-启动模拟器的shell窗口"><a href="#3-启动模拟器的shell窗口" class="headerlink" title="3.启动模拟器的shell窗口"></a>3.启动模拟器的shell窗口</h3><p>​    Android平台是基于Linux的,有时开发者希望直接打开Android平台的shell窗口,这样就可以在该窗口内执行一些常用的Linux命令,如ls,mkdir,rm等.此时可以考虑使用adb shell命令:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb shell</div></pre></td></tr></table></figure>
<h3 id="4-安装-卸载APK程序"><a href="#4-安装-卸载APK程序" class="headerlink" title="4.安装,卸载APK程序"></a>4.安装,卸载APK程序</h3><p>​    APK程序就是Android程序的发布包,虽然我们使用Java开发了Android应用,但并不是直接将Java二进制文件复制到手机或者模拟器上即可,而是需要将Android应用打包成APK.</p>
<p>​    一旦将Android应用打包成APK包,接下来就可以通过ADB工具来安装,卸载APK程序了.</p>
<p>​    使用ADB安装APK程序的命令格式如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb install [-r] [-s] &lt;file&gt;</div></pre></td></tr></table></figure>
<p>​    上面的命令格式指定安装<file>代表的APK包,其中-r表示重新安装该APK包;-s表示将APK包安装到SD卡上–默认是将APK包安装到内部存储器上.</file></p>
<p>​    如果希望从Android系统中删除指定软件包,则可以使用如下命令:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb uninstall [-k] &lt;package&gt;</div></pre></td></tr></table></figure>
<p>​    上面的命令格式指定删除<package>代表的APK包,其中-k表示只删除该应用程序,但保留该应用程序的数据和缓存目录.</package></p>
<h2 id="1-3-5-使用mksdcard管理虚拟SD卡"><a href="#1-3-5-使用mksdcard管理虚拟SD卡" class="headerlink" title="1.3.5 使用mksdcard管理虚拟SD卡"></a>1.3.5 使用mksdcard管理虚拟SD卡</h2><p>​    正如前面在Android SDK和AVD管理器中所见到的,我们可以在创建AVD设备时创建一个虚拟SD卡.实际上还可以使用mksdcard命令来单独创建一个虚拟存储卡.</p>
<p>​    mksdcard命令的语法格式如下:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mksdcard [-l label] &lt;size&gt; &lt;file&gt;</div></pre></td></tr></table></figure>
<p>​    上面的命令格式中<size>指定虚拟SD卡的大小,<file>指定保存虚拟SD卡的文件镜像.</file></size></p>
<p>​    如果希望在启动模拟器时使用指定的虚拟SD卡,则在启动模拟器时增加-sdcard <file>选项,其中<file>代表虚拟SD卡的文件镜像.例如如下命令:</file></file></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">emulator -avd crazyit -sdcard d:\sdcard.img</div></pre></td></tr></table></figure>
<p>​    到此为止,我们已经成功地安装了Android SDK,配置Android开发环境,并且对Android相关开发工具都有了一个大致的了解.</p>
<p>​    接下来欢迎正式踏上Android应用学习开发之路~</p>
<p>注: 欢迎交流与学习,转载请注明出处 <a href="http://thychan.cn" target="_blank" rel="external">http://thychan.cn</a></p>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> Android </tag>
            
            <tag> Android学习笔记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java课题设计-MTDM]]></title>
      <url>/2016/12/31/Java%E8%AF%BE%E9%A2%98%E8%AE%BE%E8%AE%A1-MTDM/</url>
      <content type="html"><![CDATA[<h1 id="MTDM"><a href="#MTDM" class="headerlink" title="MTDM"></a>MTDM</h1><p>MTDM(Multi-threaded Download Manager)</p>
<ul>
<li>Author: ThyChan</li>
<li>Blog: <a href="http://thychan.cn" target="_blank" rel="external">http://thychan.cn</a></li>
<li>GitHub: <a href="https://github.com/thy-chan" target="_blank" rel="external">https://github.com/thy-chan</a></li>
<li>Email: cn_cx@foxmail.com</li>
<li>CodeType: Java</li>
<li>development environment:<br>​    OS: Win10 64bit<br>​    IDE: Intellij IDEA<br>​    Java version: JDK1.8.0_112<br>​</li>
</ul>
<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p>​    在我们平时使用互联网,获取资源时,最容易被忽视但又离不开的便是下载工具. 而现今市场上大部分人所使用的下载工具便是迅雷,百度云,QQ旋风,uTorrent,Internet Download Manager等等.而在使用这些工具的过程中, 应用开发商往往以利益优先而不是以用户体验优先,总是插入各种广告,或者VIP限制,其目标是将用户向<strong>「吸引眼球」</strong>而非<strong>「关心真正重要的事」</strong>的方向推进,从而脱离了下载工具的本质—-下载资源. 例如某些下载应用强制插入浏览器,插入各种广告以及对下载网速进行限制等等.</p>
<p>​    在自选Java课题时,曾想过很多题目,如五子棋,聊天客户端,音乐播放器,小游戏等等.但考虑到以上几点以及实用性后, 便决定选取多线程下载工具这一题目, 仅当一次学习和锻炼.</p>
<p>​    该下载工具是由Java语言开发,并基于面向对象理论, 采用图形化界面的软件.其中涉及到了多线程技术以及网络技术.故命名为多线程下载管理器(Multi-threaded Download Manager),后文简称<strong>MTDM</strong>. GUI界面设计略微参考了Internet Download Manager的GUI界面. 编码设计过程中参考了Java疯狂讲义.</p>
<h2 id="2-MTDM概述"><a href="#2-MTDM概述" class="headerlink" title="2. MTDM概述"></a>2. MTDM概述</h2><h3 id="2-1-分析设计"><a href="#2-1-分析设计" class="headerlink" title="2.1 分析设计"></a>2.1 分析设计</h3><p><strong>MTDM的GUI界面</strong>大致包括主界面,添加下载资源的界面.</p>
<ul>
<li>主界面拥有工具栏(新建,开始,暂停,删除,移除,关于),导航树(显示正在下载的资源,下载失败的资源和已下载完成的资源) ,下载列表以及资源信息列表</li>
</ul>
<ul>
<li>添加下载资源的界面有提示用户输入下载资源的地址链接, 存储到本地的路径,以及设置下载过程中的线程数.</li>
</ul>
<p><strong>MTDM所涉及的功能</strong>有创建任务,删除任务,开始任务,暂停任务,建立下载线程,对文件进行分割,合并.保存已下载资源的信息中用到对象的序列化与反序列化等.</p>
<p>主界面如下:</p>
<p><img src="\imgs\mtdm_imgs\mtdm.png" alt="mtdm"></p>
<h3 id="2-2-项目实现编码概述"><a href="#2-2-项目实现编码概述" class="headerlink" title="2.2 项目实现编码概述"></a>2.2 项目实现编码概述</h3><p>设计并编码实现见源码<a href="https://github.com/thy-chan/MTDM-Multithreaded-Download-Manager" target="_blank" rel="external">MTDM</a>,及注释</p>
<p>MTDM源码列表:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">MTDM(src)</div><div class="line">cn.thychan.mtdm				//包名</div><div class="line">--exception							//异常</div><div class="line">------URLException							//URL异常</div><div class="line">--info								//资源信息</div><div class="line">------Info									//资源信息</div><div class="line">--navigation					 	//导航树</div><div class="line">------DownloadingNode				 		//正在下载的节点</div><div class="line">------DownloadNode					 		//导航树的节点(接口)</div><div class="line">------FailNode						 		//下载失败的节点</div><div class="line">------FinishNode					 		//下载完成的节点</div><div class="line">------TaskNode						 		//任务节点</div><div class="line">--object							//对象</div><div class="line">------Part									//块对象</div><div class="line">------Resource								//资源对象</div><div class="line">--state								//状态</div><div class="line">------AbstractState							//抽象状态</div><div class="line">------Connecting							//正在连接中</div><div class="line">------Downloading							//正在下载</div><div class="line">------Failed								//下载失败</div><div class="line">------Finished								//下载完成</div><div class="line">------Pause									//暂停</div><div class="line">------TaskState								//资源状态接口</div><div class="line">--thread							//线程</div><div class="line">------DownloadHander						//用于处理文件的下载与继续下载</div><div class="line">------DownloadThread						//下载线程</div><div class="line">--ui								//用户界面</div><div class="line">------AboutDialog							//关于对话框</div><div class="line">------DownloadProgressBar					 //资源列表进度条</div><div class="line">------DownloadTable							//下载列表</div><div class="line">------DownloadTableCellRenderer				 //下载列表渲染器</div><div class="line">------DownloadTableModel					 //下载表格式数据模型</div><div class="line">------MainFrame								//主框架</div><div class="line">------NavigationTree						//导航树</div><div class="line">------NavigationTreeCellRender				 //导航树渲染器</div><div class="line">------NewTaskDialog							//新建下载任务对话框</div><div class="line">--util								//工具</div><div class="line">------DateUtil								//日期工具,用于格式化时间</div><div class="line">------FileUtil								//文件工具,文件相关的操作</div><div class="line">------ImageUtil								//图片工具,用于加载图片资源</div><div class="line">--ContextHolder						 //用于保存DownloadContext的唯一实例</div><div class="line">--DownloadContext					 //上下文对象,保存一些公共信息</div><div class="line">--Main								//Main方法,程序入口</div><div class="line"></div><div class="line">images						//图片资源</div><div class="line">--icon								//标题栏图标</div><div class="line">--nav								//导航树图标</div><div class="line">--state								//状态图标</div><div class="line">--tool								//工具栏图标</div><div class="line"></div><div class="line">META-INF					Build时用于生成Jar包</div></pre></td></tr></table></figure>
<h3 id="2-3-测试"><a href="#2-3-测试" class="headerlink" title="2.3 测试"></a>2.3 测试</h3><p>MTDM.jar已放置在项目文件的根目录下,只要拥有jre运行环境,便可以双击运行</p>
<p>简单测试如下:</p>
<p><img src="\imgs\mtdm_imgs\temp.gif" alt="temp"></p>
<p>注:该项目,源码,文档仅限于交流学习,禁止转发及用于其他目的!</p>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> Java </tag>
            
            <tag> 项目 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[TeamViewer安装使用详解]]></title>
      <url>/2016/12/23/TeamViewer%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>版本: TeamViewer 12.0.72356</p>
<p>环境: Windows版</p>
<p>压缩包: 安装包及工具(底部)</p>
<p><code>TeamViewer</code> – 远程支持、远程访问、在线协作和会议。TeamViewer是一个能在任何防火墙和NAT代理的后台用于穿透内网远程控制软件，用于实现远程支持、远程访问、远程管理、家庭办公及在线协作和会议。</p>
<p><code>TeamViewer破解补丁</code>一直由意大利大神 @DeltaFoX 专注制作，可破解为商业版、付费版、企业版，自动进入对应许可证通道，无免费版任何功能限制！无首次退出软件后订阅弹窗，无怀疑商业用途提示弹窗！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">注：@DeltaFoX的破解补丁只能搜索默认安装目录</div><div class="line">C:\Program Files\Teamviewer &amp; C:\Program Files\Program Files (x86)，</div><div class="line">如果想让破解补丁用于便携版，可装一次安装版，然后打完补丁后把下面三个文件：</div><div class="line">TeamViewer.exe、TeamViewer_Service.exe、TeamViewer_Desktop.exe </div><div class="line">复制出来替换到便携版即可！</div></pre></td></tr></table></figure>
<h2 id="1-补丁使用方法"><a href="#1-补丁使用方法" class="headerlink" title="1. 补丁使用方法"></a><strong>1. 补丁使用方法</strong></h2><p>(ps:首先使用<code>UninstallTool</code>卸载工具把TeamViewer卸载清除,因为它卸载应用的同时也会清除相关注册表以及相关文件,卸载比较干净. 当然,为了保险起见,卸载完成后再进行如下操作)</p>
<p>  1）完整卸载并删除现有TeamViewer安装过的版本</p>
<p>  2）删除：%AppData%\Teamviewer、%tmp%\TeamViewer</p>
<p>  3）删除：C:\Users\Administrator\AppData\Local\TeamViewer</p>
<p>  4）删除：HKCU\Software\TeamViewer、HKLM\SOFTWARE\TeamViewer</p>
<p>  5）下载Teamviewer对应版本，安装方式选<strong>个人/非商务用途</strong>，安装完毕后在计算机系统服务里找到TeamViewer这个服务，然后点击结束任务(<strong>提示,不要急着关闭窗口,等上几秒,然后TeamViewer进程会继续出现,再次结束任务即可.总共会出现3次</strong>). 最后打补丁(TeamViewer_12.0.72365_Patch_URET_v4.7.exe)即可！</p>
<p>具体步骤截图如下:</p>
<p><img src="\imgs\teamviewer\1.png" alt="1"><img src="\imgs\teamviewer\2.png" alt="2"></p>
<p><img src="\imgs\teamviewer\3.png" alt="3"></p>
<p><img src="\imgs\teamviewer\4.png" alt="4"></p>
<p><img src="\imgs\teamviewer\5.png" alt="5"></p>
<h2 id="2-Windows-下提示-‘许可证已过期、怀疑为商业用途’-解决方法"><a href="#2-Windows-下提示-‘许可证已过期、怀疑为商业用途’-解决方法" class="headerlink" title="2. Windows 下提示 ‘许可证已过期、怀疑为商业用途’ 解决方法"></a>2. Windows 下提示 ‘许可证已过期、怀疑为商业用途’ 解决方法</h2><p>(注: 若没出现这种问题就不用理会这一点,否则进行如下操作)</p>
<p>  1). 根据 补丁使用方法中的步骤，完全卸载Teamviewer 及删除所有数据</p>
<p>  2). 使用MAC修改器 修改连接外网网卡的 MAC 地址（如使用无线上网，则改无线网卡的 MAC地址），重启</p>
<p>​       电脑。（TMAC 修改神器见压缩包内）</p>
<p>  3). 重新安装 Teamviewer 即可自动更换 Teamviewer ID，就不会再提示许可证过期。</p>
<h2 id="3-TeamViewer-12-0-72365-官方简体中文版-完整版-便携版"><a href="#3-TeamViewer-12-0-72365-官方简体中文版-完整版-便携版" class="headerlink" title="3. TeamViewer 12.0.72365 官方简体中文版 完整版 / 便携版"></a>3. TeamViewer 12.0.72365 官方简体中文版 完整版 / 便携版</h2><p>​    <strong>关于官方完整版和便携版的区别</strong>  ：</p>
<p>​    <code>完整安装版</code>包含VPN驱动、远程打印驱动、Outlook会议插件，支持安装为系统服务，支持设置随机启动、设置无人    值守访问；</p>
<p>​    <code>便携版</code>则没有这些功能！另外便携版默认是不能保存设置的，如果需要保存设置，其实可以将目录下的TeamViewer.ini配置文件nosave=1改为0，即可使用设置无人值守访问功能，另外从完整版提取TeamViewer_Service.exe到便携版，也可以支持设置随机启动。</p>
<p>本文档会定期更新</p>
<p>压缩包: 暂不提供, 需要请留言留下Email</p>
]]></content>
      
        <categories>
            
            <category> 软件 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 软件 </tag>
            
            <tag> 工具 </tag>
            
            <tag> IT </tag>
            
            <tag> 远程 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[实力打脸：你真的是在忙吗？]]></title>
      <url>/2016/12/10/%E5%AE%9E%E5%8A%9B%E6%89%93%E8%84%B8%EF%BC%9A%E4%BD%A0%E7%9C%9F%E7%9A%84%E6%98%AF%E5%9C%A8%E5%BF%99%E5%90%97%EF%BC%9F/</url>
      <content type="html"><![CDATA[<p>信息泛滥的如今，你每天花费大量时间是在阅读精品还是垃圾信息？这支短片是为 Time Well Spent 项目所拍摄的，其目标是将科技产品和媒体向「关心真正重要的事」而非「吸引眼球」的方向推进。From Max Stossel</p>
<video width="640" height="360" controls><br><source src="http://uc-baobab.wdjcdn.com/1481106372161_11372_854x480.mp4?t=1481382128&k=e59d6e153a286a08"><br></video>






<p>注: 分享自开眼.</p>
]]></content>
      
        <categories>
            
            <category> 视频 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 生活 </tag>
            
            <tag> 开眼 </tag>
            
            <tag> 视频 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[操作系统课程设计分析报告-内核模块]]></title>
      <url>/2016/12/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A--%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97/</url>
      <content type="html"><![CDATA[<p>[TOC]</p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:</h2><p>•理解Linux内核模块的思想、方法，实现以下任意一个内核模块</p>
<p>–① 通过内核模块显示进程控制块信息:遍历进程树，输出进程PID和进程的可执行文件名</p>
<p>–② 设计一个内核模块，实现一个虚拟文件系统，该系统驻留在主存中，可以初始化和安装、卸载、创建、复制、追加、删除文件（目录）</p>
<p>•编写makefile，编译内核模块</p>
<p>•加载内核模块、测试命令</p>
<p>•卸载内核模块</p>
<p>本次课程设计所实现的是内核模块①.</p>
<p>实验环境: 虚拟机Ubuntu16.04.1LTS                 内核: Linux 4.4.0-36-generic x86_64</p>
<h2 id="模块代码"><a href="#模块代码" class="headerlink" title="模块代码"></a>模块代码</h2><p>传统计算机程序的运行生命周期相当简单。加载器为程序分配内存，然后加载程序和所需要的动态链接库。指令从一些入口开始执行（传统C/C++程序以main()函数作为入口），语句被执行，异常被抛出，动态内存被分配和释放，程序最终运行完成。当程序退出时，操作系统识别任何内存泄露，并释放到内存池。</p>
<p>内核模块不是应用程序，从一开始就没有main()函数。内核模块和普通应用程序的区别有：</p>
<ul>
<li>非顺序执行：内核模块使用初始化函数将自身注册并处理请求，初始化函数运行后就结束了。内核模块处理的请求在模块代码中定义。这和常用于图形用户界面（graphical-user interface，GUI）应用的事件驱动编程模型比较类似。</li>
<li>没有自动清理：任何由内核模块申请的内存，必须要模块卸载时手动释放，否则这些内存将无法使用，直到系统重启。</li>
<li>不要使用printf()函数：内核代码无法访问为Linux用户空间编写的库。内核模块运行在内核空间，它有自己独立的地址空间。内核空间和用户空间的接口被清晰的定义和控制。内核模块可以通过printk()函数输出信息，这些输出可以在用户空间查看到。</li>
<li>会被中断：内核模块一个概念上困难的地方在于他们可能会同时被多个程序/进程使用。构建内核模块时需要小心，以确保在发生中断的时候行为一致和正确。BeagleBone有一个单核处理器（目前为止），但是我们仍然需要考虑多进程同时访问对模块的影响。</li>
<li>更高级的执行特权：通常内核模块会比用户空间程序分配更多的CPU周期。这看上去是一个优势，然而需要特别注意内核模块不会影响到系统的综合性能。</li>
<li>无浮点支持：对用户空间应用，内核代码使用陷阱（trap）来实现整数到浮点模式的转换。然而在内核空间中这些陷阱难以使用。替代方案是手工保存和恢复浮点运算，这是最好的避免方式，并将处理留给用户空间代码。</li>
</ul>
<p>​    <em><u>listpro.c</u></em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;	        // 用于标记函数的宏，如__init、__exit</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;       // 加载内核模块到内核使用的核心头文件</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;       // 包含内核使用的类型、宏和函数</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sched.h&gt; 	    //task_struct在linux/sched.h文件里定义(在使用for_each_process宏的时需要引入这个头文件)</span></span></div><div class="line"></div><div class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);			<span class="comment">// 许可类型，它会影响到运行时行为</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> num=<span class="number">-1</span>;				<span class="comment">// 可加载内核模块参数，这里默认值设置为“-1”</span></div><div class="line">module_param(num, <span class="keyword">int</span>, S_IRUGO); <span class="comment">// 参数描述,int表示类型为整型，S_IRUGO表示该参数只读，无法修改</span></div><div class="line"></div><div class="line"><span class="comment">/** 模块加载函数 </span></div><div class="line"> *  @brief 可加载内核模块初始化函数</div><div class="line"> *  static关键字限制了该函数的可见范围为当前C文件。</div><div class="line"> *  @return 当执行成功返回0</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">list_init</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">task</span>, *<span class="title">p</span>;</span></div><div class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">pos</span>;</span></div><div class="line">  <span class="keyword">int</span> count=<span class="number">0</span>;</div><div class="line">  p = <span class="literal">NULL</span>;</div><div class="line">  pos = &amp;(init_task.tasks);</div><div class="line">  task = &amp;init_task;</div><div class="line">  printk(KERN_ALERT <span class="string">"\n========listpro_start=======\n"</span>);</div><div class="line">  printk(KERN_ALERT <span class="string">"PID\tCOMM\n"</span>);</div><div class="line">  <span class="keyword">if</span>(num!=<span class="number">-1</span>)			<span class="comment">//按用户指定的num打印进程控制块的数量</span></div><div class="line">    &#123;</div><div class="line">      p=list_entry(pos, struct task_struct, tasks);</div><div class="line">      <span class="keyword">for</span>(count=<span class="number">0</span>;count&lt;num;count++)</div><div class="line">      	&#123;</div><div class="line">	  printk(KERN_ALERT <span class="string">"%d\t%s\n"</span>, p-&gt;pid, p-&gt;comm);</div><div class="line">	  p=list_entry(p-&gt;tasks.next, struct task_struct, tasks);</div><div class="line">      	&#125;</div><div class="line">    &#125;</div><div class="line">  <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">      	for_each_process(task) <span class="comment">//默认打印所有的进程控制块</span></div><div class="line">		&#123;</div><div class="line">			count++;</div><div class="line">			printk(KERN_ALERT <span class="string">"%d\t%s\n"</span>, task-&gt;pid, task-&gt;comm);</div><div class="line">	   	&#125;</div><div class="line">	&#125;</div><div class="line">  printk(<span class="string">"已打印进程控制块的数量为%d!"</span>, count);</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/** 模块卸载函数</span></div><div class="line"> *  @brief 可加载内核模块清理函数和初始化函数类似，它是静态（static）的。</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">list_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">  printk(KERN_ALERT <span class="string">"Goodbye !"</span>);</div><div class="line">  printk(KERN_ALERT <span class="string">"\n=======listpro_end=======\n"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*模块注册函数*/</span></div><div class="line">module_init(list_init);</div><div class="line">module_exit(list_exit);</div></pre></td></tr></table></figure>
<p>除了列表1注释中描述的点之外，还有一些补充的点：</p>
<ul>
<li>第6行：语句MODULE_LICENSE(“GPL”)提供了（通过modinfo）该模块的许可条款，这让使用这个内核模块的用户能够确保在使用自由软件。由于内核是基于GPL发布的，许可的选择会影响内核处理模块的方式。如果对于非GPL代码选择“专有”许可，内核将会把模块标记为“污染的（tainted）”，并且显示警告。对GPL有非污染（non-tainted）的替代品，比如“GPL版本2”、“GPL和附加权利”、“BSD/GPL双许可”、“MIT/GPL双许可”和“MPL/GPL双许可”。更多内容可以查看linux/module.h头文件。</li>
<li>第7行：num（int类型）被声明为静态，并且被初始化为-1。在内核模块中应该避免使用全局变量，这比在应用程序编程时更加重要，因为全局变量被整个内核共享。应该使用static关键字来限制变量在模块中的作用域。如果必须使用全局变量，在变量名上增加前缀确保在模块中是唯一的。</li>
<li>第8行：module_param(name, type, permissions)宏有三个参数，名字（展示给用户的参数名和模块中的变量名）、类型（参数类型，即byte、int、uint、long、ulong、short、ushort、bool、逆布尔invbool或字符指针之一）和权限（S_IRUGO意味着运行用户/组/其他只有读权限）。</li>
<li>第15和49行：函数可以是任何名字（如list_init()和list_exit()），但是必须向module_init()和module_exit()宏传入相同的名字，如第56和57行。</li>
<li>第23行：printk()和printf()行数的使用方式类似，可以在内核模块代码的任何地方调用该函数。唯一重要却别是当调用printk()函数时，必须提供日志级别。日志级别在linux/kern_levels.h头文件中定义，它的值为KERN_EMERG、KERN_ALERT、KERN_CRIT、KERN_ERR、KERN_WARNING、KERN_NOTICE、KERN_INFO、KERN_DEBUG和KERN_DEFAULT之一。该头文件通过linux/printk.h文件被包含在linux/kernel.h头文件中。</li>
</ul>
<p>从本质上讲，当模块加载时，list_init()函数将会执行。当模块卸载时，list_exit()函数会被执行。</p>
<h2 id="构建模块代码"><a href="#构建模块代码" class="headerlink" title="构建模块代码"></a>构建模块代码</h2><p>构建内核模块需要Makefile文件，事实上是一个特殊的kbuild Makefile。构建本文示例的内核模块所需要的Makefile文件如下:</p>
<p>​    <em><u>Makefile</u></em></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">obj-m+=listpro.o</div><div class="line"></div><div class="line">LINUX_KERNEL :=/lib/modules/$(shell uname -r)/build</div><div class="line">all:</div><div class="line">	make -C $(LINUX_KERNEL) M=$(shell pwd) modules</div><div class="line">clean:</div><div class="line">	make -C $(LINUX_KERNEL) M=$(shell pwd) clean</div></pre></td></tr></table></figure>
<p>Makefile文件第一行被成为目标定义，它定义了需要构建的模块（listpro.o）。obj-m定义了可加载模块目标。当模块需要从多个目标文件构建时，语法会变得更加复杂，但这个Makefile文件对构建示例模块已经足够了。</p>
<p>Makefile文件中需要提醒的内容和普通Makefile文件类似。</p>
<ul>
<li>(shell uname -r)命令返回当前内核构建版本，这确保了一定程度的可移植性。</li>
<li>C选项在执行任何make任务前将目录切换到内核目录。</li>
<li>M=$(PWD)变量赋值告诉<strong>make</strong>命令实际工程文件存放位置。对于外部内核模块来说，modules目标是默认目标。另一种目标是modules_install，它将安装模块（<strong>make</strong>命令必须使用超级用户权限执行且需要提供模块安装路径）。</li>
</ul>
<p>一切都很顺利的情况下（如已经按照前文描述安装了Linux内核头文件），构建内核模块的过程是很简单快捷的。构建步骤如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">chan@ubuntu-vm:~/Desktop/kernel$ ls -l</div><div class="line">总用量 8</div><div class="line">-rw------- 1 chan chan 1162 12月  6 17:37 listpro.c</div><div class="line">-rw------- 1 chan chan  176 12月  6 17:56 Makefile</div><div class="line">chan@ubuntu-vm:~/Desktop/kernel$ make</div><div class="line">make -C /lib/modules/4.4.0-38-generic/build M=/home/chan/Desktop/kernel modules</div><div class="line">make[1]: Entering directory '/usr/src/linux-headers-4.4.0-38-generic'</div><div class="line">  CC [M]  /home/chan/Desktop/kernel/listpro.o</div><div class="line">  Building modules, stage 2.</div><div class="line">  MODPOST 1 modules</div><div class="line">  CC      /home/chan/Desktop/kernel/listpro.mod.o</div><div class="line">  LD [M]  /home/chan/Desktop/kernel/listpro.ko</div><div class="line">make[1]: Leaving directory '/usr/src/linux-headers-4.4.0-38-generic'</div><div class="line">chan@ubuntu-vm:~/Desktop/kernel$ ls -l</div><div class="line">总用量 36</div><div class="line">-rw------- 1 chan chan 1162 12月  6 17:37 listpro.c</div><div class="line">-rw-rw-r-- 1 chan chan 5664 12月  6 18:06 listpro.ko</div><div class="line">-rw-rw-r-- 1 chan chan  867 12月  6 18:06 listpro.mod.c</div><div class="line">-rw-rw-r-- 1 chan chan 3008 12月  6 18:06 listpro.mod.o</div><div class="line">-rw-rw-r-- 1 chan chan 4752 12月  6 18:06 listpro.o</div><div class="line">-rw------- 1 chan chan  176 12月  6 17:56 Makefile</div><div class="line">-rw-rw-r-- 1 chan chan   44 12月  6 18:06 modules.order</div><div class="line">-rw-rw-r-- 1 chan chan    0 12月  6 18:06 Module.symvers</div><div class="line">chan@ubuntu-vm:~/Desktop/kernel$</div></pre></td></tr></table></figure>
<p>现在，在构建目录中能够看见一个listpro.ko可加载内核模块，它的文件扩展名为.ko。</p>
<h5 id="测试可加载内核模块"><a href="#测试可加载内核模块" class="headerlink" title="测试可加载内核模块"></a>测试可加载内核模块</h5><p>该模块目前能够使用内核模块工具加载：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">chan@ubuntu-vm:~/Desktop/kernel$ sudo insmod listpro.ko</div><div class="line">[sudo] chan 的密码： </div><div class="line">chan@ubuntu-vm:~/Desktop/kernel$ lsmod</div><div class="line">Module                  Size  Used by</div><div class="line">listpro                16384  0</div><div class="line">vmw_vsock_vmci_transport    28672  1</div><div class="line">...</div><div class="line">scsi_transport_spi     32768  1 mptspi</div><div class="line">e1000                 135168  0</div><div class="line">pata_acpi              16384  0</div><div class="line">fjes                   28672  0</div><div class="line">chan@ubuntu-vm:~/Desktop/kernel$</div></pre></td></tr></table></figure>
<p>通过<strong>modinfo</strong>命令，可以获得模块的信息，这个命令能够识别出模块的描述、作者和定义的任何模块参数：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">chan@ubuntu-vm:~/Desktop/kernel$ modinfo listpro.ko</div><div class="line">filename:       /home/chan/Desktop/kernel/listpro.ko</div><div class="line">license:        GPL</div><div class="line">srcversion:     E5799ABCE0644B7E481E418</div><div class="line">depends:        </div><div class="line">vermagic:       4.4.0-38-generic SMP mod_unload modversions </div><div class="line">parm:           num:int</div><div class="line">chan@ubuntu-vm:~/Desktop/kernel$</div></pre></td></tr></table></figure>
<p>模块可以通过<strong>rmmod</strong>命令卸载：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">chan@ubuntu-vm:~/Desktop/kernel$ sudo rmmod listpro.ko</div><div class="line">chan@ubuntu-vm:~/Desktop/kernel$</div></pre></td></tr></table></figure>
<p>重复上述步骤，可以在内核日志(/var/log/kern.log)中看见使用printk()函数输出的结果。可加载内核模块加载和卸载时的输出(中间省略)，如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">Dec  6 18:08:12 ubuntu-vm kernel: [ 4428.437869] ========listpro_start=======</div><div class="line">Dec  6 18:08:12 ubuntu-vm kernel: [ 4428.437874] PID	COMM</div><div class="line">Dec  6 18:08:12 ubuntu-vm kernel: [ 4428.437877] 1	systemd</div><div class="line">Dec  6 18:08:12 ubuntu-vm kernel: [ 4428.437878] 2	kthreadd</div><div class="line">Dec  6 18:08:12 ubuntu-vm kernel: [ 4428.437880] 3	ksoftirqd/0</div><div class="line">Dec  6 18:08:12 ubuntu-vm kernel: [ 4428.437882] 5	kworker/0:0H</div><div class="line">Dec  6 18:08:12 ubuntu-vm kernel: [ 4428.437883] 7	rcu_sched</div><div class="line">...</div><div class="line">Dec  6 18:08:12 ubuntu-vm kernel: [ 4428.438353] 7461	kworker/2:0</div><div class="line">Dec  6 18:08:12 ubuntu-vm kernel: [ 4428.438355] 8161	kworker/1:1</div><div class="line">Dec  6 18:08:12 ubuntu-vm kernel: [ 4428.438356] 8167	sudo</div><div class="line">Dec  6 18:08:12 ubuntu-vm kernel: [ 4428.438358] 8168	insmod</div><div class="line">Dec  6 18:13:53 ubuntu-vm kernel: [ 4428.438359] 已打印进程控制块的数量为267!</div><div class="line">Dec  6 18:13:53 ubuntu-vm kernel: [ 4768.952967] Goodbye !&lt;1&gt;[ 4768.952971] </div><div class="line">Dec  6 18:13:53 ubuntu-vm kernel: [ 4768.952971] =======listpro_end=======</div></pre></td></tr></table></figure>
<h5 id="测试可加载内核模块自定义参数"><a href="#测试可加载内核模块自定义参数" class="headerlink" title="测试可加载内核模块自定义参数"></a>测试可加载内核模块自定义参数</h5><p>列表1中的代码同时包含了自定义参数，它允许在初始化时向内核模块传递参数。这个功能能够这样测试：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">chan@ubuntu-vm:~/Desktop/kernel$ sudo insmod listpro.ko num=7</div><div class="line">chan@ubuntu-vm:~/Desktop/kernel$</div></pre></td></tr></table></figure>
<p>这时如果查看<strong>/var/log/kern.log</strong>文件，会看见如下新增日志消息.</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Dec  6 18:18:07 ubuntu-vm kernel: [ 5023.185921] ========listpro_start=======</div><div class="line">Dec  6 18:18:07 ubuntu-vm kernel: [ 5023.185926] PID	COMM</div><div class="line">Dec  6 18:18:07 ubuntu-vm kernel: [ 5023.185928] 0	swapper/0</div><div class="line">Dec  6 18:18:07 ubuntu-vm kernel: [ 5023.185930] 1	systemd</div><div class="line">Dec  6 18:18:07 ubuntu-vm kernel: [ 5023.185931] 2	kthreadd</div><div class="line">Dec  6 18:18:07 ubuntu-vm kernel: [ 5023.185933] 3	ksoftirqd/0</div><div class="line">Dec  6 18:18:07 ubuntu-vm kernel: [ 5023.185934] 5	kworker/0:0H</div><div class="line">Dec  6 18:18:07 ubuntu-vm kernel: [ 5023.185935] 7	rcu_sched</div><div class="line">Dec  6 18:18:07 ubuntu-vm kernel: [ 5023.185937] 8	rcu_bh</div><div class="line">Dec  6 18:19:53 ubuntu-vm kernel: [ 5023.185938] 已打印进程控制块的数量为7!</div><div class="line">Dec  6 18:19:53 ubuntu-vm kernel: [ 5129.251625] Goodbye !&lt;1&gt;[ 5129.251629] </div><div class="line">Dec  6 18:19:53 ubuntu-vm kernel: [ 5129.251629] =======listpro_end=======</div></pre></td></tr></table></figure>
<p>模块被加载后，在/sys/module/目录下将出现以模块名命名的目录, 它提供了用户直接访问自定义参数状态的方式。例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">chan@ubuntu-vm:~/Desktop/kernel$ cd /sys/module/listpro/</div><div class="line">chan@ubuntu-vm:/sys/module/listpro$ ls -l</div><div class="line">总用量 0</div><div class="line">-r--r--r-- 1 root root 4096 12月  6 18:37 coresize</div><div class="line">drwxr-xr-x 2 root root    0 12月  6 18:37 holders</div><div class="line">-r--r--r-- 1 root root 4096 12月  6 18:37 initsize</div><div class="line">-r--r--r-- 1 root root 4096 12月  6 18:37 initstate</div><div class="line">drwxr-xr-x 2 root root    0 12月  6 18:37 notes</div><div class="line">drwxr-xr-x 2 root root    0 12月  6 18:37 parameters</div><div class="line">-r--r--r-- 1 root root 4096 12月  6 18:37 refcnt</div><div class="line">drwxr-xr-x 2 root root    0 12月  6 18:37 sections</div><div class="line">-r--r--r-- 1 root root 4096 12月  6 18:37 srcversion</div><div class="line">-r--r--r-- 1 root root 4096 12月  6 18:37 taint</div><div class="line">--w------- 1 root root 4096 12月  6 18:37 uevent</div><div class="line">chan@ubuntu-vm:/sys/module/listpro$</div></pre></td></tr></table></figure>
<p> 如果此模块存在perm不为0的命令行参数则在此模块的目录下将出现parameters目录，包含一系列以参数名命名的文件节点，这些文件的权限值等于perm，文件的内容为参数的值。自定义参数查看步骤为：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">chan@ubuntu-vm:/sys/module/listpro$ cd parameters</div><div class="line">chan@ubuntu-vm:/sys/module/listpro/parameters$ ls</div><div class="line">num</div><div class="line">chan@ubuntu-vm:/sys/module/listpro/parameters$ cat num</div><div class="line">-1</div><div class="line">chan@ubuntu-vm:/sys/module/listpro/parameters$</div></pre></td></tr></table></figure>
<p>这里num变量的状态可以查看到，并且读取这个值不需要超级用户权限。这是因为在定义内核参数的时候使用了S_IRUGO参数。这个值还能够设置为可写，但是模块代码中将会需要检测状态变化并依据变化做出响应。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在内核中，进程控制块被组织成多个双向链表，其中有一个双向链表包含所有的进程控制块，只需要访问该双向链表，就可以访问到所有进程控制块。</p>
<p>尽管这个模块功能比较简单，但通过这次课程设计，对可加载内核模块如何工作有了概要认识，大致了解了构建、加载、卸载了内核模块的方法，过程，同时了解了可加载内核模块自定义参数的设置。</p>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux内核模块]]></title>
      <url>/2016/12/03/Linux%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97/</url>
      <content type="html"><![CDATA[<h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><ul>
<li>内核模块概述</li>
<li>内核模块编程</li>
<li>内核模块机制的实现</li>
<li>实验<ul>
<li>通过内核模块显示进程控制块信息</li>
</ul>
</li>
</ul>
<h2 id="内核模块概述"><a href="#内核模块概述" class="headerlink" title="内核模块概述"></a>内核模块概述</h2><h3 id="内核模块"><a href="#内核模块" class="headerlink" title="内核模块"></a>内核模块</h3><ul>
<li><p>核心空间运行的一种目标文件，不能单独执行但其代码可在运行时链接到系统中作为内核的一部分执行或卸载。</p>
<p>–内核模块是一种特有的机制，它由一组函数和数据结构组成，可作为独立程序来编译。</p>
</li>
</ul>
<ul>
<li><p>当模块被安装时，它被链接到内核中。</p>
<p>–可在系统启动时进行模块安装，称静态加载；也可在系统运行时进行模块安装，称动态加载。</p>
</li>
</ul>
<h3 id="内核模块的主要作用"><a href="#内核模块的主要作用" class="headerlink" title="内核模块的主要作用"></a>内核模块的主要作用</h3><ul>
<li><p>动态地增加或减少内核功能。</p>
<p>– Loadable Kernel Modules（LKM）机制实现系统运行时对内核功能的动态扩充。</p>
<p>–许多情况下用户需要增加内核态程序。</p>
</li>
<li><p>提高单内核操作系统的灵活性与可扩展性。</p>
</li>
</ul>
<h3 id="Linux内核模块"><a href="#Linux内核模块" class="headerlink" title="Linux内核模块"></a>Linux内核模块</h3><ul>
<li><p>是一个编译好的、具有特定格式的独立目标文件，用户可通过系统提供的一组与模块相关的命令将内核模块加载进内核，当内核模块被加载后，它有以下特点：</p>
<p>– 与内核一起运行在相同的内核态和内核地址空间；</p>
<p>– 运行时具有与内核同样的特权级；</p>
<p>– 可方便地访问内核中的各种数据结构。</p>
</li>
<li><p>被载入内核的内核模块代码与静态编译进内核的代码没有区别，内核模块与内核中的其他模块交互只需采用函数调用。</p>
</li>
<li><p>内核模块可以很容易地被移出内核，当用户不再需要某功能模块时，可以将它从内核卸载以节省系统主存开销，配置十分灵活。</p>
</li>
<li><p>Linux内核需要对载入的内核模块进行管理，管理内核模块主要有两项任务：</p>
<p>–内核符号表管理；</p>
<p>–维护内核模块的引用计数。</p>
</li>
<li><p>内核将资源登记在符号表中，当内核模块被加载后，模块可以通过符号表使用内核中的资源。</p>
<p>–新模块载入内核时，系统把新模块提供的符号加进符号表中，这样新载入模块就可访问已装载模块提供的资源；</p>
</li>
<li><p>在卸载一个模块时，系统释放分配给该模块的所有系统资源,如内核主存区等, 同时将该模块提供的符号从符号表中删除。</p>
</li>
<li><p>由于所有内核模块在加载后都在同一地址空间中，内核模块之间可相互引用各自导出的符号，因此内核模块之间会产生依赖性：</p>
<p>– 如果A模块需要用到B模块导出的符号，而B模块没有被载入内核的话，A模块的加载就会出错；</p>
<p>– 如果有其他内核模块引用一个内核模块导出的符号，内核不允许该内核模块被卸载，内核模块的引用计数器便用来管理内核模块之间的依赖性。</p>
<p>– 如果一个内核模块被依赖，它的引用计数就会增加；当依赖减少时，相应的引用计数也会减少；一个内核模块只有在引用计数为0时候才允许被卸载。</p>
<p>​</p>
</li>
</ul>
<h2 id="内核模块编程"><a href="#内核模块编程" class="headerlink" title="内核模块编程"></a>内核模块编程</h2><h3 id="内核模块的结构"><a href="#内核模块的结构" class="headerlink" title="内核模块的结构"></a>内核模块的结构</h3><ul>
<li><p>编写“Hello,world!”内核模块</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function">MODULE <span class="title">LICENSE</span><span class="params">(<span class="string">"GPL"</span>)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hello_init</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">	printk(KERN_ALERT <span class="string">"Hello, world!\n"</span>);</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hello_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">	printk(KERN_ALERT <span class="string">"Goodbye, world!\n"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">module_init(hello_init);</div><div class="line">module_exit(hello_exit);</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="编译与加载"><a href="#编译与加载" class="headerlink" title="编译与加载"></a>编译与加载</h3><ul>
<li><p>在v2.6中，编译、链接后生成的内核模块后缀为.ko，</p>
</li>
<li><p>编译内核模块的makefile只需要下面一行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">obj-m:=hello.o</div></pre></td></tr></table></figure>
</li>
<li><p>生成的内核模块为hello.ko  </p>
</li>
<li><p>如果需要生成一个名为mymodule.ko的内核模块，并且该内核模块的源代码来源于modulesrc1.c和modulesrc2.c两个文件，makefile应该写成如下形式：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">obj-m:=mymodule.o</div><div class="line">module-objs:=modulesrc1.omodulesrc2.o</div></pre></td></tr></table></figure>
</li>
<li><p>如果用户采用makefile，在调用make命令时，需要将内核源代码所在目录作为一个参数传递给make命令。</p>
<p>–例如，如果v2.6的内核源代码位于/usr/src/linux-2.6下，用户模块源代码所在目录应该使用的make命令为：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Make -C /usr/src/linux-2.6 M=$(shell pwd) modules</div></pre></td></tr></table></figure>
</li>
<li><p>当编译好内核模块后，用户以超级用户身份就可将内核模块加载到内核中。</p>
</li>
<li><p>内核提供modutils软件包供用户对内核模块进行管理，该软件包安装后会在/sbin目录下安装insmod、rmmod、ksyms、lsmod、modprobe等实用程序。</p>
</li>
<li><p><code>insmod</code>命令:把需要载入的模块以目标代码形式加载进内核中，insmod自动调用modules_init( )函数中定义的过程运行，超级用户使用这个命令，其格式为：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash">insmod [path]–<span class="comment"># modulename</span></span></div></pre></td></tr></table></figure>
</li>
<li><p><code>rmmod</code>命令:将已经载入内核的模块从内核中卸载，自动调用modules_exit()函数中定义的过程运行，命令格式为</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash">rmmod [path]modulename</span></div></pre></td></tr></table></figure>
</li>
<li><p><code>ksyms</code>命令:用来显示内核符号和模块符号信息</p>
</li>
<li><p><code>lsmod</code>命令:显示已经载入内核的所有模块信息，包括被载入模块的模块名、大小和引用计数等，命令格式为：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash">lsmod</span></div></pre></td></tr></table></figure>
</li>
<li><p>对于本节中的hello模块，超级用户可用以下命令加载模块：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash">insmod hello.ko</span></div></pre></td></tr></table></figure>
<p>​</p>
</li>
</ul>
<h3 id="内核符号表"><a href="#内核符号表" class="headerlink" title="内核符号表"></a>内核符号表</h3><ul>
<li><p>是一个用来存放所有模块可以访问的符号，以及对应地址的特殊数据结构，模块的链接是将模块插入到内核的过程，模块所导出的符号都将成为内核符号表的一部分。</p>
</li>
<li><p>模块根据符号表从核心空间获取主存地址，从而确保在核心空间中正确地运行</p>
</li>
<li><p>在v2.6内核中，用户可从/proc/kallsyms中以文本方式读取内核符号表。</p>
</li>
<li><p>在v2.4内核中，缺省情况下，模块中的非静态全局变量及函数在模块加载后会输出到内核符号表，而在v2.6内核中，缺省情况下，这些符号不会被输出到内核符号表中。如果模块需要导出符号供其他模块使用，应该使用下面定义的两个宏：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">EXPORT_SYMBOL(name)</div><div class="line">EXPORT_SYMBOL_GPL(name)</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="初始化与清理函数"><a href="#初始化与清理函数" class="headerlink" title="初始化与清理函数"></a>初始化与清理函数</h3><ul>
<li><p>内核模块必须调用宏module_init与module_exit去注册初始化与清理函数。初始化函数通常定义为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">staticint __<span class="function">init <span class="title">init_func</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="comment">/* 初始化代码*/</span></div><div class="line">&#125;</div><div class="line">module_init(init_func);</div></pre></td></tr></table></figure>
</li>
<li><p>大部分模块都需要设置清理函数，该函数在模块卸载时被调用；如果一个模块没有定义清理函数，内核将不会允许它被卸载</p>
</li>
<li><p>模块在清理函数中需要将已申请的资源归还给系统。清理函数的定义为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function">staticvoid__exit <span class="title">exit_func</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line"><span class="comment">/* 清理代码*/</span></div><div class="line">&#125;</div><div class="line">module_exit(exit_func);</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="模块参数"><a href="#模块参数" class="headerlink" title="模块参数"></a>模块参数</h3><ul>
<li><p>用户在加载内核模块之前，可能需要传递参数给内核模块，与内核模块进行简单的交互</p>
</li>
<li><p>用户在insmod、modprobe命令中直接制定参数，命令形式为：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash">modprobe modname var=value</span></div><div class="line">//modname是要加载的模块名，var是要传递的变量名，value是传递的参数值。</div></pre></td></tr></table></figure>
</li>
<li><p>如果用户每次加载模块时传递的参数都相同，可以在/etc/modprobe.conf配置文件中预先写入参数，每次当模块被加载时，该配置文件中的参数就会被自动传递给模块。</p>
</li>
<li><p>模块要使用用户传递的参数，应该采用以下定义的宏：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">module_param(name,type,perm)</div><div class="line">module_param_array(name,type,nump,perm)</div></pre></td></tr></table></figure>
</li>
<li><p>type指明参数类型，模块直接支持的参数类型有：</p>
<p>– bool、invbool。bool为布尔型，invbool类型是颠倒的布尔类型，真值为false，假值为true。</p>
<p>– charp。字符串指针，指针指向用户传入的字符串。</p>
<p>– int、long、short、uint、ulong、ushort。基本变长整型值，以u开头的是无符号值。</p>
</li>
<li><p>perm为参数在sysfs文件系统中所对应的文件节点的属性。</p>
<p>模块被加载后，在/sys/module/目录下将出现以模块名命名的目录，如果此模块存在perm不为0的命令行参数则在此模块的目录下将出现parameters目录，包含一系列以参数名命名的文件节点，这些文件的权限值等于perm，文件的内容为参数的值。</p>
</li>
<li><p>nump为一个指针</p>
<p>该指针所指的变量保存输入的数组元素个数，当不需保存实际输入的数组元素个数时，该指针可设置为NULL。用户传递数组参数给模块时，使用逗号分隔输入的数组元素设定好nump后，如果用户传递的数组大小大于指定的nump，模块加载者会拒绝加载更多的数组元素。</p>
<p>​</p>
</li>
</ul>
<h2 id="内核模块机制的实现"><a href="#内核模块机制的实现" class="headerlink" title="内核模块机制的实现"></a>内核模块机制的实现</h2><h3 id="模块在内核中的表示"><a href="#模块在内核中的表示" class="headerlink" title="模块在内核中的表示"></a>模块在内核中的表示</h3><ul>
<li><p>内核在管理模块时使用的管理数据结构为structmodule，每一个内核模块被载入时，都要为其分配一个module对象，用一个双向链表把所有module对象组织起来，该链表的第1个元素为modules，开发者能够通过该元素依次访问内核中所有的module对象。</p>
</li>
<li><p>内核通过module对象主要是为了记录模块的依赖，并进行模块导出符号的管理。</p>
<p>|              类型              |     成员名      |       作用        |<br>| :————————–: | :———-: | :————-: |<br>|       enum module_stat       |     stat     |     模块当前状态      |<br>|          char [60]           |     nam      |       模块名       |<br>| const struct kernel_symbol <em> |     syms     |     导出符号数组      |<br>|         unsigned int         |   num_syms   |    导出符号数组大小     |<br>| const struct kernel_symbol </em> |   gpl_syms   |    GPL导出符号数组    |<br>|         unsigned int         | num_gpl_syms |   GPL导出符号数组大小   |<br>|      struct module_ref       | ref[NR_CPUS] | 每个CPU上对该模块的引用计数 |</p>
</li>
<li><p>stat成员表明当前模块的状态：MODULE_STATE_LIVE（处于激活状态）, MODULE STATE COMING（正在被初始化状态）, MODULE_STATE_GOING（正在被卸载状态）。</p>
</li>
<li><p>每个module对象都包含有多个引用计数，每个CPU都有一个引用计数。</p>
<p>– 每当模块被使用时，模块的引用计数加1；当模块不被使用时，模块的引用计数就会相应减少，仅当引用计数为0时，该模块才能被内核卸载。</p>
<p>– 例如，假设一个MS-DOS的文件系统被编译成为模块，当模块被加载后，模块的引用计数为0；当用户用mount命令挂上一个MS-DOS的分区后，模块引用计数就变成1；只有在用户umount后，引用计数变成0，该模块才能被卸载。</p>
</li>
<li><p>在内核代码段中，有3个段保存导出符号相关信息：</p>
<p>– <strong>kstrtab保存导出符号的名字；</strong></p>
<p>– ksymtab保存供所有模块使用的符号的地址；</p>
<p>– __ksymtab<em>gpl保存仅供GPL协议模块使用的符号的地址。</em></p>
<p>– 只有被EXPORT_SYMBOL和EXPORT<em>SYMBOL</em> GPL宏导出的符号才会被C编译器写入内核代码的相应段中，在加载内核时，会根据代码段中的符号信息创建符号表。</p>
</li>
</ul>
<h3 id="模块的加载与卸载"><a href="#模块的加载与卸载" class="headerlink" title="模块的加载与卸载"></a>模块的加载与卸载</h3><ul>
<li><p>模块的加载</p>
<p>– 用户通过insmod命令将模块载入内核，该命令的主要操作如下：</p>
<p>​    –从命令行读入要被载入的模块名。</p>
<p>​    –获得模块代码，它通常放在/lib/modules目录下。</p>
<p>​    –调用init_module( )函数，将包含模块代码缓存的指针、模块代码长度和用户参数传递给函数，该函 数将完成模块的加载工作。</p>
</li>
<li><p>模块的卸载</p>
<p>–用户可以通过rmmod命令将内核模块卸载，该命令所做的操作是：</p>
<p>​    1）读取要被卸载的模块名。</p>
<p>​    2）打开/proc/modules文件，查看该模块是否已经被卸载。</p>
<p>​    3）调用delete_module( )，把模块名传递给该函数，该函数将完成模块的卸载工作。</p>
</li>
</ul>
<h2 id="实验：内核模块显示进程控制块信息"><a href="#实验：内核模块显示进程控制块信息" class="headerlink" title="实验：内核模块显示进程控制块信息"></a>实验：内核模块显示进程控制块信息</h2><h3 id="实验说明"><a href="#实验说明" class="headerlink" title="实验说明"></a>实验说明</h3><ul>
<li>在内核中，所有进程控制块都被一个双向链表连接起来，该链表中的第1个进程控制块为init_task。</li>
<li>编写一个内核模块，模块接收用户传递的一个参数num，num指定要打印的进程控制块的数量；若用户不指定num或者num&lt;0，模块则打印所有进程控制块的信息。需要打印的进程控制块信息有：进程PID和进程的可执行文件名。</li>
</ul>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ul>
<li><p>定义模块参数</p>
<p>– 该模块需要接受用户传递的参数，在使用该参数之前，需要在代码中预先定义好该参数，该参数的类型设置为整型，在sysfs中的权限是只读的。定义的方法为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">staticintnum=<span class="number">-1</span>;</div><div class="line">module_param(num,<span class="keyword">int</span>,S_IRUGO);</div></pre></td></tr></table></figure>
<p> – 该参数的初始值被设置为-1。-1将作为打印所有进程控制块的标记，默认值为-1，意味着当用户不传入任何参数时，模块将打印所有的进程的信息。</p>
</li>
<li><p>访问进程控制块链表</p>
<p>– 在内核中，进程控制块被组织成多个双向链表，其中有一个双向链表包含所有的进程控制块，只需要访问该双向链表，就可以访问到所有进程控制块。Linux内核中几乎所有双向链表都采用相同的数据结构来实现，内核中定义list_head通用数据结构，其定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Struct  list_head&#123;</div><div class="line">        structlist_head*next, * prev;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
<li><p>访问进程控制块链表</p>
<p>– list head中，开发者可以通过内核提供的一组宏创建并操作一个双向链表，而该链表中元素的类型为该数据结构.</p>
</li>
<li><p>访问进程控制块链表</p>
<p>– 在进程控制块task struct中，包含一个名为tasks的成员，该成员的类型为list_head，通过该成员将进程控制块串成一个双向链表。Linux内核通过该成员将所有的进程都放入同一个双向链表。</p>
<p>– 为了访问包含list_head的数据结构，内核提供一个宏：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">list_entry(ptr,type,member);</div></pre></td></tr></table></figure>
</li>
<li><p>访问进程控制块链表</p>
<p>– 在该宏中，ptr是一个指向list head的指针，type是包含list_head的数据结构类型，而member是list_head在该数据结构中的成员名。例如，若一个进程控制块中的tasks的地址为p，为了访问该进程控制块，可以采用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">list_entry(p, structtask_struct,tasks) ；</div><div class="line"><span class="comment">//该宏便会返回该进程控制块的地址。</span></div></pre></td></tr></table></figure>
</li>
<li><p>访问进程控制块链表</p>
<p>– 如果得到一个进程控制块的地址p，开发者可以通过：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">list_entry(p-&gt;tasks.next,structtask_struct,tasks);</div><div class="line"><span class="comment">//访问该双向链表中的下一个进程控制块。</span></div></pre></td></tr></table></figure>
<p>– 第1个进程控制块为init_task，如果开发者发现下一个进程控制块为init_task 时，说明已经完整地遍历过所有进程控制块。</p>
</li>
<li><p>访问进程控制块链表</p>
<p>– 内核定义宏for_each_process用于遍历所有的进程控制块，开发者通过该宏就能将所有的进程控制块访问一遍，该宏展开的形式为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(p = &amp;init_task; (p = list_entry((p)-&gt;tasks.next,structtask_struct,tasks) !=&amp;init_task; )</div></pre></td></tr></table></figure>
</li>
<li><p>输出进程控制块信息</p>
<p>– 进程控制块中包含进程大部分信息，根据实验要求，模块需要打印进程的pid和可执行文件名，在进程控制块的数据结构中，成员pid为进程的PID，而成员comm包含进程的可执行文件名。在内核中，模块可以通过printk()内核函数将这些信息打印到系统日志中。</p>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深入浅出Java8 Lambda表达式]]></title>
      <url>/2016/11/26/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAJava8-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p><strong>摘要</strong>：此篇文章主要介绍 Java8 Lambda 表达式产生的背景和用法，以及 Lambda 表达式与匿名类的不同等。本文系 <a href="http://www.oneapm.com/index.html?utm_source=Community&amp;utm_medium=Article&amp;utm_term=lambda&amp;utm_campaign=NovArti&amp;from=matefinola" target="_blank" rel="external">OneAPM</a> 工程师编译整理。</p>
<p><a href="http://www.oneapm.com/ai/java.html?utm_source=Community&amp;utm_medium=Article&amp;utm_term=lambda&amp;utm_campaign=NovArti&amp;from=matefinola" target="_blank" rel="external">Java</a> 是一流的面向对象语言，除了部分简单数据类型，Java 中的一切都是对象，即使数组也是一种对象，每个类创建的实例也是对象。在 Java 中定义的函数或方法不可能完全独立，也不能将方法作为参数或返回一个方法给实例。</p>
<p>从 Swing 开始，我们总是通过匿名类给方法传递函数功能，以下是旧版的事件监听代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">someObject.addMouseListener(<span class="keyword">new</span> MouseAdapter() &#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mouseClicked</span><span class="params">(MouseEvent e)</span> </span>&#123;</div><div class="line">             </div><div class="line">            <span class="comment">//Event listener implementation goes here...</span></div><div class="line">       </div><div class="line">        &#125;</div><div class="line">    &#125;);</div></pre></td></tr></table></figure>
<p>在上面的例子里，为了给 Mouse 监听器添加自定义代码，我们定义了一个匿名内部类 MouseAdapter 并创建了它的对象，通过这种方式，我们将一些函数功能传给 addMouseListener 方法。</p>
<p>简而言之，在 Java 里将普通的方法或函数像参数一样传值并不简单，为此，Java 8 增加了一个语言级的新特性，名为 <strong>Lambda 表达式</strong>。</p>
<h2 id="为什么-Java-需要-Lambda-表达式？"><a href="#为什么-Java-需要-Lambda-表达式？" class="headerlink" title="为什么 Java 需要 Lambda 表达式？"></a>为什么 Java 需要 Lambda 表达式？</h2><p>如果忽视注解(Annotations)、泛型(Generics)等特性，自 Java 语言诞生时起，它的变化并不大。Java 一直都致力维护其对象至上的特征，在使用过 JavaScript 之类的函数式语言之后，Java 如何强调其面向对象的本质，以及源码层的数据类型如何严格变得更加清晰可感。其实，函数对 Java 而言并不重要，在 Java 的世界里，函数无法独立存在。</p>
<p><img src="https://segmentfault.com/image?src=http://news.oneapm.com/content/images/2015/11/xkcd-functional-1.png&amp;objectId=1190000004005428&amp;token=1f7dee2d88d595b052b3073282060278" alt="img"></p>
<p>在函数式编程语言中，函数是一等公民，它们可以独立存在，你可以将其赋值给一个变量，或将他们当做参数传给其他函数。JavaScript 是最典型的函数式编程语言。点击<a href="http://eloquentjavascript.net/chapter6.html" target="_blank" rel="external">此处</a>以及<a href="http://www.ibm.com/developerworks/library/wa-javascript/index.html" target="_blank" rel="external">此处</a>可以清楚了解 JavaScript 这种函数式语言的好处。函数式语言提供了一种强大的功能——闭包，相比于传统的编程方法有很多优势，闭包是一个可调用的对象，它记录了一些信息，这些信息来自于创建它的作用域。Java 现在提供的最接近闭包的概念便是 Lambda 表达式，虽然闭包与 Lambda 表达式之间存在显著差别，但至少 Lambda 表达式是闭包很好的替代者。</p>
<p>在 Steve Yegge 辛辣又幽默的<a href="http://steve-yegge.blogspot.com/2006/03/execution-in-kingdom-of-nouns.html" target="_blank" rel="external">博客文章</a>里，描绘了 Java 世界是如何严格地以名词为中心的，如果你还没看过，赶紧去读吧，写得非常风趣幽默，而且恰如其分地解释了为什么 Java 要引进 Lambda 表达式。</p>
<p>Lambda 表达式为 Java 添加了缺失的函数式编程特点，使我们能将函数当做一等公民看待。尽管不完全正确，我们很快就会见识到 Lambda 与闭包的不同之处，但是又无限地接近闭包。在支持一类函数的语言中，Lambda 表达式的类型将是函数。但是，在 Java 中，Lambda 表达式是对象，他们必须依附于一类特别的对象类型——函数式接口(functional interface)。我们会在后文详细介绍函数式接口。</p>
<p>Mario Fusco 的这篇思路清晰的<a href="http://java.dzone.com/articles/why-we-need-Lambda-expressions" target="_blank" rel="external">文章</a>介绍了为什么 Java 需要 Lambda 表达式。他解释了为什么现代编程语言必须包含闭包这类特性。</p>
<h2 id="Lambda-表达式简介"><a href="#Lambda-表达式简介" class="headerlink" title="Lambda 表达式简介"></a>Lambda 表达式简介</h2><p>Lambda 表达式是一种匿名函数(对 Java 而言这并不完全正确，但现在姑且这么认为)，简单地说，它是没有声明的方法，也即没有访问修饰符、返回值声明和名字。</p>
<p>你可以将其想做一种速记，在你需要使用某个方法的地方写上它。当某个方法只使用一次，而且定义很简短，使用这种速记替代之尤其有效，这样，你就不必在类中费力写声明与方法了。</p>
<p><img src="https://segmentfault.com/image?src=http://news.oneapm.com/content/images/2015/11/java-lambda-expression-1.png&amp;objectId=1190000004005428&amp;token=ed9eb8fd1ccc76338220b9c731f694a8" alt="img"></p>
<p>Java 中的 Lambda 表达式通常使用 <code>(argument) -&gt; (body)</code> 语法书写，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(arg1, arg2...) -&gt; &#123; body &#125;</div><div class="line"> </div><div class="line">(type1 arg1, type2 arg2...) -&gt; &#123; body &#125;</div></pre></td></tr></table></figure>
<p>以下是一些 Lambda 表达式的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">(<span class="keyword">int</span> a, <span class="keyword">int</span> b) -&gt; &#123;  <span class="keyword">return</span> a + b; &#125;</div><div class="line"> </div><div class="line">() -&gt; System.out.println(<span class="string">"Hello World"</span>);</div><div class="line"> </div><div class="line">(String s) -&gt; &#123; System.out.println(s); &#125;</div><div class="line"> </div><div class="line">() -&gt; <span class="number">42</span></div><div class="line"> </div><div class="line">() -&gt; &#123; <span class="keyword">return</span> <span class="number">3.1415</span> &#125;;</div></pre></td></tr></table></figure>
<h2 id="Lambda-表达式的结构"><a href="#Lambda-表达式的结构" class="headerlink" title="Lambda 表达式的结构"></a>Lambda 表达式的结构</h2><p>让我们了解一下 Lambda 表达式的结构。</p>
<ul>
<li>一个 Lambda 表达式可以有零个或多个参数</li>
<li>参数的类型既可以明确声明，也可以根据上下文来推断。例如：<code>(int a)</code>与<code>(a)</code>效果相同</li>
<li>所有参数需包含在圆括号内，参数之间用逗号相隔。例如：<code>(a, b)</code> 或 <code>(int a, int b)</code> 或 <code>(String a, int b, float c)</code></li>
<li>空圆括号代表参数集为空。例如：<code>() -&gt; 42</code></li>
<li>当只有一个参数，且其类型可推导时，圆括号（）可省略。例如：<code>a -&gt; return a*a</code></li>
<li>Lambda 表达式的主体可包含零条或多条语句</li>
<li>如果 Lambda 表达式的主体只有一条语句，花括号{}可省略。匿名函数的返回类型与该主体表达式一致</li>
<li>如果 Lambda 表达式的主体包含一条以上语句，则表达式必须包含在花括号{}中（形成代码块）。匿名函数的返回类型与代码块的返回类型一致，若没有返回则为空</li>
</ul>
<h2 id="什么是函数式接口"><a href="#什么是函数式接口" class="headerlink" title="什么是函数式接口"></a>什么是函数式接口</h2><p>在 Java 中，Marker（标记）类型的接口是一种没有方法或属性声明的接口，简单地说，marker 接口是空接口。相似地，函数式接口是只包含一个抽象方法声明的接口。</p>
<p><code>java.lang.Runnable</code> 就是一种函数式接口，在 Runnable 接口中只声明了一个方法 <code>void run()</code>，相似地，ActionListener 接口也是一种函数式接口，我们使用匿名内部类来实例化函数式接口的对象，有了 Lambda 表达式，这一方式可以得到简化。</p>
<p>每个 Lambda 表达式都能隐式地赋值给函数式接口，例如，我们可以通过 Lambda 表达式创建 Runnable 接口的引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Runnable r = () -&gt; System.out.println(<span class="string">"hello world"</span>);</div></pre></td></tr></table></figure>
<p>当不指明函数式接口时，编译器会自动解释这种转化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> Thread(</div><div class="line">   () -&gt; System.out.println(<span class="string">"hello world"</span>)</div><div class="line">).start();</div></pre></td></tr></table></figure>
<p>因此，在上面的代码中，编译器会自动推断：根据线程类的构造函数签名 <code>public Thread(Runnable r) { }</code>，将该 Lambda 表达式赋给 Runnable 接口。</p>
<p>以下是一些 Lambda 表达式及其函数式接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Consumer&lt;Integer&gt;  c = (<span class="keyword">int</span> x) -&gt; &#123; System.out.println(x) &#125;;</div><div class="line"> </div><div class="line">BiConsumer&lt;Integer, String&gt; b = (Integer x, String y) -&gt; System.out.println(x + <span class="string">" : "</span> + y);</div><div class="line"> </div><div class="line">Predicate&lt;String&gt; p = (String s) -&gt; &#123; s == <span class="keyword">null</span> &#125;;</div></pre></td></tr></table></figure>
<p><a href="http://download.java.net/jdk8/docs/api/java/lang/FunctionalInterface.html" target="_blank" rel="external">@FunctionalInterface</a> 是 Java 8 新加入的一种接口，用于指明该接口类型声明是根据 Java 语言规范定义的函数式接口。Java 8 还声明了一些 Lambda 表达式可以使用的函数式接口，当你注释的接口不是有效的函数式接口时，可以使用 @FunctionalInterface 解决编译层面的错误。</p>
<p>以下是一种自定义的函数式接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@FunctionalInterface</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WorkerInterface</span> </span>&#123;</div><div class="line"> </div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomeWork</span><span class="params">()</span></span>;</div><div class="line"> </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>根据定义，函数式接口只能有一个抽象方法，如果你尝试添加第二个抽象方法，将抛出编译时错误。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@FunctionalInterface</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WorkerInterface</span> </span>&#123;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomeWork</span><span class="params">()</span></span>;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomeMoreWork</span><span class="params">()</span></span>;</div><div class="line"> </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>错误：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Unexpected <span class="meta">@FunctionalInterface</span> annotation </div><div class="line">    <span class="meta">@FunctionalInterface</span> ^ WorkerInterface is not a functional <span class="class"><span class="keyword">interface</span> <span class="title">multiple</span> </span></div><div class="line">    <span class="title">non</span>-<span class="title">overriding</span> <span class="title">abstract</span> <span class="title">methods</span> <span class="title">found</span> <span class="title">in</span> <span class="title">interface</span> <span class="title">WorkerInterface</span> 1 <span class="title">error</span></div></pre></td></tr></table></figure>
<p>函数式接口定义好后，我们可以在 API 中使用它，同时利用 Lambda 表达式。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">//定义一个函数式接口</span></div><div class="line"><span class="meta">@FunctionalInterface</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WorkerInterface</span> </span>&#123;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomeWork</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkerInterfaceTest</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(WorkerInterface worker)</span> </span>&#123;</div><div class="line">    worker.doSomeWork();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">//invoke doSomeWork using Annonymous class</span></div><div class="line">    execute(<span class="keyword">new</span> WorkerInterface() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomeWork</span><span class="params">()</span> </span>&#123;</div><div class="line">            System.out.println(<span class="string">"Worker invoked using Anonymous class"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line"> </div><div class="line">    <span class="comment">//invoke doSomeWork using Lambda expression </span></div><div class="line">    execute( () -&gt; System.out.println(<span class="string">"Worker invoked using Lambda expression"</span>) );</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Worker invoked using Anonymous <span class="class"><span class="keyword">class</span> </span></div><div class="line"><span class="title">Worker</span> <span class="title">invoked</span> <span class="title">using</span> <span class="title">Lambda</span> <span class="title">expression</span></div></pre></td></tr></table></figure>
<p>这上面的例子里，我们创建了自定义的函数式接口并与 Lambda 表达式一起使用。execute() 方法现在可以将 Lambda 表达式作为参数。</p>
<h2 id="Lambda-表达式举例"><a href="#Lambda-表达式举例" class="headerlink" title="Lambda 表达式举例"></a>Lambda 表达式举例</h2><p>学习 Lambda 表达式的最好方式是学习例子。</p>
<p>线程可以通过以下方法初始化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//旧方法:</span></div><div class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    System.out.println(<span class="string">"Hello from thread"</span>);</div><div class="line">&#125;</div><div class="line">&#125;).start();</div><div class="line"></div><div class="line"><span class="comment">//新方法:</span></div><div class="line"><span class="keyword">new</span> Thread(</div><div class="line">() -&gt; System.out.println(<span class="string">"Hello from thread"</span>)</div><div class="line">).start();</div></pre></td></tr></table></figure>
<p>事件处理可以使用 Java 8 的 Lambda 表达式解决。下面的代码中，我们将使用新旧两种方式向一个 UI 组件添加 ActionListener：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">  <span class="comment">//Old way:</span></div><div class="line">button.addActionListener(<span class="keyword">new</span> ActionListener() &#123;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span> </span>&#123;</div><div class="line">    System.out.println(<span class="string">"The button was clicked using old fashion code!"</span>);</div><div class="line">&#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">//New way:</span></div><div class="line">button.addActionListener( (e) -&gt; &#123;</div><div class="line">    System.out.println(<span class="string">"The button was clicked. From Lambda expressions !"</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>以下代码的作用是打印出给定数组中的所有元素。注意，使用 Lambda 表达式的方法不止一种。在下面的例子中，我们先是用常用的箭头语法创建 Lambda 表达式，之后，使用 Java 8 全新的双冒号(::)操作符将一个常规方法转化为 Lambda 表达式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Old way:</span></div><div class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>);</div><div class="line"><span class="keyword">for</span>(Integer n: list) &#123;</div><div class="line">   System.out.println(n);</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">//New way:</span></div><div class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>);</div><div class="line">list.forEach(n -&gt; System.out.println(n));</div><div class="line"> </div><div class="line"> </div><div class="line"><span class="comment">//or we can use :: double colon operator in Java 8</span></div><div class="line">list.forEach(System.out::println);</div></pre></td></tr></table></figure>
<p>在下面的例子中，我们使用断言(Predicate)函数式接口创建一个测试，并打印所有通过测试的元素，这样，你就可以使用 Lambda 表达式规定一些逻辑，并以此为基础有所作为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Arrays;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"><span class="keyword">import</span> java.util.function.Predicate;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] a)</span>  </span>&#123;</div><div class="line"></div><div class="line">    List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>);</div><div class="line"></div><div class="line">    System.out.println(<span class="string">"Print all numbers:"</span>);</div><div class="line">    evaluate(list, (n)-&gt;<span class="keyword">true</span>);</div><div class="line"></div><div class="line">    System.out.println(<span class="string">"Print no numbers:"</span>);</div><div class="line">    evaluate(list, (n)-&gt;<span class="keyword">false</span>);</div><div class="line"></div><div class="line">    System.out.println(<span class="string">"Print even numbers:"</span>);</div><div class="line">    evaluate(list, (n)-&gt; n%<span class="number">2</span> == <span class="number">0</span> );</div><div class="line"></div><div class="line">    System.out.println(<span class="string">"Print odd numbers:"</span>);</div><div class="line">    evaluate(list, (n)-&gt; n%<span class="number">2</span> == <span class="number">1</span> );</div><div class="line"></div><div class="line">    System.out.println(<span class="string">"Print numbers greater than 5:"</span>);</div><div class="line">    evaluate(list, (n)-&gt; n &gt; <span class="number">5</span> );</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">evaluate</span><span class="params">(List&lt;Integer&gt; list, Predicate&lt;Integer&gt; predicate)</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span>(Integer n: list)  &#123;</div><div class="line">        <span class="keyword">if</span>(predicate.test(n)) &#123;</div><div class="line">            System.out.println(n + <span class="string">" "</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Print all numbers: <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> </div><div class="line">Print no numbers: </div><div class="line">Print even numbers: <span class="number">2</span> <span class="number">4</span> <span class="number">6</span> </div><div class="line">Print odd numbers: <span class="number">1</span> <span class="number">3</span> <span class="number">5</span> <span class="number">7</span> </div><div class="line">Print numbers greater than <span class="number">5</span>: <span class="number">6</span> <span class="number">7</span></div></pre></td></tr></table></figure>
<p>下面的例子使用 Lambda 表达式打印数值中每个元素的平方，注意我们使用了 .stream() 方法将常规数组转化为流。Java 8 增加了一些超棒的流 APIs。<a href="http://download.java.net/jdk8/docs/api/java/util/stream/Stream.html" target="_blank" rel="external">java.util.stream.Stream</a> 接口包含许多有用的方法，能结合 Lambda 表达式产生神奇的效果。我们将 Lambda 表达式 <code>x -&gt; x*x</code> 传给 map() 方法，该方法会作用于流中的所有元素。之后，我们使用 forEach 方法打印数据中的所有元素：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Old way:</span></div><div class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>);</div><div class="line"><span class="keyword">for</span>(Integer n : list) &#123;</div><div class="line">    <span class="keyword">int</span> x = n * n;</div><div class="line">    System.out.println(x);</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">//New way:</span></div><div class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>);</div><div class="line">list.stream().map((x) -&gt; x*x).forEach(System.out::println);</div></pre></td></tr></table></figure>
<p>下面的例子会计算给定数值中每个元素平方后的总和。请注意，Lambda 表达式只用一条语句就能达到此功能，这也是 MapReduce 的一个初级例子。我们使用 map() 给每个元素求平方，再使用 reduce() 将所有元素计入一个数值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Old way:</span></div><div class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>);</div><div class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line"><span class="keyword">for</span>(Integer n : list) &#123;</div><div class="line">    <span class="keyword">int</span> x = n * n;</div><div class="line">    sum = sum + x;</div><div class="line">&#125;</div><div class="line">System.out.println(sum);</div><div class="line"> </div><div class="line"><span class="comment">//New way:</span></div><div class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>);</div><div class="line"><span class="keyword">int</span> sum = list.stream().map(x -&gt; x*x).reduce((x,y) -&gt; x + y).get();</div><div class="line">System.out.println(sum);</div></pre></td></tr></table></figure>
<h2 id="Lambda-表达式与匿名类的区别"><a href="#Lambda-表达式与匿名类的区别" class="headerlink" title="Lambda 表达式与匿名类的区别"></a>Lambda 表达式与匿名类的区别</h2><p>使用匿名类与 Lambda 表达式的一大区别在于关键词的使用。对于匿名类，关键词 <code>this</code> 解读为匿名类，而对于 Lambda 表达式，关键词 <code>this</code> 解读为写就 Lambda 的外部类。</p>
<p>Lambda 表达式与匿名类的另一不同在于两者的编译方法。Java 编译器编译 Lambda 表达式并将他们转化为类里面的私有函数，它使用 Java 7 中新加的 <code>invokedynamic</code> 指令动态绑定该方法，关于 Java 如何将 Lambda 表达式编译为字节码，Tal Weiss 写了一篇<a href="http://www.takipiblog.com/2014/01/16/compiling-Lambda-expressions-scala-vs-java-8/" target="_blank" rel="external">很好的文章</a>。</p>
<h2 id="到此为止啦，亲们！"><a href="#到此为止啦，亲们！" class="headerlink" title="到此为止啦，亲们！"></a>到此为止啦，亲们！</h2><p>Mark Reinhold，甲骨文的首席架构师，将 Lambda 表达式<a href="https://blogs.oracle.com/javaone/entry/the_javaone_2013_technical_keynote" target="_blank" rel="external">描述</a>为该编程模型最大的提升——比泛型(generics)还强大。事实的确如此，Lambda 表达式赋予了 Java 程序员相较于其他函数式编程语言缺失的特性，结合虚拟扩展方法之类的特性，Lambda 表达式能写出一些极好的代码。</p>
<p>希望这篇文章能让您对 <a href="http://www.oneapm.com/ai/java.html?utm_source=Community&amp;utm_medium=Article&amp;utm_term=lambda&amp;utm_campaign=NovArti&amp;from=matefinola" target="_blank" rel="external">Java 8</a> 的新特性所有了解。</p>
<p><strong>OneAPM for Java 能够深入到所有 Java 应用内部完成应用性能管理和监控，包括代码级别性能问题的可见性、性能瓶颈的快速识别与追溯、真实用户体验监控、服务器监控和端到端的应用性能管理。</strong></p>
<p>注: 该文章转载自:<a href="http://viralpatel.net/blogs/Lambda-expressions-java-tutorial/" target="_blank" rel="external">http://viralpatel.net/blogs/Lambda-expressions-java-tutorial/</a>?</p>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> java </tag>
            
            <tag> 函数式编程 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java8新特性之lambda函数式编程]]></title>
      <url>/2016/11/26/Java8%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8Blambda%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</url>
      <content type="html"><![CDATA[<blockquote>
<p>Java8引入了与此前完全不同的函数式编程方法，通过Lambda表达式和StreamAPI来为Java下的函数式编程提供动力。本文是Java8新特性的第一篇，旨在阐释函数式编程的本义，更在展示Java是如何通过新特性实现函数式编程的。</p>
<p>最近在读这本图灵的新书：<em>Java 8 in Action</em> ，本书作者的目的在于向Java程序员介绍Java8带来的新特性，鼓励使用新特性来完成更简洁有力的Java编程。本系列的文章的主要思路也来源于本书。</p>
</blockquote>
<p><img src="https://segmentfault.com/img/remote/1460000007540815?w=753&amp;h=941" alt="img"></p>
<h2 id="到底什么是函数式编程呢？"><a href="#到底什么是函数式编程呢？" class="headerlink" title="到底什么是函数式编程呢？"></a>到底什么是函数式编程呢？</h2><p>函数式编程并不是一个新概念，诸如Haskell这样的学院派编程语言就是以函数式编程为根基的，JVM平台上更彻底的采用函数式编程思维的更是以Scala为代表，因此函数式编程确实不是什么新概念。<br>下面来谈谈命令式编程和函数式编程。<br>什么是命令式编程呢？很容易理解，就是一条条的命令明明白白地告诉计算机，计算机依照这些这些明确的命令一步步地执行下去就好了，从汇编到C，这样的命令式编程语言无非都是在模仿计算机的机器指令的下达，明确地在每一句命令里面告诉计算机每一步需要怎么申请内存（对象变量）、怎么跳转到下一句命令（流转），即便后来的为面向对象编程思维而生的编程语言，比如Java，也仍然未走出这个范式，在每个类的对象执行具体的方法时也是按照这种“对象变量-流转”的模式在运行的。在这个模式下，我们会经常发现程序编写可能会经常限于冗长的“非关键”语句，大量的无用命令只是为了照顾语言本身的规则：比如所谓的面向接口编程最终变成了定义了一组一组的interface、interfaceImpl。<br>函数式编程则试图从编程范式的高度提高代码的抽象表达能力。命令式编程语言把“对象变量”和“流转”当作一等公民，而函数式编程在此基础上加入了“策略变量”这一新的一等公民。策略是什么呢？策略就是函数，函数本身是可以作为变量进行传递的。在以往的编程范式里，策略要被使用时通常是被调用，所以策略的使用必须通过承载策略的类或对象这样的对象变量，而函数式编程里面，我们可以直接使用策略对象来随意传递，省去了这些不必要的无用命令。<br>Java8作为一个新特性版本，在保留原有的Java纯面向对象特性之外，在容易理解的范围内引入了函数式编程方式。</p>
<h2 id="引入策略：策略何以作为变量？"><a href="#引入策略：策略何以作为变量？" class="headerlink" title="引入策略：策略何以作为变量？"></a>引入策略：策略何以作为变量？</h2><p>我们有这样的一个引入的例子：我们有一堆颜色和重量不定的苹果，这些苹果需要经过我们的一道程序，这道程序可以把这堆苹果中的红苹果取出来。怎样编写程序来选出红苹果呢？</p>
<p>首先我们定义苹果Apple类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Apple</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> String color;</div><div class="line">    <span class="keyword">private</span> Integer weight;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getColor</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> color;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setColor</span><span class="params">(String color)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.color = color;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getWeight</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> weight;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWeight</span><span class="params">(Integer weight)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.weight = weight;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Apple</span><span class="params">(String color, Integer weight)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.color = color;</div><div class="line">        <span class="keyword">this</span>.weight = weight;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>添加我们的一堆颜色和重量随机的苹果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        ArrayList&lt;Apple&gt; apples = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        Random weightRandom = <span class="keyword">new</span> Random();</div><div class="line">        Random colorRandom = <span class="keyword">new</span> Random();</div><div class="line">        String[] colors = &#123;<span class="string">"red"</span>,<span class="string">"green"</span>,<span class="string">"yellow"</span>&#125;;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</div><div class="line">            apples.add(<span class="keyword">new</span> Apple(colors[colorRandom.nextInt(<span class="number">3</span>)],weightRandom.nextInt(<span class="number">200</span>)));</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="纯命令式的思路："><a href="#纯命令式的思路：" class="headerlink" title="纯命令式的思路："></a>纯命令式的思路：</h3><p>如果我们使用传统的命令式的编程方法，这个从苹果堆中筛选红苹果的方法会这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Apple&gt; <span class="title">redAppleFilter</span><span class="params">(List&lt;Apple&gt; apples)</span></span>&#123;</div><div class="line">        List&lt;Apple&gt; redApples = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">for</span> (Apple apple:</div><div class="line">             apples) &#123;</div><div class="line">            <span class="keyword">if</span>(<span class="string">"red"</span>.equals(apple.getColor()))&#123;</div><div class="line">                redApples.add(apple);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> redApples;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">List&lt;Apple&gt; redApples = redAppleFilter(apples);</div></pre></td></tr></table></figure>
<p>如果这个时候我们变更需求了，比如我们不筛选红苹果了，要绿苹果了，怎么办呢？就得再定义一个从苹果堆中筛选绿苹果的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Apple&gt; <span class="title">greenAppleFilter</span><span class="params">(List&lt;Apple&gt; apples)</span></span>&#123;</div><div class="line">        List&lt;Apple&gt; greenApples = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">for</span> (Apple apple:</div><div class="line">             apples) &#123;</div><div class="line">            <span class="keyword">if</span>(<span class="string">"green"</span>.equals(apple.getColor()))&#123;</div><div class="line">                greenApples.add(apple);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> greenApples;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">List&lt;Apple&gt; greenApples = greenAppleFilter(apples);</div></pre></td></tr></table></figure>
<h3 id="面向对象的编程方法："><a href="#面向对象的编程方法：" class="headerlink" title="面向对象的编程方法："></a>面向对象的编程方法：</h3><p>使用为抽象操作而生的接口：接口只定义抽象的方法，具体的方法实现可以有不同的类来实现。如果把这些操作放到继承了一般筛选器的不同筛选方法的筛选器中去就会有一个典型的面向对象式的解决方案了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">AppleFilter</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;Apple&gt; <span class="title">filterByRules</span><span class="params">(List&lt;Apple&gt; apples)</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RedAppleFilter</span> <span class="keyword">implements</span> <span class="title">AppleFilter</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;Apple&gt; <span class="title">filterByRules</span><span class="params">(List&lt;Apple&gt; apples)</span> </span>&#123;</div><div class="line">        List&lt;Apple&gt; redApples = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">for</span> (Apple apple:</div><div class="line">                apples) &#123;</div><div class="line">            <span class="keyword">if</span>(<span class="string">"red"</span>.equals(apple.getColor()))&#123;</div><div class="line">                redApples.add(apple);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> redApples;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">GreenAppleFilter</span> <span class="keyword">implements</span> <span class="title">AppleFilter</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;Apple&gt; <span class="title">filterByRules</span><span class="params">(List&lt;Apple&gt; apples)</span> </span>&#123;</div><div class="line">        List&lt;Apple&gt; greenApples = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">for</span> (Apple apple:</div><div class="line">                apples) &#123;</div><div class="line">            <span class="keyword">if</span>(<span class="string">"green"</span>.equals(apple.getColor()))&#123;</div><div class="line">                greenApples.add(apple);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> greenApples;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="面向对象的抽象层级问题"><a href="#面向对象的抽象层级问题" class="headerlink" title="面向对象的抽象层级问题"></a>面向对象的抽象层级问题</h3><p>我们发现虽然使用了面向对象的编程方法虽然可以使得逻辑结构更为清晰：子类苹果筛选器实现了一般苹果筛选器的抽象方法，但仍然会有大量的代码是出现多次的。这就是典型的坏代码的味道，重复编写了两个基本一样的代码，所以我们要怎么修改才能使得代码应对变化的需求呢，比如可以应对筛选其他颜色的苹果，不要某些颜色的苹果，可以筛选某些重量范围的苹果等等，而不是每个确定的筛选都需要编写独立且基本逻辑相同的代码呢？</p>
<p>我们来看一下重复的代码究竟是哪些：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">List&lt;Apple&gt; greenApples = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">   <span class="keyword">for</span> (Apple apple:</div><div class="line">           apples) &#123;</div><div class="line">       ... ...</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> greenApples;</div></pre></td></tr></table></figure>
<p>不重复的代码有哪些：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(<span class="string">"green"</span>.equals(apple.getColor()))&#123;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其实对于循环列表这部分是对筛选这一逻辑的公用代码，而真正不同的是筛选的具体逻辑：根据红色筛选、绿色筛选等等。</p>
<p>而造成现在局面的原因就在于仅仅对大的筛选方法的实现的抽象层级太低了，所以就会编写太多的代码，如果筛选的抽象层级定位到筛选策略这一级就会大大提升代码的抽象能力。</p>
<h3 id="传递策略对象"><a href="#传递策略对象" class="headerlink" title="传递策略对象"></a>传递策略对象</h3><p>所谓策略的范围就是我们上面找到的这个“不重复的代码”：在这个问题里面就是什么样的苹果是可以经过筛选的。所以我们需要的这个策略就是用于确定什么样的苹果是可以被选出来的。我们定义一个这样的接口：给一个苹果用于判断，在test方法里对这个苹果进行检测，然后给出是否被选出的结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">AppleTester</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">test</span><span class="params">(Apple apple)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>比如我们可以通过实现上述接口，重写这个test方法使之成为选择红苹果的方法，然后我们就可以得到一个红苹果选择器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RedAppleTester</span> <span class="keyword">implements</span> <span class="title">AppleTester</span></span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">test</span><span class="params">(Apple apple)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"red"</span>.equals(apple.getColor());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>再比如我们可以通过实现上述接口，重写这个test方法使之成为选择大苹果的方法，然后我们就可以得到一个大苹果选择器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BigAppleTester</span> <span class="keyword">implements</span> <span class="title">AppleTester</span></span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">test</span><span class="params">(Apple apple)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> apple.getWeight()&gt;<span class="number">150</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>有了这个选择器，我们就可以把这个选择器，亦即我们上面提到的筛选策略，传给我们的筛选器，以此进行相应需求的筛选，只要改变选择器，就可以更换筛选策略：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Apple&gt; <span class="title">filterSomeApple</span><span class="params">(List&lt;Apple&gt; apples,AppleTester tester)</span></span>&#123;</div><div class="line">        ArrayList&lt;Apple&gt; resList = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">for</span> (Apple apple</div><div class="line">                : apples) &#123;</div><div class="line">            <span class="keyword">if</span>(tester.test(apple))</div><div class="line">                resList.add(apple);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> resList;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">List&lt;Apple&gt; redApples = filterSomeApple(apples,<span class="keyword">new</span> RedAppleTester());</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">List&lt;Apple&gt; bigApples = filterSomeApple(apples,<span class="keyword">new</span> BigAppleTester());</div></pre></td></tr></table></figure>
<p>通过使用Java的匿名类来实现选择器接口，我们可以不显式地定义RedAppleTester，BigAppleTester，而进一步简洁代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">List&lt;Apple&gt; redApples = filterSomeApple(apples, <span class="keyword">new</span> AppleTester() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> Boolean <span class="title">test</span><span class="params">(Apple apple)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> <span class="string">"red"</span>.equals(apple.getColor());</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">List&lt;Apple&gt; bigApples = filterSomeApple(apples, <span class="keyword">new</span> AppleTester() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> Boolean <span class="title">test</span><span class="params">(Apple apple)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> apple.getWeight()&gt;<span class="number">150</span>;            </div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<p>所以我们已经从上面的说明中看到，我们定义的策略是：一个实现了一般苹果选择器接口的抽象方法的特殊苹果选择器类的对象，因为是对象，所以当然是可以在代码里作为参数来传递的。这也就是我们反复提到的在函数式编程里的策略传递，在原书中叫做<strong>「行为参数化的目的是传递代码」</strong>。</p>
<p>说到这里，其实这种函数式编程的解决思路并未出现什么Java8的新特性，在低版本的Java上即可实现这个过程，因为思路虽然很绕，但是说到底使用的就是简单的接口实现和方法重写。实际上呢，借助Java 8新的特性，我们可以更方便地使用语法糖来编写更简洁、更易懂的代码。</p>
<h3 id="Java-8-Lambda简洁化函数式编程"><a href="#Java-8-Lambda简洁化函数式编程" class="headerlink" title="Java 8 Lambda简洁化函数式编程"></a>Java 8 Lambda简洁化函数式编程</h3><p>我们上面定义的这种单方法接口叫做<strong>函数式接口</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">AppleTester</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">test</span><span class="params">(Apple apple)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>函数式接口的这个方法就是这个函数式接口的<strong>函数</strong>，这个函数的「参数-返回值」类型描述叫做<strong>函数描述符</strong>，test函数的描述符是 <code>Apple-&gt;Boolean</code>。<br>而lambda表达式其实是一种语法糖现象，它是对函数实现的简单表述，比如我们上文的一个函数实现，即实现了AppleTester接口的RedAppleTester:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RedAppleTester</span> <span class="keyword">implements</span> <span class="title">AppleTester</span></span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">test</span><span class="params">(Apple apple)</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="string">"red"</span>.equals(apple.getColor());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个实现类可以用lambda表达式<br><code>(Apple a) -&gt; &quot;red&quot;.equals(a.getColor())</code><br>或者<br><code>(Apple a) -&gt; {return &quot;red&quot;.equals(a.getColor());}</code><br>来代替。-&gt;前是参数列表，后面是表达式或命令。</p>
<p>在有上下文的情况下，甚至有更简洁的写法：<br><code>AppleTester tester = a -&gt; &quot;red&quot;.equals(a.getColor());</code><br>可以这样写的原因在于编译器可以根据上下文来推断参数类型:AppleTester作为函数式接口只定义了单一抽象方法：<code>public Boolean test(Apple apple)</code>，所以可以很容易地推断出其抽象方法实现的参数类型。</p>
<p>如果AppleUtils工具类直接定义了判定红苹果的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppleUtils</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title">isRedApple</span><span class="params">(Apple apple)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"red"</span>.equals(apple.getColor());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们会发现isRedApple方法的方法描述符和函数式接口AppleTester定义的单一抽象方法的函数描述符是一样的：<code>Apple-&gt;Boolean</code>，因此我们可以采用一种叫做方法引用的语法糖来进一步化简这个lambda表达式，不需要在lambda表达式中重复写已经定义过的方法：</p>
<p><code>AppleTester tester = AppleUtils::isRedApple</code></p>
<p>方法引用之所以可以起作用，就是因为这个被引用的方法具有和引用它的函数式接口的函数描述符相同的方法描述符。在实际创建那个实现了抽象方法的匿名类对象时会将被引用的方法体嵌入到这个实现方法中去：</p>
<p><img src="https://segmentfault.com/img/remote/1460000007540816?w=827&amp;h=368" alt="img"></p>
<p>虽然写起来简洁了，但是在本质上编译器会将lambda表达式编译成一个这样的实现了接口抽象方法的匿名类的对象。基于lambda表达式简洁而强大的表达能力，可以很容易把上面的这段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">List&lt;Apple&gt; redApples = filterSomeApple(apples, <span class="keyword">new</span> AppleTester() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> Boolean <span class="title">test</span><span class="params">(Apple apple)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> <span class="string">"red"</span>.equals(apple.getColor());</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<p>改写为Java8版本的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">List&lt;Apple&gt; redApples = filterSomeApple(apples, AppleUtils::isRedApple);</div></pre></td></tr></table></figure>
<p>如你所见，这样的写法瞬间将代码改到Java8前无法企及的简洁程度。</p>
<h3 id="Java-8泛型函数式接口"><a href="#Java-8泛型函数式接口" class="headerlink" title="Java 8泛型函数式接口"></a>Java 8泛型函数式接口</h3><p>我们在上文介绍的这个函数式接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">AppleTester</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">test</span><span class="params">(Apple apple)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>它的作用仅仅是对苹果进行选择，通过实现test抽象方法来作出具体的选择器。但是其实在我们的应用环境中，很多需求是泛化的，比如上文中的给一个对象（文中是苹果）以判断其是否能满足某些需求，这个场景一经泛化即可被许多场景所使用，可以使用泛型来对接口进行泛化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ChooseStrategy</span>&lt;<span class="title">T</span>&gt;</span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">test</span><span class="params">(T t)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>public Boolean test(T t)</code>的函数描述符是<code>T-&gt;Boolean</code>，所以只要说满足这个描述符的方法都可以作为方法引用。</p>
<p>同时我们需要一个泛化的filter方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">filter</span><span class="params">(List&lt;T&gt; ts, ChooseStrategy&lt;T&gt; strategy)</span></span>&#123;</div><div class="line">    ArrayList&lt;T&gt; resList = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    <span class="keyword">for</span> (T t</div><div class="line">            : ts) &#123;</div><div class="line">        <span class="keyword">if</span>(strategy.test(t))</div><div class="line">            resList.add(t);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> resList;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">List&lt;Apple&gt; redApples = filter(apples,AppleUtils::isRedApple);</div></pre></td></tr></table></figure>
<p>除了这种在类型上的泛型来泛化使用定义的函数式接口外，甚至有一些公用的场景Java8 为我们定义了一整套的函数式接口API来涵盖这些使用场景中需要的函数式接口。我们的编程中甚至不需要自己定义这些函数式接口：</p>
<ol>
<li><code>java.util.function.Predicate</code><br>函数描述符：<code>T-&gt;boolean</code></li>
<li><code>java.util.function.Consumer</code><br>函数描述符：<code>T-&gt;void</code></li>
<li><code>java.util.function.Function</code><br>函数描述符：<code>T-&gt;R</code></li>
<li><code>java.util.function.Supplier</code><br>函数描述符：<code>()-&gt;T</code></li>
<li><code>java.util.function.UnaryOperator</code><br>函数描述符：<code>T-&gt;T</code></li>
<li><code>java.util.function.BinaryOperator</code><br>函数描述符：<code>(T,T)-&gt;T</code></li>
<li><code>java.util.function.BiPredicate</code><br>函数描述符：<code>(L,R)-&gt;boolean</code></li>
<li><code>java.util.function.BiConsumer</code><br>函数描述符：<code>(T,U)-&gt;void</code></li>
<li><code>java.util.function.BiFunction</code><br>函数描述符：<code>(T,U)-&gt;R</code></li>
</ol>
<p>Java8通过接口抽象方法实现、lambda表达式来实现了策略对象的传递，使得函数成为了第一公民，并以此来将函数式编程带入了Java世界中。有了策略传递后，使用具体的策略来完成任务，比如本文中筛选苹果的filter过程，Java8则依靠StreamAPI来实现，一系列泛化的任务过程定义在这些API中</p>
<p>注: 该文章转载自:  <a href="https://segmentfault.com/u/jinhaoplus/articles" target="_blank" rel="external">https://segmentfault.com/u/jinhaoplus/articles</a></p>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> Java.函数式编程 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[十大经典排序算法]]></title>
      <url>/2016/11/25/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>读者自行尝试可以想看源码戳这，博主在[github]: <a href="https://github.com/damonare/Sorts" target="_blank" rel="external">https://github.com/damonare/Sorts</a></strong></p>
<p><strong>建了个库，读者可以Clone下来本地尝试。此博文配合源码体验更棒哦</strong></p>
<blockquote>
<ul>
<li>这世界上总存在着那么一些看似相似但有完全不同的东西，比如雷锋和雷峰塔，小平和小平头，玛丽和马里奥，Java和javascript….当年javascript为了抱Java大腿恬不知耻的让自己变成了Java的干儿子，哦，不是应该是跪舔，毕竟都跟了Java的姓了。可如今，javascript来了个咸鱼翻身，几乎要统治web领域，Nodejs，React Native的出现使得javascript在后端和移动端都开始占有了一席之地。可以这么说,在Web的江湖，JavaScript可谓风头无两，已经坐上了头把交椅。</li>
<li>在传统的计算机算法和数据结构领域，大多数专业教材和书籍的默认语言都是Java或者C/C+ +，O’REILLY家倒是出了一本叫做《数据结构与算法javascript描述》的书，但不得不说，不知道是作者吃了shit还是译者根本就没校对，满书的小错误，这就像那种无穷无尽的小bug一样,简直就是让人有种嘴里塞满了shit的感觉，吐也不是咽下去也不是。对于一个前端来说，尤其是笔试面试的时候，算法方面考的其实不难（十大排序算法或是和十大排序算法同等难度的），但就是之前没用javascript实现过或是没仔细看过相关算法的原理，导致写起来浪费很多时间。所以撸一撸袖子决定自己查资料自己总结一篇博客等用到了直接看自己的博客就OK了，正所谓靠天靠地靠大牛不如靠自己(ˉ(∞)ˉ)。</li>
<li>算法的由来：9世纪波斯数学家提出的：“al-Khowarizmi”就是下图这货（感觉重要数学元素提出者貌似都戴了顶白帽子），开个玩笑，阿拉伯人对于数学史的贡献还是值得人敬佩的。<br><a href="http://img.blog.csdn.net/20160916152402267" target="_blank" rel="external"><img src="http://img.blog.csdn.net/20160916152402267" alt="大大"></a></li>
</ul>
</blockquote>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="排序算法说明"><a href="#排序算法说明" class="headerlink" title="排序算法说明"></a>排序算法说明</h3><p><strong>（1）排序的定义：对一序列对象根据某个关键字进行排序；</strong></p>
<p>输入：n个数：a1,a2,a3,…,an<br>输出：n个数的排列:a1’,a2’,a3’,…,an’，使得a1’&lt;=a2’&lt;=a3’&lt;=…&lt;=an’。</p>
<p>再讲的形象点就是排排坐，调座位，高的站在后面，矮的站在前面咯。</p>
<p><strong>（3）对于评述算法优劣术语的说明</strong></p>
<p><strong>稳定</strong>：如果a原本在b前面，而a=b，排序之后a仍然在b的前面；<br><strong>不稳定</strong>：如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面；</p>
<p><strong>内排序</strong>：所有排序操作都在内存中完成；<br><strong>外排序</strong>：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；</p>
<p><strong>时间复杂度</strong>: 一个算法执行所耗费的时间。<br><strong>空间复杂度</strong>: 运行完一个程序所需内存的大小。</p>
<p>关于时间空间复杂度的更多了解请戳<a href="http://blog.csdn.net/booirror/article/details/7707551/" target="_blank" rel="external">这里</a>，或是看书程杰大大编写的《大话数据结构》还是很赞的，通俗易懂。</p>
<p><strong>（4）排序算法图片总结(图片来源于网络):</strong></p>
<p>排序对比：</p>
<p><a href="http://img.blog.csdn.net/20160916153212716" target="_blank" rel="external"><img src="http://img.blog.csdn.net/20160916153212716" alt="这里写图片描述"></a></p>
<p><strong>图片名词解释：</strong><br>n: 数据规模<br>k:“桶”的个数<br>In-place: 占用常数内存，不占用额外内存<br>Out-place: 占用额外内存</p>
<p>排序分类：</p>
<p><a href="http://img.blog.csdn.net/20160916154036887" target="_blank" rel="external"><img src="http://img.blog.csdn.net/20160916154036887" alt="这里写图片描述"></a></p>
<h3 id="1-冒泡排序（Bubble-Sort）"><a href="#1-冒泡排序（Bubble-Sort）" class="headerlink" title="1.冒泡排序（Bubble Sort）"></a>1.冒泡排序（Bubble Sort）</h3><blockquote>
<p>好的，开始总结第一个排序算法，冒泡排序。我想对于它每个学过C语言的都会了解的吧，这可能是很多人接触的第一个排序算法。</p>
</blockquote>
<h4 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="(1)算法描述"></a>(1)算法描述</h4><blockquote>
<p>冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p>
</blockquote>
<h4 id="2-算法描述和实现"><a href="#2-算法描述和实现" class="headerlink" title="(2)算法描述和实现"></a>(2)算法描述和实现</h4><p>具体算法描述如下：</p>
<ul>
<li><1>.比较相邻的元素。如果第一个比第二个大，就交换它们两个；</1></li>
<li><2>.对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</2></li>
<li><3>.针对所有的元素重复以上的步骤，除了最后一个；</3></li>
<li><4>.重复步骤1~3，直到排序完成。</4></li>
</ul>
<p><strong>JavaScript代码实现：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> len = arr.length;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++) &#123;</div><div class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j+<span class="number">1</span>]) &#123;        <span class="comment">//相邻元素两两对比</span></div><div class="line">                <span class="keyword">var</span> temp = arr[j+<span class="number">1</span>];        <span class="comment">//元素交换</span></div><div class="line">                arr[j+<span class="number">1</span>] = arr[j];</div><div class="line">                arr[j] = temp;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> arr;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> arr=[<span class="number">3</span>,<span class="number">44</span>,<span class="number">38</span>,<span class="number">5</span>,<span class="number">47</span>,<span class="number">15</span>,<span class="number">36</span>,<span class="number">26</span>,<span class="number">27</span>,<span class="number">2</span>,<span class="number">46</span>,<span class="number">4</span>,<span class="number">19</span>,<span class="number">50</span>,<span class="number">48</span>];</div><div class="line"><span class="built_in">console</span>.log(bubbleSort(arr));<span class="comment">//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</span></div></pre></td></tr></table></figure>
<blockquote>
<p><strong>改进冒泡排序:</strong>设置一标志性变量pos,用于记录每趟排序中最后一次进行交换的位置。由于pos位置之后的记录均已交换到位,故在进行下一趟排序时只要扫描到pos位置即可。</p>
</blockquote>
<p>改进后算法如下:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort2</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.time(<span class="string">'改进后冒泡排序耗时'</span>);</div><div class="line">    <span class="keyword">var</span> i = arr.length<span class="number">-1</span>;  <span class="comment">//初始时,最后位置保持不变</span></div><div class="line">    <span class="keyword">while</span> ( i&gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">var</span> pos= <span class="number">0</span>; <span class="comment">//每趟开始时,无记录交换</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j= <span class="number">0</span>; j&lt; i; j++)</div><div class="line">            <span class="keyword">if</span> (arr[j]&gt; arr[j+<span class="number">1</span>]) &#123;</div><div class="line">                pos= j; <span class="comment">//记录交换的位置</span></div><div class="line">                <span class="keyword">var</span> tmp = arr[j]; arr[j]=arr[j+<span class="number">1</span>];arr[j+<span class="number">1</span>]=tmp;</div><div class="line">            &#125;</div><div class="line">        i= pos; <span class="comment">//为下一趟排序作准备</span></div><div class="line">     &#125;</div><div class="line">     <span class="built_in">console</span>.timeEnd(<span class="string">'改进后冒泡排序耗时'</span>);</div><div class="line">     <span class="keyword">return</span> arr;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> arr=[<span class="number">3</span>,<span class="number">44</span>,<span class="number">38</span>,<span class="number">5</span>,<span class="number">47</span>,<span class="number">15</span>,<span class="number">36</span>,<span class="number">26</span>,<span class="number">27</span>,<span class="number">2</span>,<span class="number">46</span>,<span class="number">4</span>,<span class="number">19</span>,<span class="number">50</span>,<span class="number">48</span>];</div><div class="line"><span class="built_in">console</span>.log(bubbleSort2(arr));<span class="comment">//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</span></div></pre></td></tr></table></figure>
<blockquote>
<p>传统冒泡排序中每一趟排序操作只能找到一个最大值或最小值,我们考虑利用在每趟排序中进行正向和反向两遍冒泡的方法一次可以得到两个最终值(最大者和最小者) , 从而使排序趟数几乎减少了一半。</p>
</blockquote>
<p>改进后的算法实现为:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort3</span>(<span class="params">arr3</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> low = <span class="number">0</span>;</div><div class="line">    <span class="keyword">var</span> high= arr.length<span class="number">-1</span>; <span class="comment">//设置变量的初始值</span></div><div class="line">    <span class="keyword">var</span> tmp,j;</div><div class="line">    <span class="built_in">console</span>.time(<span class="string">'2.改进后冒泡排序耗时'</span>);</div><div class="line">    <span class="keyword">while</span> (low &lt; high) &#123;</div><div class="line">        <span class="keyword">for</span> (j= low; j&lt; high; ++j) <span class="comment">//正向冒泡,找到最大者</span></div><div class="line">            <span class="keyword">if</span> (arr[j]&gt; arr[j+<span class="number">1</span>]) &#123;</div><div class="line">                tmp = arr[j]; arr[j]=arr[j+<span class="number">1</span>];arr[j+<span class="number">1</span>]=tmp;</div><div class="line">            &#125;</div><div class="line">        --high;                 <span class="comment">//修改high值, 前移一位</span></div><div class="line">        <span class="keyword">for</span> (j=high; j&gt;low; --j) <span class="comment">//反向冒泡,找到最小者</span></div><div class="line">            <span class="keyword">if</span> (arr[j]&lt;arr[j<span class="number">-1</span>]) &#123;</div><div class="line">                tmp = arr[j]; arr[j]=arr[j<span class="number">-1</span>];arr[j<span class="number">-1</span>]=tmp;</div><div class="line">            &#125;</div><div class="line">        ++low;                  <span class="comment">//修改low值,后移一位</span></div><div class="line">    &#125;</div><div class="line">    <span class="built_in">console</span>.timeEnd(<span class="string">'2.改进后冒泡排序耗时'</span>);</div><div class="line">    <span class="keyword">return</span> arr3;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> arr=[<span class="number">3</span>,<span class="number">44</span>,<span class="number">38</span>,<span class="number">5</span>,<span class="number">47</span>,<span class="number">15</span>,<span class="number">36</span>,<span class="number">26</span>,<span class="number">27</span>,<span class="number">2</span>,<span class="number">46</span>,<span class="number">4</span>,<span class="number">19</span>,<span class="number">50</span>,<span class="number">48</span>];</div><div class="line"><span class="built_in">console</span>.log(bubbleSort3(arr));<span class="comment">//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</span></div></pre></td></tr></table></figure>
<p>三种方法耗时对比：</p>
<p><a href="http://img.blog.csdn.net/20160916163126374" target="_blank" rel="external"><img src="http://img.blog.csdn.net/20160916163126374" alt="这里写图片描述"></a></p>
<blockquote>
<p>由图可以看出改进后的冒泡排序明显的时间复杂度更低，耗时更短了。读者自行尝试可以戳这，博主在github建了个库，读者可以Clone下来本地尝试。此博文配合源码体验更棒哦~~~</p>
</blockquote>
<p><strong>冒泡排序动图演示:</strong></p>
<p><a href="http://img.blog.csdn.net/20160916160748389" target="_blank" rel="external"><img src="http://img.blog.csdn.net/20160916160748389" alt="这里写图片描述"></a></p>
<p><strong>(3)算法分析</strong></p>
<ul>
<li>最佳情况：T(n) = O(n)</li>
</ul>
<blockquote>
<p>当输入的数据已经是正序时（都已经是正序了，为毛何必还排序呢….）</p>
</blockquote>
<ul>
<li>最差情况：T(n) = O(n2)</li>
</ul>
<blockquote>
<p>当输入的数据是反序时(卧槽，我直接反序不就完了….)</p>
</blockquote>
<ul>
<li>平均情况：T(n) = O(n2)</li>
</ul>
<h3 id="2-选择排序（Selection-Sort）"><a href="#2-选择排序（Selection-Sort）" class="headerlink" title="2.选择排序（Selection Sort）"></a>2.选择排序（Selection Sort）</h3><blockquote>
<p>表现最稳定的排序算法之一(这个稳定不是指算法层面上的稳定哈，相信聪明的你能明白我说的意思2333)，因为无论什么数据进去都是O(n²)的时间复杂度…..所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。理论上讲，选择排序可能也是平时排序一般人想到的最多的排序方法了吧。</p>
</blockquote>
<h4 id="1-算法简介"><a href="#1-算法简介" class="headerlink" title="(1)算法简介"></a>(1)算法简介</h4><blockquote>
<p>选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p>
</blockquote>
<h4 id="2-算法描述和实现-1"><a href="#2-算法描述和实现-1" class="headerlink" title="(2)算法描述和实现"></a>(2)算法描述和实现</h4><p>n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：</p>
<ul>
<li><1>.初始状态：无序区为R[1..n]，有序区为空；</1></li>
<li><2>.第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</2></li>
<li><3>.n-1趟结束，数组有序化了。</3></li>
</ul>
<p><strong>Javascript代码实现:</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectionSort</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> len = arr.length;</div><div class="line">    <span class="keyword">var</span> minIndex, temp;</div><div class="line">    <span class="built_in">console</span>.time(<span class="string">'选择排序耗时'</span>);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</div><div class="line">        minIndex = i;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</div><div class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[minIndex]) &#123;     <span class="comment">//寻找最小的数</span></div><div class="line">                minIndex = j;                 <span class="comment">//将最小数的索引保存</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        temp = arr[i];</div><div class="line">        arr[i] = arr[minIndex];</div><div class="line">        arr[minIndex] = temp;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">console</span>.timeEnd(<span class="string">'选择排序耗时'</span>);</div><div class="line">    <span class="keyword">return</span> arr;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> arr=[<span class="number">3</span>,<span class="number">44</span>,<span class="number">38</span>,<span class="number">5</span>,<span class="number">47</span>,<span class="number">15</span>,<span class="number">36</span>,<span class="number">26</span>,<span class="number">27</span>,<span class="number">2</span>,<span class="number">46</span>,<span class="number">4</span>,<span class="number">19</span>,<span class="number">50</span>,<span class="number">48</span>];</div><div class="line"><span class="built_in">console</span>.log(selectionSort(arr));<span class="comment">//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</span></div></pre></td></tr></table></figure>
<p><strong>选择排序动图演示：</strong></p>
<p><a href="http://img.blog.csdn.net/20160916164754013" target="_blank" rel="external"><img src="http://img.blog.csdn.net/20160916164754013" alt="这里写图片描述"></a></p>
<h4 id="3-算法分析"><a href="#3-算法分析" class="headerlink" title="(3)算法分析"></a>(3)算法分析</h4><ul>
<li>最佳情况：T(n) = O(n2)</li>
<li>最差情况：T(n) = O(n2)</li>
<li>平均情况：T(n) = O(n2)</li>
</ul>
<h2 id="3-插入排序（Insertion-Sort）"><a href="#3-插入排序（Insertion-Sort）" class="headerlink" title="3.插入排序（Insertion Sort）"></a>3.插入排序（Insertion Sort）</h2><blockquote>
<p>插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理解的了，因为只要打过扑克牌的人都应该能够秒懂。当然，如果你说你打扑克牌摸牌的时候从来不按牌的大小整理牌，那估计这辈子你对插入排序的算法都不会产生任何兴趣了…..</p>
</blockquote>
<h4 id="1-算法简介-1"><a href="#1-算法简介-1" class="headerlink" title="(1)算法简介"></a>(1)算法简介</h4><blockquote>
<p>插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p>
</blockquote>
<h4 id="2-算法描述和实现-2"><a href="#2-算法描述和实现-2" class="headerlink" title="(2)算法描述和实现"></a>(2)算法描述和实现</h4><p>一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：</p>
<ul>
<li><1>.从第一个元素开始，该元素可以认为已经被排序；</1></li>
<li><2>.取出下一个元素，在已经排序的元素序列中从后向前扫描；</2></li>
<li><3>.如果该元素（已排序）大于新元素，将该元素移到下一位置；</3></li>
<li><4>.重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</4></li>
<li><5>.将新元素插入到该位置后；</5></li>
<li><6>.重复步骤2~5。</6></li>
</ul>
<p><strong>Javascript代码实现:</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertionSort</span>(<span class="params">array</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.toString.call(array).slice(<span class="number">8</span>, <span class="number">-1</span>) === <span class="string">'Array'</span>) &#123;</div><div class="line">        <span class="built_in">console</span>.time(<span class="string">'插入排序耗时：'</span>);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; array.length; i++) &#123;</div><div class="line">            <span class="keyword">var</span> key = array[i];</div><div class="line">            <span class="keyword">var</span> j = i - <span class="number">1</span>;</div><div class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; array[j] &gt; key) &#123;</div><div class="line">                array[j + <span class="number">1</span>] = array[j];</div><div class="line">                j--;</div><div class="line">            &#125;</div><div class="line">            array[j + <span class="number">1</span>] = key;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">console</span>.timeEnd(<span class="string">'插入排序耗时：'</span>);</div><div class="line">        <span class="keyword">return</span> array;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">'array is not an Array!'</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>改进插入排序：</strong> 查找插入位置时使用二分查找的方式</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">binaryInsertionSort</span>(<span class="params">array</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.toString.call(array).slice(<span class="number">8</span>, <span class="number">-1</span>) === <span class="string">'Array'</span>) &#123;</div><div class="line">        <span class="built_in">console</span>.time(<span class="string">'二分插入排序耗时：'</span>);</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; array.length; i++) &#123;</div><div class="line">            <span class="keyword">var</span> key = array[i], left = <span class="number">0</span>, right = i - <span class="number">1</span>;</div><div class="line">            <span class="keyword">while</span> (left &lt;= right) &#123;</div><div class="line">                <span class="keyword">var</span> middle = <span class="built_in">parseInt</span>((left + right) / <span class="number">2</span>);</div><div class="line">                <span class="keyword">if</span> (key &lt; array[middle]) &#123;</div><div class="line">                    right = middle - <span class="number">1</span>;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    left = middle + <span class="number">1</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> j = i - <span class="number">1</span>; j &gt;= left; j--) &#123;</div><div class="line">                array[j + <span class="number">1</span>] = array[j];</div><div class="line">            &#125;</div><div class="line">            array[left] = key;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">console</span>.timeEnd(<span class="string">'二分插入排序耗时：'</span>);</div><div class="line"></div><div class="line">        <span class="keyword">return</span> array;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">'array is not an Array!'</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> arr=[<span class="number">3</span>,<span class="number">44</span>,<span class="number">38</span>,<span class="number">5</span>,<span class="number">47</span>,<span class="number">15</span>,<span class="number">36</span>,<span class="number">26</span>,<span class="number">27</span>,<span class="number">2</span>,<span class="number">46</span>,<span class="number">4</span>,<span class="number">19</span>,<span class="number">50</span>,<span class="number">48</span>];</div><div class="line"><span class="built_in">console</span>.log(binaryInsertionSort(arr));<span class="comment">//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</span></div></pre></td></tr></table></figure>
<blockquote>
<p>改进前后对比：</p>
</blockquote>
<p><a href="http://img.blog.csdn.net/20160916174656100" target="_blank" rel="external"><img src="http://img.blog.csdn.net/20160916174656100" alt="这里写图片描述"></a></p>
<p><strong>插入排序动图演示:</strong></p>
<p><a href="http://img.blog.csdn.net/20160916173802597" target="_blank" rel="external"><img src="http://img.blog.csdn.net/20160916173802597" alt="这里写图片描述"></a></p>
<h4 id="3-算法分析-1"><a href="#3-算法分析-1" class="headerlink" title="(3)算法分析"></a>(3)算法分析</h4><ul>
<li>最佳情况：输入数组按升序排列。T(n) = O(n)</li>
<li>最坏情况：输入数组按降序排列。T(n) = O(n2)</li>
<li>平均情况：T(n) = O(n2)</li>
</ul>
<h3 id="4-希尔排序（Shell-Sort）"><a href="#4-希尔排序（Shell-Sort）" class="headerlink" title="4.希尔排序（Shell Sort）"></a>4.希尔排序（Shell Sort）</h3><blockquote>
<p>1959年Shell发明；<br>第一个突破O(n^2)的排序算法；是简单插入排序的改进版；它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序</p>
</blockquote>
<h4 id="1-算法简介-2"><a href="#1-算法简介-2" class="headerlink" title="(1)算法简介"></a>(1)算法简介</h4><blockquote>
<p>希尔排序的核心在于间隔序列的设定。既可以提前设定好间隔序列，也可以动态的定义间隔序列。动态定义间隔序列的算法是《算法（第4版》的合著者Robert Sedgewick提出的。</p>
</blockquote>
<h4 id="2-算法描述和实现-3"><a href="#2-算法描述和实现-3" class="headerlink" title="(2)算法描述和实现"></a>(2)算法描述和实现</h4><p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：</p>
<ul>
<li><1>. 选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；</1></li>
<li><2>.按增量序列个数k，对序列进行k 趟排序；</2></li>
<li><3>.每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</3></li>
</ul>
<p><strong>Javascript代码实现：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">shellSort</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> len = arr.length,</div><div class="line">        temp,</div><div class="line">        gap = <span class="number">1</span>;</div><div class="line">    <span class="built_in">console</span>.time(<span class="string">'希尔排序耗时:'</span>);</div><div class="line">    <span class="keyword">while</span>(gap &lt; len/<span class="number">5</span>) &#123;          <span class="comment">//动态定义间隔序列</span></div><div class="line">        gap =gap*<span class="number">5</span>+<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> (gap; gap &gt; <span class="number">0</span>; gap = <span class="built_in">Math</span>.floor(gap/<span class="number">5</span>)) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = gap; i &lt; len; i++) &#123;</div><div class="line">            temp = arr[i];</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> j = i-gap; j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; temp; j-=gap) &#123;</div><div class="line">                arr[j+gap] = arr[j];</div><div class="line">            &#125;</div><div class="line">            arr[j+gap] = temp;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">console</span>.timeEnd(<span class="string">'希尔排序耗时:'</span>);</div><div class="line">    <span class="keyword">return</span> arr;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> arr=[<span class="number">3</span>,<span class="number">44</span>,<span class="number">38</span>,<span class="number">5</span>,<span class="number">47</span>,<span class="number">15</span>,<span class="number">36</span>,<span class="number">26</span>,<span class="number">27</span>,<span class="number">2</span>,<span class="number">46</span>,<span class="number">4</span>,<span class="number">19</span>,<span class="number">50</span>,<span class="number">48</span>];</div><div class="line"><span class="built_in">console</span>.log(shellSort(arr));<span class="comment">//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</span></div></pre></td></tr></table></figure>
<p><strong>希尔排序图示（图片来源网络）：</strong></p>
<p><a href="http://img.blog.csdn.net/20160916235203417" target="_blank" rel="external"><img src="http://img.blog.csdn.net/20160916235203417" alt="这里写图片描述"></a></p>
<h4 id="（3）算法分析"><a href="#（3）算法分析" class="headerlink" title="（3）算法分析"></a>（3）算法分析</h4><ul>
<li>最佳情况：T(n) = O(nlog2 n)</li>
<li>最坏情况：T(n) = O(nlog2 n)</li>
<li>平均情况：T(n) =O(nlog n)</li>
</ul>
<h3 id="5-归并排序（Merge-Sort）"><a href="#5-归并排序（Merge-Sort）" class="headerlink" title="5.归并排序（Merge Sort）"></a>5.归并排序（Merge Sort）</h3><blockquote>
<p>和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(n log n）的时间复杂度。代价是需要额外的内存空间。</p>
</blockquote>
<h4 id="1-算法简介-3"><a href="#1-算法简介-3" class="headerlink" title="(1)算法简介"></a>(1)算法简介</h4><blockquote>
<p>　归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。归并排序是一种稳定的排序方法。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。</p>
</blockquote>
<h4 id="2-算法描述和实现-4"><a href="#2-算法描述和实现-4" class="headerlink" title="(2)算法描述和实现"></a>(2)算法描述和实现</h4><p>具体算法描述如下：</p>
<ul>
<li><1>.把长度为n的输入序列分成两个长度为n/2的子序列；</1></li>
<li><2>.对这两个子序列分别采用归并排序；</2></li>
<li><3>.将两个排序好的子序列合并成一个最终的排序序列。</3></li>
</ul>
<p><strong>Javscript代码实现:</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeSort</span>(<span class="params">arr</span>) </span>&#123;  <span class="comment">//采用自上而下的递归方法</span></div><div class="line">    <span class="keyword">var</span> len = arr.length;</div><div class="line">    <span class="keyword">if</span>(len &lt; <span class="number">2</span>) &#123;</div><div class="line">        <span class="keyword">return</span> arr;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> middle = <span class="built_in">Math</span>.floor(len / <span class="number">2</span>),</div><div class="line">        left = arr.slice(<span class="number">0</span>, middle),</div><div class="line">        right = arr.slice(middle);</div><div class="line">    <span class="keyword">return</span> merge(mergeSort(left), mergeSort(right));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params">left, right</span>)</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">var</span> result = [];</div><div class="line">    <span class="built_in">console</span>.time(<span class="string">'归并排序耗时'</span>);</div><div class="line">    <span class="keyword">while</span> (left.length &amp;&amp; right.length) &#123;</div><div class="line">        <span class="keyword">if</span> (left[<span class="number">0</span>] &lt;= right[<span class="number">0</span>]) &#123;</div><div class="line">            result.push(left.shift());</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            result.push(right.shift());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (left.length)</div><div class="line">        result.push(left.shift());</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (right.length)</div><div class="line">        result.push(right.shift());</div><div class="line">    <span class="built_in">console</span>.timeEnd(<span class="string">'归并排序耗时'</span>);</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> arr=[<span class="number">3</span>,<span class="number">44</span>,<span class="number">38</span>,<span class="number">5</span>,<span class="number">47</span>,<span class="number">15</span>,<span class="number">36</span>,<span class="number">26</span>,<span class="number">27</span>,<span class="number">2</span>,<span class="number">46</span>,<span class="number">4</span>,<span class="number">19</span>,<span class="number">50</span>,<span class="number">48</span>];</div><div class="line"><span class="built_in">console</span>.log(mergeSort(arr));</div></pre></td></tr></table></figure>
<p><strong>归并排序动图演示:</strong></p>
<p><a href="http://img.blog.csdn.net/20160917001326254" target="_blank" rel="external"><img src="http://img.blog.csdn.net/20160917001326254" alt="这里写图片描述"></a></p>
<h4 id="3-算法分析-2"><a href="#3-算法分析-2" class="headerlink" title="(3)算法分析"></a>(3)算法分析</h4><ul>
<li>最佳情况：T(n) = O(n)</li>
<li>最差情况：T(n) = O(nlogn)</li>
<li>平均情况：T(n) = O(nlogn)</li>
</ul>
<h3 id="6-快速排序（Quick-Sort）"><a href="#6-快速排序（Quick-Sort）" class="headerlink" title="6.快速排序（Quick Sort）"></a>6.快速排序（Quick Sort）</h3><blockquote>
<p>快速排序的名字起的是简单粗暴，因为一听到这个名字你就知道它存在的意义，就是快，而且效率高! 它是处理大数据最快的排序算法之一了。</p>
</blockquote>
<h4 id="1-算法简介-4"><a href="#1-算法简介-4" class="headerlink" title="(1)算法简介"></a>(1)算法简介</h4><blockquote>
<p>快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p>
</blockquote>
<h4 id="2-算法描述和实现-5"><a href="#2-算法描述和实现-5" class="headerlink" title="(2)算法描述和实现"></a>(2)算法描述和实现</h4><p>快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：</p>
<ul>
<li><1>.从数列中挑出一个元素，称为 “基准”（pivot）；</1></li>
<li><2>.重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</2></li>
<li><3>.递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</3></li>
</ul>
<p><strong>Javascript代码实现：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*方法说明：快速排序</span></div><div class="line">@param  array 待排序数组*/</div><div class="line"><span class="comment">//方法一</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">array, left, right</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.time(<span class="string">'1.快速排序耗时'</span>);</div><div class="line">    <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.toString.call(array).slice(<span class="number">8</span>, <span class="number">-1</span>) === <span class="string">'Array'</span> &amp;&amp; <span class="keyword">typeof</span> left === <span class="string">'number'</span> &amp;&amp; <span class="keyword">typeof</span> right === <span class="string">'number'</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (left &lt; right) &#123;</div><div class="line">            <span class="keyword">var</span> x = array[right], i = left - <span class="number">1</span>, temp;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> j = left; j &lt;= right; j++) &#123;</div><div class="line">                <span class="keyword">if</span> (array[j] &lt;= x) &#123;</div><div class="line">                    i++;</div><div class="line">                    temp = array[i];</div><div class="line">                    array[i] = array[j];</div><div class="line">                    array[j] = temp;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            quickSort(array, left, i - <span class="number">1</span>);</div><div class="line">            quickSort(array, i + <span class="number">1</span>, right);</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">console</span>.timeEnd(<span class="string">'1.快速排序耗时'</span>);</div><div class="line">        <span class="keyword">return</span> array;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">'array is not an Array or left or right is not a number!'</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//方法二</span></div><div class="line"><span class="keyword">var</span> quickSort2 = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.time(<span class="string">'2.快速排序耗时'</span>);</div><div class="line">　　<span class="keyword">if</span> (arr.length &lt;= <span class="number">1</span>) &#123; <span class="keyword">return</span> arr; &#125;</div><div class="line">　　<span class="keyword">var</span> pivotIndex = <span class="built_in">Math</span>.floor(arr.length / <span class="number">2</span>);</div><div class="line">　　<span class="keyword">var</span> pivot = arr.splice(pivotIndex, <span class="number">1</span>)[<span class="number">0</span>];</div><div class="line">　　<span class="keyword">var</span> left = [];</div><div class="line">　　<span class="keyword">var</span> right = [];</div><div class="line">　　<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</div><div class="line">　　　　<span class="keyword">if</span> (arr[i] &lt; pivot) &#123;</div><div class="line">　　　　　　left.push(arr[i]);</div><div class="line">　　　　&#125; <span class="keyword">else</span> &#123;</div><div class="line">　　　　　　right.push(arr[i]);</div><div class="line">　　　　&#125;</div><div class="line">　　&#125;</div><div class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'2.快速排序耗时'</span>);</div><div class="line">　　<span class="keyword">return</span> quickSort2(left).concat([pivot], quickSort2(right));</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> arr=[<span class="number">3</span>,<span class="number">44</span>,<span class="number">38</span>,<span class="number">5</span>,<span class="number">47</span>,<span class="number">15</span>,<span class="number">36</span>,<span class="number">26</span>,<span class="number">27</span>,<span class="number">2</span>,<span class="number">46</span>,<span class="number">4</span>,<span class="number">19</span>,<span class="number">50</span>,<span class="number">48</span>];</div><div class="line"><span class="built_in">console</span>.log(quickSort(arr,<span class="number">0</span>,arr.length<span class="number">-1</span>));<span class="comment">//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</span></div><div class="line"><span class="built_in">console</span>.log(quickSort2(arr));<span class="comment">//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</span></div></pre></td></tr></table></figure>
<p><strong>快速排序动图演示：</strong></p>
<p><a href="http://img.blog.csdn.net/20160917003004906" target="_blank" rel="external"><img src="http://img.blog.csdn.net/20160917003004906" alt="快速排序"></a></p>
<h4 id="3-算法分析-3"><a href="#3-算法分析-3" class="headerlink" title="(3)算法分析"></a>(3)算法分析</h4><ul>
<li>最佳情况：T(n) = O(nlogn)</li>
<li>最差情况：T(n) = O(n2)</li>
<li>平均情况：T(n) = O(nlogn)</li>
</ul>
<h3 id="7-堆排序（Heap-Sort）"><a href="#7-堆排序（Heap-Sort）" class="headerlink" title="7.堆排序（Heap Sort）"></a>7.堆排序（Heap Sort）</h3><blockquote>
<p>堆排序可以说是一种利用堆的概念来排序的选择排序。</p>
</blockquote>
<h4 id="1-算法简介-5"><a href="#1-算法简介-5" class="headerlink" title="(1)算法简介"></a>(1)算法简介</h4><blockquote>
<p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p>
</blockquote>
<h4 id="2-算法描述和实现-6"><a href="#2-算法描述和实现-6" class="headerlink" title="(2)算法描述和实现"></a>(2)算法描述和实现</h4><p>具体算法描述如下：</p>
<ul>
<li><1>.将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；</1></li>
<li><2>.将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；</2></li>
<li><3>.由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。</3></li>
</ul>
<p><strong>Javascript代码实现：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*方法说明：堆排序</span></div><div class="line">@param  array 待排序数组*/</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">heapSort</span>(<span class="params">array</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.time(<span class="string">'堆排序耗时'</span>);</div><div class="line">    <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.toString.call(array).slice(<span class="number">8</span>, <span class="number">-1</span>) === <span class="string">'Array'</span>) &#123;</div><div class="line">        <span class="comment">//建堆</span></div><div class="line">        <span class="keyword">var</span> heapSize = array.length, temp;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="built_in">Math</span>.floor(heapSize / <span class="number">2</span>) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">            heapify(array, i, heapSize);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//堆排序</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = heapSize - <span class="number">1</span>; j &gt;= <span class="number">1</span>; j--) &#123;</div><div class="line">            temp = array[<span class="number">0</span>];</div><div class="line">            array[<span class="number">0</span>] = array[j];</div><div class="line">            array[j] = temp;</div><div class="line">            heapify(array, <span class="number">0</span>, --heapSize);</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">console</span>.timeEnd(<span class="string">'堆排序耗时'</span>);</div><div class="line">        <span class="keyword">return</span> array;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">'array is not an Array!'</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/*方法说明：维护堆的性质</span></div><div class="line">@param  arr 数组</div><div class="line">@param  x   数组下标</div><div class="line">@param  len 堆大小*/</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">heapify</span>(<span class="params">arr, x, len</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.toString.call(arr).slice(<span class="number">8</span>, <span class="number">-1</span>) === <span class="string">'Array'</span> &amp;&amp; <span class="keyword">typeof</span> x === <span class="string">'number'</span>) &#123;</div><div class="line">        <span class="keyword">var</span> l = <span class="number">2</span> * x + <span class="number">1</span>, r = <span class="number">2</span> * x + <span class="number">2</span>, largest = x, temp;</div><div class="line">        <span class="keyword">if</span> (l &lt; len &amp;&amp; arr[l] &gt; arr[largest]) &#123;</div><div class="line">            largest = l;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (r &lt; len &amp;&amp; arr[r] &gt; arr[largest]) &#123;</div><div class="line">            largest = r;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (largest != x) &#123;</div><div class="line">            temp = arr[x];</div><div class="line">            arr[x] = arr[largest];</div><div class="line">            arr[largest] = temp;</div><div class="line">            heapify(arr, largest, len);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">'arr is not an Array or x is not a number!'</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> arr=[<span class="number">91</span>,<span class="number">60</span>,<span class="number">96</span>,<span class="number">13</span>,<span class="number">35</span>,<span class="number">65</span>,<span class="number">46</span>,<span class="number">65</span>,<span class="number">10</span>,<span class="number">30</span>,<span class="number">20</span>,<span class="number">31</span>,<span class="number">77</span>,<span class="number">81</span>,<span class="number">22</span>];</div><div class="line"><span class="built_in">console</span>.log(heapSort(arr));<span class="comment">//[10, 13, 20, 22, 30, 31, 35, 46, 60, 65, 65, 77, 81, 91, 96]</span></div></pre></td></tr></table></figure>
<p><strong>堆排序动图演示：</strong></p>
<p><a href="http://img.blog.csdn.net/20160917105502853" target="_blank" rel="external"><img src="http://img.blog.csdn.net/20160917105502853" alt="这里写图片描述"></a></p>
<h4 id="3-算法分析-4"><a href="#3-算法分析-4" class="headerlink" title="(3)算法分析"></a>(3)算法分析</h4><ul>
<li>最佳情况：T(n) = O(nlogn)</li>
<li>最差情况：T(n) = O(nlogn)</li>
<li>平均情况：T(n) = O(nlogn)</li>
</ul>
<h3 id="8-计数排序（Counting-Sort）"><a href="#8-计数排序（Counting-Sort）" class="headerlink" title="8.计数排序（Counting Sort）"></a>8.计数排序（Counting Sort）</h3><blockquote>
<p>计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。<br>作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p>
</blockquote>
<h4 id="1-算法简介-6"><a href="#1-算法简介-6" class="headerlink" title="(1)算法简介"></a>(1)算法简介</h4><blockquote>
<p>计数排序(Counting sort)是一种稳定的排序算法。计数排序使用一个额外的数组C，其中第i个元素是待排序数组A中值等于i的元素的个数。然后根据数组C来将A中的元素排到正确的位置。它只能对整数进行排序。</p>
</blockquote>
<h4 id="2-算法描述和实现-7"><a href="#2-算法描述和实现-7" class="headerlink" title="(2)算法描述和实现"></a>(2)算法描述和实现</h4><p>具体算法描述如下：</p>
<ul>
<li><1>. 找出待排序的数组中最大和最小的元素；</1></li>
<li><2>. 统计数组中每个值为i的元素出现的次数，存入数组C的第i项；</2></li>
<li><3>. 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；</3></li>
<li><4>. 反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。</4></li>
</ul>
<p><strong>Javascript代码实现：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">countingSort</span>(<span class="params">array</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> len = array.length,</div><div class="line">        B = [],</div><div class="line">        C = [],</div><div class="line">        min = max = array[<span class="number">0</span>];</div><div class="line">    <span class="built_in">console</span>.time(<span class="string">'计数排序耗时'</span>);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</div><div class="line">        min = min &lt;= array[i] ? min : array[i];</div><div class="line">        max = max &gt;= array[i] ? max : array[i];</div><div class="line">        C[array[i]] = C[array[i]] ? C[array[i]] + <span class="number">1</span> : <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = min; j &lt; max; j++) &#123;</div><div class="line">        C[j + <span class="number">1</span>] = (C[j + <span class="number">1</span>] || <span class="number">0</span>) + (C[j] || <span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> k = len - <span class="number">1</span>; k &gt;= <span class="number">0</span>; k--) &#123;</div><div class="line">        B[C[array[k]] - <span class="number">1</span>] = array[k];</div><div class="line">        C[array[k]]--;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">console</span>.timeEnd(<span class="string">'计数排序耗时'</span>);</div><div class="line">    <span class="keyword">return</span> B;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> arr = [<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">2</span>];</div><div class="line"><span class="built_in">console</span>.log(countingSort(arr)); <span class="comment">//[1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 4, 4, 6, 7, 7, 8, 8, 9, 9]</span></div></pre></td></tr></table></figure>
<p><strong>JavaScript动图演示：</strong>、</p>
<p><a href="http://img.blog.csdn.net/20160917110641479" target="_blank" rel="external"><img src="http://img.blog.csdn.net/20160917110641479" alt="这里写图片描述"></a></p>
<h4 id="3-算法分析-5"><a href="#3-算法分析-5" class="headerlink" title="(3)算法分析"></a>(3)算法分析</h4><blockquote>
<p>当输入的元素是n 个0到k之间的整数时，它的运行时间是 O(n + k)。计数排序不是比较排序，排序的速度快于任何比较排序算法。由于用来计数的数组C的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。</p>
</blockquote>
<ul>
<li>最佳情况：T(n) = O(n+k)</li>
<li>最差情况：T(n) = O(n+k)</li>
<li>平均情况：T(n) = O(n+k)</li>
</ul>
<h3 id="9-桶排序（Bucket-Sort）"><a href="#9-桶排序（Bucket-Sort）" class="headerlink" title="9.桶排序（Bucket Sort）"></a>9.桶排序（Bucket Sort）</h3><blockquote>
<p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。</p>
</blockquote>
<h4 id="1-算法简介-7"><a href="#1-算法简介-7" class="headerlink" title="(1)算法简介"></a>(1)算法简介</h4><blockquote>
<p>桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排</p>
</blockquote>
<h4 id="2-算法描述和实现-8"><a href="#2-算法描述和实现-8" class="headerlink" title="(2)算法描述和实现"></a>(2)算法描述和实现</h4><p>具体算法描述如下：</p>
<ul>
<li><1>.设置一个定量的数组当作空桶；</1></li>
<li><2>.遍历输入数据，并且把数据一个一个放到对应的桶里去；</2></li>
<li><3>.对每个不是空的桶进行排序；</3></li>
<li><4>.从不是空的桶里把排好序的数据拼接起来。</4></li>
</ul>
<p><strong>Javascript代码实现:</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*方法说明：桶排序</span></div><div class="line">@param  array 数组</div><div class="line">@param  num   桶的数量*/</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bucketSort</span>(<span class="params">array, num</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (array.length &lt;= <span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">return</span> array;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> len = array.length, buckets = [], result = [], min = max = array[<span class="number">0</span>], regex = <span class="string">'/^[1-9]+[0-9]*$/'</span>, space, n = <span class="number">0</span>;</div><div class="line">    num = num || ((num &gt; <span class="number">1</span> &amp;&amp; regex.test(num)) ? num : <span class="number">10</span>);</div><div class="line">    <span class="built_in">console</span>.time(<span class="string">'桶排序耗时'</span>);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</div><div class="line">        min = min &lt;= array[i] ? min : array[i];</div><div class="line">        max = max &gt;= array[i] ? max : array[i];</div><div class="line">    &#125;</div><div class="line">    space = (max - min + <span class="number">1</span>) / num;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</div><div class="line">        <span class="keyword">var</span> index = <span class="built_in">Math</span>.floor((array[j] - min) / space);</div><div class="line">        <span class="keyword">if</span> (buckets[index]) &#123;   <span class="comment">//  非空桶，插入排序</span></div><div class="line">            <span class="keyword">var</span> k = buckets[index].length - <span class="number">1</span>;</div><div class="line">            <span class="keyword">while</span> (k &gt;= <span class="number">0</span> &amp;&amp; buckets[index][k] &gt; array[j]) &#123;</div><div class="line">                buckets[index][k + <span class="number">1</span>] = buckets[index][k];</div><div class="line">                k--;</div><div class="line">            &#125;</div><div class="line">            buckets[index][k + <span class="number">1</span>] = array[j];</div><div class="line">        &#125; <span class="keyword">else</span> &#123;    <span class="comment">//空桶，初始化</span></div><div class="line">            buckets[index] = [];</div><div class="line">            buckets[index].push(array[j]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span> (n &lt; num) &#123;</div><div class="line">        result = result.concat(buckets[n]);</div><div class="line">        n++;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">console</span>.timeEnd(<span class="string">'桶排序耗时'</span>);</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> arr=[<span class="number">3</span>,<span class="number">44</span>,<span class="number">38</span>,<span class="number">5</span>,<span class="number">47</span>,<span class="number">15</span>,<span class="number">36</span>,<span class="number">26</span>,<span class="number">27</span>,<span class="number">2</span>,<span class="number">46</span>,<span class="number">4</span>,<span class="number">19</span>,<span class="number">50</span>,<span class="number">48</span>];</div><div class="line"><span class="built_in">console</span>.log(bucketSort(arr,<span class="number">4</span>));<span class="comment">//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</span></div></pre></td></tr></table></figure>
<p><strong>桶排序图示（图片来源网络）：</strong></p>
<p><a href="http://img.blog.csdn.net/20160917111945979" target="_blank" rel="external"><img src="http://img.blog.csdn.net/20160917111945979" alt="这里写图片描述"></a></p>
<p>关于桶排序<a href="http://www.cnblogs.com/lonelyxmas/p/3561938.html" target="_blank" rel="external">更多</a></p>
<h4 id="3-算法分析-6"><a href="#3-算法分析-6" class="headerlink" title="(3)算法分析"></a>(3)算法分析</h4><blockquote>
<p>　桶排序最好情况下使用线性时间O(n)，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为O(n)。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。</p>
</blockquote>
<ul>
<li>最佳情况：T(n) = O(n+k)</li>
<li>最差情况：T(n) = O(n+k)</li>
<li>平均情况：T(n) = O(n2)</li>
</ul>
<h3 id="10-基数排序（Radix-Sort）"><a href="#10-基数排序（Radix-Sort）" class="headerlink" title="10.基数排序（Radix Sort）"></a>10.基数排序（Radix Sort）</h3><blockquote>
<p>基数排序也是非比较的排序算法，对每一位进行排序，从最低位开始排序，复杂度为O(kn),为数组长度，k为数组中的数的最大的位数；</p>
</blockquote>
<h4 id="1-算法简介-8"><a href="#1-算法简介-8" class="headerlink" title="(1)算法简介"></a>(1)算法简介</h4><blockquote>
<p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以是稳定的。</p>
</blockquote>
<h4 id="2-算法描述和实现-9"><a href="#2-算法描述和实现-9" class="headerlink" title="(2)算法描述和实现"></a>(2)算法描述和实现</h4><p>具体算法描述如下：</p>
<ul>
<li><1>.取得数组中的最大数，并取得位数；</1></li>
<li><2>.arr为原始数组，从最低位开始取每个位组成radix数组；</2></li>
<li><3>.对radix进行计数排序（利用计数排序适用于小范围数的特点）；</3></li>
</ul>
<p><strong>Javascript代码实现：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 基数排序适用于：</div><div class="line"> *  (1)数据范围较小，建议在小于1000</div><div class="line"> *  (2)每个数值都要大于等于0</div><div class="line"> * @author damonare</div><div class="line"> * @param  arr 待排序数组</div><div class="line"> * @param  maxDigit 最大位数</div><div class="line"> */</div><div class="line"><span class="comment">//LSD Radix Sort</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">radixSort</span>(<span class="params">arr, maxDigit</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> mod = <span class="number">10</span>;</div><div class="line">    <span class="keyword">var</span> dev = <span class="number">1</span>;</div><div class="line">    <span class="keyword">var</span> counter = [];</div><div class="line">    <span class="built_in">console</span>.time(<span class="string">'基数排序耗时'</span>);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; maxDigit; i++, dev *= <span class="number">10</span>, mod *= <span class="number">10</span>) &#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; arr.length; j++) &#123;</div><div class="line">            <span class="keyword">var</span> bucket = <span class="built_in">parseInt</span>((arr[j] % mod) / dev);</div><div class="line">            <span class="keyword">if</span>(counter[bucket]== <span class="literal">null</span>) &#123;</div><div class="line">                counter[bucket] = [];</div><div class="line">            &#125;</div><div class="line">            counter[bucket].push(arr[j]);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">var</span> pos = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; counter.length; j++) &#123;</div><div class="line">            <span class="keyword">var</span> value = <span class="literal">null</span>;</div><div class="line">            <span class="keyword">if</span>(counter[j]!=<span class="literal">null</span>) &#123;</div><div class="line">                <span class="keyword">while</span> ((value = counter[j].shift()) != <span class="literal">null</span>) &#123;</div><div class="line">                      arr[pos++] = value;</div><div class="line">                &#125;</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">console</span>.timeEnd(<span class="string">'基数排序耗时'</span>);</div><div class="line">    <span class="keyword">return</span> arr;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> arr = [<span class="number">3</span>, <span class="number">44</span>, <span class="number">38</span>, <span class="number">5</span>, <span class="number">47</span>, <span class="number">15</span>, <span class="number">36</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">2</span>, <span class="number">46</span>, <span class="number">4</span>, <span class="number">19</span>, <span class="number">50</span>, <span class="number">48</span>];</div><div class="line"><span class="built_in">console</span>.log(radixSort(arr,<span class="number">2</span>)); <span class="comment">//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</span></div></pre></td></tr></table></figure>
<p><strong>基数排序LSD动图演示：</strong></p>
<p><a href="http://img.blog.csdn.net/20160917123313659" target="_blank" rel="external"><img src="http://img.blog.csdn.net/20160917123313659" alt="这里写图片描述"></a></p>
<h4 id="3-算法分析-7"><a href="#3-算法分析-7" class="headerlink" title="(3)算法分析"></a>(3)算法分析</h4><ul>
<li>最佳情况：T(n) = O(n * k)</li>
<li>最差情况：T(n) = O(n * k)</li>
<li>平均情况：T(n) = O(n * k)</li>
</ul>
<p>基数排序有两种方法：</p>
<ul>
<li>MSD 从高位开始进行排序</li>
<li>LSD 从低位开始进行排序</li>
</ul>
<p><strong>基数排序 vs 计数排序 vs 桶排序</strong></p>
<p>这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：</p>
<ol>
<li>基数排序：根据键值的每位数字来分配桶</li>
<li>计数排序：每个桶只存储单一键值</li>
<li>桶排序：每个桶存储一定范围的数值</li>
</ol>
<p>注：此文章转载自:<a href="http://damonare.github.io/2016/09/16/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%EF%BC%88javascript%E6%8F%8F%E8%BF%B0%EF%BC%89/" target="_blank" rel="external">http://damonare.github.io/2016/09/16/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%EF%BC%88javascript%E6%8F%8F%E8%BF%B0%EF%BC%89/</a></p>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[木马逆向分析报告_mpscn4.0.exe]]></title>
      <url>/2016/11/25/%E6%9C%A8%E9%A9%AC%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>​    出于兴趣，前段时间参加了学院组织的‘电信诈骗计算机木马逆向分析’比赛。然而到自己真正去做时，才体会到其难度。。期间数次面对反汇编后的源码，进行debug，由于代码量以及难度大，曾数次产生放弃的念头(-_-)。还好在伙伴的支持下，坚持完成了下去。不过撰稿临近结束时，由于电脑突然蓝屏，再加上之前的文档并没有保存，瞬间泪奔。。。只好熬夜重写分析报告。由于个人技术有限，这篇分析报告很粗浅，请见谅~</p>
<p> <em>[<strong>特洛伊木马</strong>（Trojan Horse），在计算机领域中指的是一种后门程序，是用来盗取其他用户的个人信息，甚至是远程控制对方的计算机而加壳制作，然后通过各种手段传播或者骗取目标用户执行该程序，以达到盗取密码等各种数据资料等目的。与病毒相似，木马程序有很强的隐秘性，随操作系统启动而启动。     —-wikipedia]</em> </p>
<h2 id="1-对mpscn4-0-exe木马程序进行初步观察，分析"><a href="#1-对mpscn4-0-exe木马程序进行初步观察，分析" class="headerlink" title="1.对mpscn4.0.exe木马程序进行初步观察，分析"></a>1.对mpscn4.0.exe木马程序进行初步观察，分析</h2><p><strong>(1).首先用腾讯电脑管家进行初步杀毒，然而并没有任何异常显示，且未发现病毒</strong><br><img src="\imgs\mumafenxi\dngj.png" alt=""></p>
<p><strong>(2).接下来，查看<code>mpscn4.0.exe</code>的属性，发现其版权是属于<code>TeamViewer</code>，然后找到正版的TeamViewer和其进行对比：</strong><br><img src="\imgs\mumafenxi\mm.png" alt="mpscn4.0.exe"><img src="\imgs\mumafenxi\tv.png" alt="TeamViewer"></p>
<p><strong>可以发现，这两个文件的版权都同属于TeamViewer，同时<code>mpscn4.0.exe</code>的文件大小只有4.84MB，而<code>TeamViewer.exe</code>的文件大小却达到22.8MB。</strong><br><strong>(维基百科查询可知：TeamViewer是一个远程控制软件，兼容于Microsoft Windows、Mac OS X、Linux、iOS、Android操作系统，也可以通过网页浏览器连接已安装TeamViewer的电脑。TeamViewer GmbH公司创建于2005年，总部位于德国，致力于研发和销售高端的在线协作和通讯解决方案。)</strong></p>
<p><strong>这里很容易发现<code>mpscn4.0.exe</code>的异常情况：</strong></p>
<ul>
<li><strong>该程序是由TeamViewer经过精简后再改编伪装为自己的软件。</strong></li>
<li><strong>该程序的文件大小只有4.84MB，其功能必定和TeamViewer远程控制软件不同。</strong><br><strong>下图是mpscn4.0.exe在虚拟机中的运行界面：</strong><br><img src="\imgs\mumafenxi\mmjm.png" alt="mmjm"><img src="\imgs\mumafenxi\mmjm2.jpg" alt="mmjm2"></li>
</ul>
<hr>
<h2 id="2-对程序进行反编译，debug，逆向编译，提取出4个dll文件，以及监视其运行创建进程后线程的执行状态"><a href="#2-对程序进行反编译，debug，逆向编译，提取出4个dll文件，以及监视其运行创建进程后线程的执行状态" class="headerlink" title="2.对程序进行反编译，debug，逆向编译，提取出4个dll文件，以及监视其运行创建进程后线程的执行状态"></a>2.对程序进行反编译，debug，逆向编译，提取出4个dll文件，以及监视其运行创建进程后线程的执行状态</h2><p><strong>(1).首先通过反编译,分析其具体的运行流程</strong><br><img src="\imgs\mumafenxi\cxrk.png" alt="cxrk"><br><img src="\imgs\mumafenxi\fhb2.png" alt="fhb2"><br><img src="\imgs\mumafenxi\fhb1.png" alt="fhb1"><br><img src="\imgs\mumafenxi\fhb5.png" alt="fhb5"></p>
<p><strong>(2).虽然我们已学过汇编，但从未接触过逆向反编译，以及如此多的代码量依旧困扰了我们很久，于是便解压缩反编译，通过监视木马程序运行后线程的变化，提取出4个可疑的dll文件：</strong></p>
<p><strong><code>ReadCustomerData.dll</code>，<code>nsis7z.dll</code>，<code>InstallOptions.dll</code>，<code>TvGetVersion.dll</code></strong></p>
<p><img src="\imgs\mumafenxi\fhb6.png" alt="fhb6"><br><img src="\imgs\mumafenxi\fhb.png" alt="fhb"><br><img src="\imgs\mumafenxi\fhb3.png" alt="fhb3"><br><img src="\imgs\mumafenxi\fhb4.jpg" alt="fhb4"></p>
<p><strong>(3).通过分析监视木马程序运行后线程的变化行为大致分析出4个dll文件的情况如下：</strong></p>
<p><strong>(I).<code>ReadCustomerData.dll</code></strong></p>
<ul>
<li><p><strong>拷贝自身到其他目录</strong></p>
<p>%ProgramFiles%\ReadCustomerData.dll</p>
</li>
</ul>
<p><strong>(II).<code>nsis7z.dll</code></strong></p>
<ul>
<li><p><strong>搜索指定窗口，拷贝自身到其他目录</strong></p>
<p>%ProgramFiles%\nsis7z.dll</p>
</li>
</ul>
<p><strong>(III).<code>InstallOptions.dll</code></strong></p>
<ul>
<li><p><strong>拷贝自身到其他目录</strong></p>
<p>%ProgramFiles%\InstallOptions.dll</p>
</li>
</ul>
<p><strong>(IV).<code>TvGetVersion.dll</code></strong></p>
<ul>
<li><p><strong>检测指定文件是否开启WINDOWS文件保护</strong></p>
</li>
<li><p><strong>拷贝自身到其他目录</strong></p>
<p>%ProgramFiles%\TvGetVersion.dll</p>
</li>
<li><p><strong>在其他进程中申请内存</strong></p>
<p>%ProgramFiles%\MSN Gaming Zone\Windows\zClientm.exe</p>
<p>%system%\sysocmgr.exe</p>
<p>%system%\verclsid.exe</p>
</li>
<li><p><strong>添加开机自启动项</strong></p>
<p>[NULL] - %system%\LangWrbk.dll</p>
<p>[NULL] - %system%\ciodm.dll</p>
<p>[NULL] - %system%\ixsso.dll</p>
<p>[NULL] - %system%\mimefilt.dll</p>
<p>[NULL] - %system%\query.dll</p>
<p>[NULL] - CIAdmin.dll</p>
<p>[NULL] - OffFilt.dll</p>
<p>[NULL] - infosoft.dll</p>
<p>[NULL] - nlhtml.dll</p>
<p>[NULL] - query.dll</p>
</li>
<li><p><strong>创建互斥体</strong></p>
<p>“Shell.CMruPidlList”</p>
</li>
<li><p><strong>创建进程</strong></p>
<p>%ProgramFiles%\MSN Gaming Zone\Windows\zClientm.exe%system%\sysocmgr.exe%system%\verclsid.exe%system%\wbem\wmiadap.exe</p>
</li>
</ul>
<hr>
<h2 id="3-分析总结"><a href="#3-分析总结" class="headerlink" title="3.分析总结"></a>3.分析总结</h2><p>​        <strong>木马程序<code>mpscn4.0.exe</code>运行以后首先便开始加载动态链接库，接着在系统指定的文件夹内创建文件，将自身复制进去，然后便将TvGetVersion.dll文件拷贝到其他目录，运行检测指定文件是否开启WINDOWS文件保护，同时在其他进程中申请内存，添加开机自启动项，创建互斥体<code>Shell.CMruPidlList</code>，创建进程<code>wmiadap.exe</code>，进行夺权。当完成这一切操作，实现对本机的控制权后，便开始移动重命名文件，删除之前复制，创建的文件，实行自毁。</strong></p>
<ul>
<li><strong>预防方法：</strong></li>
</ul>
<p><strong>当今这个网络时代，病毒泛滥、木马横行，还有流氓软件、恶意网站等等各路牛鬼蛇神时刻窥伺着，系统中标、软件崩溃那是司空见惯的家常便饭。于是乎各类杀毒软件、网络防火墙、木马清理工具才像雨后春笋般地冒出来。但是，即便用这些工具把电脑“武装到牙齿”，Windows有时候仍然免不了“瘟倒死”的结果：</strong></p>
<p><strong>很多病毒会关闭杀毒软件使之失去保护，</strong></p>
<p><strong>病毒库也有不及时不完整的问题；</strong></p>
<p><strong>网络防火墙如果配置不当会留下漏洞；</strong></p>
<p><strong>木马清理工具也不能面面俱到没有疏漏。</strong></p>
<p><strong>……</strong></p>
<p><strong>总之，平时养成良好的上网习惯，辨别能力，以及安全防范意识，技能才是根本之道。</strong></p>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 网络安全 </tag>
            
            <tag> 木马 </tag>
            
            <tag> 逆向分析 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【系统架构师修炼之道】（19）：操作系统基础知识——分页存储管理]]></title>
      <url>/2016/11/18/%E3%80%90%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88%E4%BF%AE%E7%82%BC%E4%B9%8B%E9%81%93%E3%80%91%EF%BC%8819%EF%BC%89%EF%BC%9A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E2%80%94%E2%80%94%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/</url>
      <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>将一个进程直接分散到许多不相邻的分区中。</p>
<h2 id="页面与页表"><a href="#页面与页表" class="headerlink" title="页面与页表"></a>页面与页表</h2><ul>
<li>页面<br>将一个进程的逻辑地址分成若干大小相同的片,并加以编号，从0开始，如第0页，第1页</li>
<li>块<br>把内存空间分配成页面相同大小的若干存储块，并加以编号，如0#块，1#块</li>
</ul>
<h2 id="页面大小选择"><a href="#页面大小选择" class="headerlink" title="页面大小选择"></a>页面大小选择</h2><p>分页系统中的页面其大小应适中。页面若太小，一方面虽然可使内存碎片减小，从而减少了内存碎片的总空间，有利于提高内存利用率，但另一方面也会使每个进程占用较多的页面，从而导致进程的页表过长，占用大量内存；此外，还会降低页面换进换出的效率。然而，如果选择的页面较大，虽然可以减少页表的长度，提高页面换进换出的速度，但却又会使页内碎片增大。因此，页面的大小应选择适中，且页面大小应是2的幂，通常为512 B～8 KB</p>
<h2 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h2><p><a href="http://ww4.sinaimg.cn/large/74311666jw1ew6ch6zcy0j20gr0dzdgx.jpg" target="_blank" rel="external"><img src="http://ww4.sinaimg.cn/large/74311666jw1ew6ch6zcy0j20gr0dzdgx.jpg" alt="img"></a></p>
<p>页号 = 相对地址 / 块尺寸</p>
<p>页内偏移 = 相对地址 % 块尺寸</p>
<h2 id="地址变换"><a href="#地址变换" class="headerlink" title="地址变换"></a>地址变换</h2><ul>
<li><p>当进程运行时，系统将该进程 PCB 中页表起始地址及其长度送入页表起始地址寄存器（PB）和页表长度寄存器（Pl）</p>
</li>
<li><p>系统将 CPU 给出的逻辑地址由硬件中的地址映射机制自动分成两部分：页号 p 和页内地址 d</p>
</li>
<li><p>比较 p 和 Pl，若 p&gt;= Pl，发生地址越界终端，否则进行地址映射</p>
</li>
<li><p>根据页表起始地址寄存器 Pb 和 p，找到也表中相应表项，即：找到页号 p 的物理块号 p’</p>
</li>
<li><p>将 p’ 与 d 拼在一起形成内存物理地址</p>
<h3 id="逻辑地址转换成物理地址"><a href="#逻辑地址转换成物理地址" class="headerlink" title="逻辑地址转换成物理地址"></a>逻辑地址转换成物理地址</h3></li>
</ul>
<p><a href="http://ww2.sinaimg.cn/large/74311666jw1ew6cggkr6yj20kq0c3my7.jpg" target="_blank" rel="external"><img src="http://ww2.sinaimg.cn/large/74311666jw1ew6cggkr6yj20kq0c3my7.jpg" alt="img"></a></p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>由于页表是存放在内存中的，这使CPU在每存取一个数据时，都要两次访问内存。第一次是访问内存中的页表，从中找到指定页的物理块号，再将块号与页内偏移量W拼接，以形成物理地址。第二次访问内存时，才是从第一次所得地址中获得所需数据(或向此地址中写入数据)。因此，采用这种方式将使计算机的处理速度降低近1/2。可见，以此高昂代价来换取存储器空间利用率的提高，是得不偿失的。</p>
<h3 id="改良方案"><a href="#改良方案" class="headerlink" title="改良方案"></a>改良方案</h3><p><a href="http://ww2.sinaimg.cn/large/74311666jw1ew6cfcvodyj20oh0fptal.jpg" target="_blank" rel="external"><img src="http://ww2.sinaimg.cn/large/74311666jw1ew6cfcvodyj20oh0fptal.jpg" alt="img"></a></p>
<ul>
<li>当进程运行时，系统将该进程 PCB 中页表起始地址及其长度分别送入页表起始地址寄存器（Pb）和页表长度寄存器（Pl）</li>
<li>系统将 CPU 给出逻辑地址由硬件中的地址影射机制自动分成页号 p 和业内地址 d</li>
<li>比较 p 和 Pl，若 p &gt;= Pl，则产生地址越界中断，否则进行地址映射，与此同时，用 p 去查找快表，若找到一项，则终止步骤 d，转入步骤 e</li>
<li>根据页表起始地址寄存器 Pb 和 p，找到页表中相应表项，即 p 的物理块号 p’</li>
<li>将 p’ 和 d 放入块表中，若块表已满，则用淘汰算法，淘汰表中的一项。常用淘汰算法：先进先出（淘汰最先进入的）、访问位（淘汰访问次数最少的）</li>
<li>将 p’ 和 d 拼在一起形成内存物理地址</li>
</ul>
<h2 id="硬件支持"><a href="#硬件支持" class="headerlink" title="硬件支持"></a>硬件支持</h2><p>硬件需要提供页表起始地址寄存器（Pb）和页表长度寄存器（Pl）<br>页表起始地址寄存器保存了正在运行进程页表的首地址<br>页表长度寄存器保存了正在运行进程页表的长度</p>
<h2 id="分页存储的优缺点"><a href="#分页存储的优缺点" class="headerlink" title="分页存储的优缺点"></a>分页存储的优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>作业可不连续存放，解决了可变分区存储的外部碎片问题</li>
<li>有利于多道程序运行</li>
</ul>
<h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>存在内部碎片</li>
<li><p>页的划分没有考虑程序的逻辑结构，不利于共享</p>
<p>注：该文章转载自：<a href="http://mousycoder.com/2015/10/14/the-pragmatic-sa-19/" target="_blank" rel="external">http://mousycoder.com/2015/10/14/the-pragmatic-sa-19/</a></p>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【系统架构师修炼之道】（18）：操作系统基础知识——分区存储管理]]></title>
      <url>/2016/11/17/%E3%80%90%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88%E4%BF%AE%E7%82%BC%E4%B9%8B%E9%81%93%E3%80%91%EF%BC%8818%EF%BC%89%EF%BC%9A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E2%80%94%E2%80%94%E5%88%86%E5%8C%BA%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/</url>
      <content type="html"><![CDATA[<h2 id="存储管理的概念"><a href="#存储管理的概念" class="headerlink" title="存储管理的概念"></a>存储管理的概念</h2><p>逻辑地址：用户程序经编译后，每个目标模块以0为基地址进行的顺序编址，它不是主存中的真实地址，是相对基地址而言的。</p>
<p>物理地址：主存中各存储单元的地址，从统一的基地址进行的顺序编制，是主存中的真实地址，<strong>可以寻址</strong>并实际存在，物理地址又称绝对地址</p>
<p>存储空间：是地址的集合。</p>
<h2 id="分区存储管理"><a href="#分区存储管理" class="headerlink" title="分区存储管理"></a>分区存储管理</h2><h3 id="固定分区存储管理"><a href="#固定分区存储管理" class="headerlink" title="固定分区存储管理"></a>固定分区存储管理</h3><p>预先把可分配的主存储器空间分割成若干个连续区域，每个区域的大小可以相同，也可以不同，存储管理需设置一张“主存分配表”，例如：</p>
<p><img src="https://segmentfault.com/image?src=http://ww3.sinaimg.cn/large/74311666jw1ew47uhbo2ij20ej05h3yt.jpg&amp;objectId=1190000003754517&amp;token=ae9467b92ac25a214b6ca820dd6feb29" alt="img"></p>
<p>当标志位为0 的时候代表没有被占用，如果某一个分区分配给一个作业后，则在状态标志栏里填上占用该分区的作业名。</p>
<p>特点： 存储空间利用率不高，但是分配简单</p>
<h3 id="可变分区存储管理"><a href="#可变分区存储管理" class="headerlink" title="可变分区存储管理"></a>可变分区存储管理</h3><p>根据作业的大小来划分分区，要装入一个作业时，根据作业的需要的主存量查看主存中是否有足够的空间，按需分配，分区的个数也是随机，可以避免空间浪费，但是管理起来，稍微复杂。</p>
<p>具体过程：<br>当一个新的作业要求装入，必须找一个足够大的空闲区，把该作业装入该区，如果找到的空闲去大于作业需求量，则作业装入后把原来的空闲区分成两部分，一部分给作业，另一部分变成较小的空闲区。当该作业撤离时，如果<strong>归还区域和其他空闲区相邻，则可以合成一个较大的空闲区</strong></p>
<p>主存分配表：已分配区情况表，未分配区情况表</p>
<p><img src="https://segmentfault.com/image?src=http://ww3.sinaimg.cn/large/74311666jw1ew48abtnn8j20dq06xt99.jpg&amp;objectId=1190000003754517&amp;token=b1cd2391692e2094f9f11eb356dc2f82" alt="img"></p>
<p>如图：当要装入长度为30K的作业时，先从未分配的情况表中找到长度为36K的空闲区，此时在已分配区添加一条新的条目记录30K的分配，标记作业，然后在未分配表中修改之前长度36K的空闲区的起始地址，长度。作业撤离的时候，将分配区情况表中的标志置为空，将回收的分区以及相邻空闲的分区一起登记到未分配情况表。由于分区的个数不定，则表格最好用链表</p>
<h3 id="分区存储管理的放置策略"><a href="#分区存储管理的放置策略" class="headerlink" title="分区存储管理的放置策略"></a>分区存储管理的放置策略</h3><ul>
<li>首次适应算法<br>目的：尽量减少查找时间<br>具体做法：把空闲区按地址从小到大排列在未分配表，每次按照顺序查找未分配表，把最先找到的满足需求的地址最小的那个空闲分区作为分配对象，这种算法有利于大作业的装入，但是回收的时候，必须移动表格中的登记(重新插入新的记录，保持从大到小)<br>特点：简单，保证有大的空闲分区，保证大作业的执行</li>
<li>最佳适应算法<br>目的：尽可能不把大的空闲区分割成小的分区，保证大作业的需要<br>方法：<strong>从空闲区挑选一个能满足作业要求的最小分区</strong>，这样可以保证不去分割一个更大的区域，使得装入大作业比较容易，但是如果所要求的略大，则分割后的剩下空闲区就太小，以至于无法使用。<br>具体做法：把空闲区按从小到大排序，从最小的区开始查找，一直到能满足要求的区为止。回收的时候，也要对表格重新排序。<br>特点：比较费时，麻烦</li>
<li>最坏适应算法<br>目的：让中，小作业比较好装入<br>具体做法：挑选一个最大的空闲区分割给作业使用，可以让剩下的空闲区不至于太小，这种分配算法把空闲区从大到小排序，回收的时候，也要对表格重新排序。</li>
</ul>
<h3 id="移动技术"><a href="#移动技术" class="headerlink" title="移动技术"></a>移动技术</h3><p>当未分配表中找不到一个足够大的空闲区来装入作业的时候，可以采用移动技术把主存中的作业改变存放区域，</p>
<p>空闲分区的合并方案：</p>
<ul>
<li>调度到某个作业时，系统中的每个空闲分区的尺寸都比它所需要的存储量小，但是空闲区的总存储量大于它的需求，于是进行存储区的合并</li>
<li>只有作业运行完毕归还他所占用的存储分区，系统就进行空闲分区合并</li>
</ul>
<p>一般采用第一种方案。</p>
<h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><ul>
<li>合并会增加系统的时间开销</li>
<li>合并是有条件的，正在进行I/O进程不能移动</li>
<li>合并时尽量减少信息的移动量</li>
</ul>
<p>注：该文章转自：<a href="https://segmentfault.com/u/mousycoder/articles" target="_blank" rel="external">https://segmentfault.com/u/mousycoder/articles</a></p>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[HeadFirst 设计模式 - Chapter8 模板方法设计模式]]></title>
      <url>/2016/11/13/HeadFirst-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-Chapter8-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>在一个方法中定义了一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。</p>
<p>是一种重要的<code>代码复用</code>的重要技巧。从实现的角度来说，这符合<code>封装变化</code>的思想。同时，<code>钩子</code>是被声明在抽象类中，但是<code>只有空的</code>或者<code>默认</code>的算法实现，由子类决定是否进行覆盖，对算法的不同点进行挂钩。当两个或多个类执行的操作可以抽象为统一的步骤算法，只是在每步细节的实现上有差异，则可以依赖模板方法构造一种继承体系（有变化就封装继承体系）</p>
<p>模板 = 方法 = 一组步骤（任何步骤都可以是抽象的，由子类负责实现）这可以确保算法的结构保持不变，同时由子类提供实现。</p>
<p>类图如下：<br><img src="https://segmentfault.com/img/bVmvCN" alt="img"></p>
<p>hook是对那些子类可以选择实现的功能，在抽像类中给出一个简单的默认实现，让子类决定去不去覆盖这里涉及到两个角色：</p>
<p><strong>抽象模板</strong></p>
<ul>
<li>定义了一个或多个抽象操作，以便让子类实现。这些抽象操作叫做基本操作，它们是一个顶级逻辑的组成步骤。</li>
<li>定义并实现了一个模板方法。这个模板方法一般是一个具体方法，它给出了一个顶级逻辑的骨架，而逻辑的组成步骤在相应的抽象操作中，推迟到子类实现。顶级逻辑也有可能调用一些具体方法。</li>
</ul>
<p><strong>具体模板</strong></p>
<ul>
<li>实现父类所定义的一个或多个抽象方法，它们是一个顶级逻辑的组成步骤。</li>
<li>每一个抽象模板角色都可以有任意多个具体模板角色与之对应，而每一个具体模板角色都可以给出这些抽象方法（也就是顶级逻辑的组成步骤）的不同实现，从而使得顶级逻辑的实现各不相同。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractClass</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">templateMethod</span><span class="params">()</span></span>&#123;</div><div class="line">        primitiveOperation1();</div><div class="line">        primitiveOperation2();</div><div class="line">        concreteOperation();</div><div class="line">        hook();</div><div class="line">    &#125; <span class="comment">// 声明为final 以免子类改变这个算法的顺序</span></div><div class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">primitiveOperation1</span><span class="params">()</span></span>; <span class="comment">// 子类实现</span></div><div class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">primitiveOperation2</span><span class="params">()</span></span>; <span class="comment">// 子类实现</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">concreteOperation</span><span class="params">()</span></span>&#123;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hook</span><span class="params">()</span></span>&#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>何时使用抽象方法？何时使用hook?<br>当你的子类必须提供算法中某个步骤的实现时，就用抽象方法；<br>如果算法中这个步骤是可选的，就用hook. 通过使用钩子，让抽象类的子类的负荷减轻itu</p>
<p>注：该文章转载自：<a href="https://segmentfault.com/u/secondlife/articles" target="_blank" rel="external">https://segmentfault.com/u/secondlife/articles</a></p>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[HeadFirst 设计模式 - Chapte7 适配器模式/外观模式]]></title>
      <url>/2016/11/12/HeadFirst-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-Chapte7-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h1 id="适配器设计模式"><a href="#适配器设计模式" class="headerlink" title="适配器设计模式"></a>适配器设计模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>将一个类的接口，转换成客户期望的另一个接口。适配器让原本接口不兼容的类可以合作无间。</p>
<p>适配器模式包括三个角色：目标接口Target,需要适配的类Adaptee,和适配器Adatper.</p>
<p><img src="https://segmentfault.com/img/bVmsYf" alt="img"></p>
<p>explanation:<br>这个模式可以通过创建适配器进行接口转换，让不兼容的接口变得兼容。<br>1.适配器实现目标接口 2. 使用对象组合：适配器与被适配者的组合（turkey）.</p>
<p>在写适配器的时候需要找出每一个适配器方法在被适配器者中的对应的方法是什么。</p>
<hr>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Target:Duck</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Duck</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Adaptee: Turkey</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Turkey</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">gobble</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Adapter:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TurkeyAdapter</span> <span class="keyword">implements</span> <span class="title">Duck</span> </span>&#123;</div><div class="line">    Turkey turkey;</div><div class="line">    TurkeyAdapter(Turkey turkey)&#123;</div><div class="line">        <span class="keyword">this</span>.turkey = turkey;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</div><div class="line">            turkey.fly();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span> </span>&#123;</div><div class="line">        turkey.gobble();</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Client:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DuckTestDrive</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        MallardDuck Duck = <span class="keyword">new</span> MallardDuck();</div><div class="line">        WildTurkey turkey = <span class="keyword">new</span> WildTurkey();</div><div class="line">        Duck turkeyAdapter =  <span class="keyword">new</span> TurkeyAdapter(turkey); <span class="comment">// generate a turkey-like duck</span></div><div class="line">        turkeyAdapter.fly();</div><div class="line">        turkeyAdapter.quack();  </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h1 id="外观设计模式"><a href="#外观设计模式" class="headerlink" title="外观设计模式"></a>外观设计模式</h1><p>提供了一个统一的接口，用来访问子系统中的一群接口，外观定义了一个高层接口，让子系统更容易使用。</p>
<p>外观的意图就是提供一个简单的接口+将客户从组件的子系统中解耦。</p>
<p><img src="https://sf-static.b0.upaiyun.com/v-583541b4/global/img/squares.svg" alt="img"></p>
<h1 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h1><p>装饰者：不改变接口，但假如责任<br>适配器：将一个接口转成另一个接口<br>外观：让接口更简单</p>
<p>注：该文章转载自：<a href="https://segmentfault.com/u/secondlife/articles" target="_blank" rel="external">https://segmentfault.com/u/secondlife/articles</a></p>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[HeadFirst 设计模式 - Chapte5 单例模式]]></title>
      <url>/2016/11/10/HeadFirst-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-Chapte5-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>确保单例对象的类只有一个实例，并提供一个全局访问点(全局资源只有一份)。<br><img src="https://segmentfault.com/img/bVmrne" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">在java实现单例模式需要私有的构造器，一个静态方法和一个静态变量。</div></pre></td></tr></table></figure>
<h1 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h1><p>这样有利于我们协调系统行为。比如在数据库连接或者线程池，或者在某个服务器程序中，该服务器的<code>配置信息</code>存放在一个文件中，这些配置数据由一个单例对象统一读取，然后服务进程中的其他对象再通过这个单例对象获取配置信息。这种方式简化了在复杂环境下的配置管理。</p>
<h1 id="单线程下单例模式"><a href="#单线程下单例模式" class="headerlink" title="单线程下单例模式"></a>单线程下单例模式</h1><p>代码 ： 延迟方式 利用私有的构造器，只有单例类内部才可以调用构造器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton uniqueInstance;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 请求得到一个实例 : 延迟的方式</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">GetInstance</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(uniqueInstance == <span class="keyword">null</span>)&#123;</div><div class="line">            uniqueInstance = <span class="keyword">new</span> Singleton();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> uniqueInstance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="多线程下单例模式的问题"><a href="#多线程下单例模式的问题" class="headerlink" title="多线程下单例模式的问题"></a>多线程下单例模式的问题</h1><p>单例模式在多线程的应用场合下必须小心使用。如果<code>当唯一实例尚未创建时</code>，有两个线程同时调用创建方法，那么它们同时没有检测到唯一实例的存在，从而同时各自创建了一个实例，这样就有两个实例被构造出来，从而违反了单例模式中实例唯一的原则。 解决这个问题的办法是为指示类是否已经实例化的变量提供一个互斥锁 (虽然这样会降低效率)</p>
<p>互斥锁会带来效率的下降（只有在第一次执行这个方法时候才需要同步），改善方法：</p>
<ol>
<li><p>使用“急切eagerly”创建实例，而不用延迟化的方法。</p>
<p>即 静态初始化器中创建单例。保证了线程安全: <code>private static ChocolateBoiler uniqueInstance = new ChocolateBoiler();</code>. JVM在加载这个类时马上创建此唯一的单例实例。JVM保证在任何线程访问uniqueInstance静态变量之前，一定先创建此实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChocolateBoiler</span> </span>&#123;</div><div class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> empty;</div><div class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> boiled;</div><div class="line"><span class="comment">// 静态初始化器中创建单例。保证了线程安全</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> ChocolateBoiler uniqueInstance = <span class="keyword">new</span> ChocolateBoiler();</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="title">ChocolateBoiler</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">this</span>.empty = <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">this</span>.boiled = <span class="keyword">false</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(isEmpty())&#123;</div><div class="line">        empty = <span class="keyword">false</span>;</div><div class="line">        boiled = <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>double checked locking 双重检查加锁</p>
<p>即临界区的代码仅仅需要加锁一次（创建的时候），同时档期获取锁的时候必须是线程安全的。可以用double checked locking来减少竞争和加锁的负担。</p>
</li>
</ol>
<ul>
<li><p><code>double checked locking</code>是单例模式的多线程版本，如果是单线程可以使用延迟模式。</p>
</li>
<li><p><code>double checked locking</code> 模式依就会使用锁——临界区锁定，不要以为可以避免使用锁。</p>
</li>
<li><p><code>double checked locking</code> 模式解决的问题是：当多个线程存在访问临界区企图时，保证了临界区只需要访问一次。</p>
<p>​</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton2</span> </span>&#123;</div><div class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton2 uniqueInstance;</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton2</span><span class="params">()</span></span>&#123;&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton2 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(uniqueInstance == <span class="keyword">null</span>)&#123;</div><div class="line">        <span class="keyword">synchronized</span> (Singleton2.class) &#123;</div><div class="line">            <span class="keyword">if</span>(uniqueInstance == <span class="keyword">null</span>)&#123;</div><div class="line">                uniqueInstance = <span class="keyword">new</span> Singleton2();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> uniqueInstance;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>注：该文章转载自：<a href="https://segmentfault.com/u/secondlife/articles" target="_blank" rel="external">https://segmentfault.com/u/secondlife/articles</a></p>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[HeadFirst 设计模式 - Chapte4 工厂设计模式]]></title>
      <url>/2016/11/09/HeadFirst-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-Chapte4-%E5%B7%A5%E5%8E%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><p>定义</p>
<p><img src="https://segmentfault.com/img/bVmq4F" alt="img"></p>
<p>工厂方法模式定义了一个创建对象的接口，但由子类决定（“决定”是指在编写创建者类creator类时，不需要知道实际创建的product是哪一个。选择使用了哪个子类，自然就决定了实际创建的产品是什么）要实例化的类是哪一个。<br>工厂方法让类把实例化推迟到子类。ConcreteCreator负责创建一个或多个具体产品，只有ConcreteCreator类知道如何创建这些产品（组合使用了ConcreteProduct）。</p>
<p><img src="https://segmentfault.com/img/bVmmWw" alt="img"></p>
<p>简单工厂模式是让一个对象负责所有具体类的实例化，而工厂模式是让一群子类（NYStylePizzaStore, ChicagoStylePizzaStore）来负责实例化。工厂方法 createPizza()是抽象的，所以会依赖子类来处理对象的创建 — 工厂模式通过让子类决定该创建的对象是什么，来达到将对象创建的过程封装的目的。</p>
<hr>
<p>Creator:</p>
<p>PizzaStore实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">PizzaStore</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Pizza <span class="title">orderPizza</span><span class="params">(String type)</span> <span class="comment">// order system</span></span></div><div class="line">    &#123;</div><div class="line">        Pizza pizza;</div><div class="line">        pizza =  createPizza(type);  </div><div class="line">        pizza.prepare();</div><div class="line">        pizza.bake();</div><div class="line">        pizza.cut();</div><div class="line">        pizza.box();</div><div class="line">        <span class="keyword">return</span> pizza;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">abstract</span> Pizza <span class="title">createPizza</span><span class="params">(String type)</span></span>; <span class="comment">// factory method</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChicagoPizzaStore</span> <span class="keyword">extends</span> <span class="title">PizzaStore</span> </span>&#123;</div><div class="line">    Pizza pizza = <span class="keyword">null</span>;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function">Pizza <span class="title">createPizza</span><span class="params">(String type)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(type.equals(<span class="string">"cheese"</span>))&#123;</div><div class="line">            pizza = <span class="keyword">new</span> ChicagoStyleCheesePizza();  <span class="comment">// create specific class </span></div><div class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(type.equals(<span class="string">"pepperoni"</span>))&#123;</div><div class="line">            pizza = <span class="keyword">new</span> NYStylePepperoniPizza(); <span class="comment">// create specific class </span></div><div class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (type.equals(<span class="string">"clam"</span>))&#123;</div><div class="line">            pizza = <span class="keyword">new</span> NYStyleClamPizza(); <span class="comment">// create specific class </span></div><div class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (type.equals(<span class="string">"veggie"</span>))&#123;</div><div class="line">            pizza = <span class="keyword">new</span> NYStyleVeggiePizza(); <span class="comment">// create specific class </span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> pizza;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NYPizzaStore</span> <span class="keyword">extends</span> <span class="title">PizzaStore</span> </span>&#123;</div><div class="line">    Pizza pizza = <span class="keyword">null</span>;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function">Pizza <span class="title">createPizza</span><span class="params">(String type)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(type.equals(<span class="string">"cheese"</span>))&#123;</div><div class="line">            pizza = <span class="keyword">new</span> NYStyleCheesePizza();  <span class="comment">// create specific class </span></div><div class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(type.equals(<span class="string">"pepperoni"</span>))&#123;</div><div class="line">            pizza = <span class="keyword">new</span> NYStylePepperoniPizza(); <span class="comment">// create specific class </span></div><div class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (type.equals(<span class="string">"clam"</span>))&#123;</div><div class="line">            pizza = <span class="keyword">new</span> NYStyleClamPizza(); <span class="comment">// create specific class </span></div><div class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (type.equals(<span class="string">"veggie"</span>))&#123;</div><div class="line">            pizza = <span class="keyword">new</span> NYStyleVeggiePizza(); <span class="comment">// create specific class </span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> pizza;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>Products:</p>
<p>Pizza的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.*;</div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Pizza</span> </span>&#123;</div><div class="line">    String name;</div><div class="line">    String dough;</div><div class="line">    String sauce;</div><div class="line">    ArrayList&lt;String&gt; toppings = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"Preparing "</span> + name);</div><div class="line">        System.out.println(<span class="string">"Tossing dough"</span>);</div><div class="line">        System.out.println(<span class="string">"Adding sauce "</span>);</div><div class="line">        System.out.println(<span class="string">"Adding toppings"</span>);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;toppings.size();i++)&#123;</div><div class="line">            System.out.println(<span class="string">" "</span> + toppings.get(i));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bake</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"Bake for 25 mins at 350"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cut</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"Cutting the pizza into diagonal slics"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">box</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"Place pizza in official PizzaStore box"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> name;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NYStyleCheesePizza</span> <span class="keyword">extends</span> <span class="title">Pizza</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NYStyleCheesePizza</span><span class="params">()</span></span>&#123;</div><div class="line">        name = <span class="string">"NY Style Sauce and Cheese Pizza"</span>;</div><div class="line">        dough = <span class="string">"Thin Crust Dough"</span>;</div><div class="line">        sauce = <span class="string">"Marinara Sauce"</span>;</div><div class="line">        toppings.add(<span class="string">"Grated Regginao Cheese"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>测试类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PizzaTestDrive</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        <span class="comment">// create two stores</span></div><div class="line">        PizzaStore nyStore = <span class="keyword">new</span> NYPizzaStore(); </div><div class="line">        PizzaStore chicagoStore = <span class="keyword">new</span> ChicagoPizzaStore();</div><div class="line">        Pizza pizza = nyStore.orderPizza(<span class="string">"cheese"</span>);</div><div class="line">        System.out.println(<span class="string">"Ethan ordered a"</span> + pizza.getName() + <span class="string">"\n"</span>);</div><div class="line">        pizza = chicagoStore.orderPizza(<span class="string">"cheese"</span>);</div><div class="line">        System.out.println(<span class="string">"Joel ordered a"</span> + pizza.getName() + <span class="string">"\n"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h1 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>抽象工厂模式提供一个接口，用于创建相关或依赖对象的家族（使用抽象的接口来创建一组相关的产品），而不需要明确指定具体类。</p>
<p>这个接口内的每个方法都负责创建一个具体的产品，同时我们利用实现抽象工厂的子类来提供这些具体的做法。</p>
<p><img src="https://segmentfault.com/img/bVmrj5" alt="img"></p>
<h1 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h1><p>创建产品家族 + 将相关产品集合起来。</p>
<p>具体实现 AbstractFactory接口创建一个产品家族</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PizzaIngredientFactory</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> Dough <span class="title">createDough</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> Sause <span class="title">createSauce</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> Cheese <span class="title">createCheese</span><span class="params">()</span></span>;</div><div class="line">    <span class="keyword">public</span> Veggies[] createVeggies();</div><div class="line">    <span class="function"><span class="keyword">public</span> Pepperoni <span class="title">createPepperoni</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> Clams <span class="title">createClam</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>具体工厂实现不同的产品家族。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NYPizzaIngredientFactory</span> <span class="keyword">implements</span> <span class="title">PizzaIngredientFactory</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> Cheese <span class="title">createCheese</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ReggianoCheese();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> Clams <span class="title">createClam</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FreshClams();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Dough <span class="title">createDough</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThinCrustDough();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> Pepperoni <span class="title">createPepperoni</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SlicedPepperoni();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> Sause <span class="title">createSauce</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MarinaraSauce();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> Veggies[] createVeggies() &#123;</div><div class="line">        Veggies veggies[] = &#123; </div><div class="line">                <span class="keyword">new</span> Garlic(), <span class="keyword">new</span> Onion(),<span class="keyword">new</span> Mushroom(),<span class="keyword">new</span> RedPepper()</div><div class="line">        &#125;;</div><div class="line">        <span class="keyword">return</span> veggies;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>抽象的产品 Pizza接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Pizza</span> </span>&#123;</div><div class="line">    String name;</div><div class="line">    Dough dough;</div><div class="line">    Sause sauce;</div><div class="line">    Veggies veggies[];</div><div class="line">    Cheese cheese;</div><div class="line">    Pepperoni pepproni;</div><div class="line">    Clams clam;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bake</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"Bake for 25 mins at 350"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cut</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"Cutting the pizza into diagonal slics"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">box</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"Place pizza in official PizzaStore box"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> name;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</div><div class="line">         <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>具体的产品CheesePizza：使用了（组合）抽象工厂生产的一组产品，集合起来的产品为CheesePizza</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CheesePizza</span> <span class="keyword">extends</span> <span class="title">Pizza</span> </span>&#123;</div><div class="line">    PizzaIngredientFactory ingredientFactory; <span class="comment">// 要制作pizza,需要提供原料，所以每个pizza都需要从构造器参数得到一个工厂</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CheesePizza</span><span class="params">(PizzaIngredientFactory ingredientFactory)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.ingredientFactory = ingredientFactory;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Preparing "</span>+name);</div><div class="line">        dough = ingredientFactory.createDough();</div><div class="line">        sauce = ingredientFactory.createSauce();</div><div class="line">        cheese = ingredientFactory.createCheese();</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>客户的代码只需要涉及抽象工厂</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NYPizzaStore</span> <span class="keyword">extends</span> <span class="title">PizzaStore</span> </span>&#123;</div><div class="line">    <span class="function">Pizza <span class="title">createPizza</span><span class="params">(String item)</span></span>&#123;</div><div class="line">        Pizza pizza = <span class="keyword">null</span>;</div><div class="line">        PizzaIngredientFactory ingredientFactory = <span class="keyword">new</span> NYPizzaIngredientFactory();</div><div class="line"></div><div class="line">        <span class="keyword">if</span>(item.equals(<span class="string">"cheese"</span>))</div><div class="line">        &#123;</div><div class="line">            pizza = <span class="keyword">new</span> CheesePizza(ingredientFactory);</div><div class="line">            pizza.setName(<span class="string">"New York style cheese pizza"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">"veggie"</span>)) &#123;</div><div class="line">            pizza = <span class="keyword">new</span> VeggiePizza(ingredientFactory);     </div><div class="line">            pizza.setName(<span class="string">"New York style veggie pizza"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> pizza;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="工厂模式-VS-抽象工厂模式"><a href="#工厂模式-VS-抽象工厂模式" class="headerlink" title="工厂模式 VS 抽象工厂模式"></a>工厂模式 VS 抽象工厂模式</h1><p>都负责封装对象的创建。都能将对象的创建封装起来，将应用程序解耦，并降低对其特定实现的依赖。</p>
<p>工厂模式使用的是类，通过继承，即利用工厂方法创建对象，需要扩展一个类，并覆盖它的工厂方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">工厂模式提供一个抽象的接口来创建一个产品，由每个子类决定实例化哪个具体的产品（具体类）</div></pre></td></tr></table></figure>
<p>而抽象工厂模式使用的是对象，使用组合。即提供一个用来创建一个产品家族的抽象类型，这个类型的子类定义了产品被产生的方法。要使用这个工厂，必须先实例化它，然后将它传入一些针对抽象类型所写的代码里。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">抽象工厂模式提供一个抽象接口来创建一个产品家族，每个具体子类都创建一个家族产品。</div></pre></td></tr></table></figure>
<p>注：该文章转载自：<a href="https://segmentfault.com/u/secondlife/articles" target="_blank" rel="external">https://segmentfault.com/u/secondlife/articles</a></p>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[HeadFirst 设计模式 - Chapter3 装饰者]]></title>
      <url>/2016/11/07/HeadFirst-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-Chapter3-%E8%A3%85%E9%A5%B0%E8%80%85/</url>
      <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">设计原则：</div><div class="line">类应该对扩展开放，对修改关闭</div></pre></td></tr></table></figure>
<h1 id="装饰者设计模式"><a href="#装饰者设计模式" class="headerlink" title="装饰者设计模式"></a>装饰者设计模式</h1><p>动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案。</p>
<h2 id="主要思想"><a href="#主要思想" class="headerlink" title="主要思想"></a>主要思想</h2><p>为已有功能动态地添加更多功能的一种方式。</p>
<p>从代码实现的角度来说，就是希望在不修改任何底层代码的情况下为对象赋予新的功能。当系统需要添加新功能的时候，通过新的代码来装饰原有类的核心职责或主要行为。这些新加入的代码相当于对原有核心代码的修饰，只在特定的应用场景下出现。</p>
<p>装饰者模式通过组合的方式来扩展对象的行为，而不依赖于继承，也就是说虽然类的框架中包含继承，但只是为了获取正确的类型，而不是继承一种行为。行为来自于装饰者和基础组件，或者与其他装饰者之间的组合关系。</p>
<ul>
<li>装饰者和被装饰对象有相同的超类型。</li>
<li>你可以用一个或多个装饰者包装一个对象。</li>
<li>既然装饰者和被装饰对象有相同的超类型，所以在任何需要原始对象（被包装的）的场合，可以用装饰过的对象代替它。</li>
<li>装饰者可以在所委托被装饰者的行为之前与/或之后，加上自己的行为，以达到特定的目的。</li>
<li>对象可以在任何时候被装饰，所以可以在运行时动态地、不限量地用你喜欢的装饰者来装饰对象</li>
</ul>
<p>类图如下:</p>
<p><img src="https://segmentfault.com/img/bVmg0Y" alt="img"></p>
<p>Component类是基本的被装饰对象抽象类，定义了一些功能接口，ConcreteComponent是一个实际的功能类实现。Decorator则是需要为原始核心功能类动态添加功能时的装饰类。ConcreteDecorator是装饰类的实现，<strong>包含了一个封装的Component对象（实例变量）</strong>，每个装饰者功能独立，只负责对自己包含的对象进行自身功能添加，不关注其他功能。装饰的时候考虑先后顺序（如果需要的话）。装饰者还可以添加新的行为，定义新的状态，新的行为是在旧的行为前面或者后面添加一个计算来实现，新结果的获取将依赖或者委托给旧行为的执行结果。</p>
<p>一个装饰者模式的实际应用是： java io里面的InputStream提供基本的按照流读入一个流，而FileInputStream，StringBufferInputStream，ByteArrayInputStream分别作为几种不同类型的流读取方式。而针对FileInputStream又包含诸如BufferedInputStream，PushBackInputStream这些装饰者为文件输入流提供新的功能，处理不同的应用需求。</p>
<h1 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h1><p>装饰者模式的劣势在于如果客户程序依赖于组件的某种特殊类型，由于装饰是透明的，将出现问题。装饰者模式会导致设计过程中出现许多小对象（每次装饰都需要对象作为新的组件），过渡使用程序会变得复杂。比如在实例化组件的过程中，不仅需要实例化组件，还需要把组件包装进装饰者中，这个问题可以结合工厂模式和生成器模式解决。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>相当于抽象的Compoent类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Beverage</span> </span>&#123;</div><div class="line">    <span class="keyword">protected</span> String description = <span class="string">"Unknown Beverage"</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> description;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">float</span> <span class="title">cost</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>四个具体组件，每个代表一种咖啡类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DarkRoast</span> <span class="keyword">extends</span> <span class="title">Beverage</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DarkRoast</span><span class="params">()</span></span>&#123;</div><div class="line">        description = <span class="string">"Most Excellent Dark Roast"</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">cost</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">1.05f</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>抽象的Decorator类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CondimentDecorator</span> <span class="keyword">extends</span> <span class="title">Beverage</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getDescription</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>具体的装饰者类，每个代表一种扩展功能：调料装饰者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// specific decorator</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mocha</span> <span class="keyword">extends</span> <span class="title">CondimentDecorator</span> </span>&#123;</div><div class="line">    Beverage beverage;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Mocha</span><span class="params">(Beverage beverage)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.beverage = beverage;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">        <span class="keyword">return</span> beverage.getDescription() + <span class="string">", Mocha"</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">        <span class="keyword">return</span> .<span class="number">20f</span>+beverage.cost();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>测试类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StarbuzzCoffee</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Beverage beverage = <span class="keyword">new</span> Espresso();</div><div class="line">        <span class="comment">// A cup of espresso without any condiment</span></div><div class="line">        System.out.println(beverage.getDescription()+<span class="string">"$"</span>+beverage.cost());</div><div class="line">        <span class="comment">// A cup of darkroast with condiment </span></div><div class="line">        Beverage beverage2 = <span class="keyword">new</span> DarkRoast();</div><div class="line">        beverage2 = <span class="keyword">new</span> Mocha(beverage2); <span class="comment">// decorate with mocha</span></div><div class="line">        beverage2 = <span class="keyword">new</span> Mocha(beverage2);<span class="comment">// decorate with mocha again</span></div><div class="line">        beverage2 = <span class="keyword">new</span> Whip(beverage2); <span class="comment">// decorate with whip</span></div><div class="line"></div><div class="line">        System.out.println(beverage2.getDescription()+<span class="string">"$"</span>+beverage2.cost());</div><div class="line">        <span class="comment">// A cup of houseblend with condiment</span></div><div class="line">        Beverage beverage3 = <span class="keyword">new</span> HouseBlend();</div><div class="line">        beverage3 = <span class="keyword">new</span> Soy(beverage3); <span class="comment">// decorate with mocha</span></div><div class="line">        beverage3 = <span class="keyword">new</span> Mocha(beverage3);<span class="comment">// decorate with mocha again</span></div><div class="line">        beverage3 = <span class="keyword">new</span> Whip(beverage3); <span class="comment">// decorate with whip</span></div><div class="line">        System.out.println(beverage3.getDescription()+<span class="string">"$"</span>+beverage3.cost());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注：该文章转载自<a href="https://segmentfault.com/u/secondlife/articles" target="_blank" rel="external">https://segmentfault.com/u/secondlife/articles</a></p>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[译] Emacs Lisp 速成]]></title>
      <url>/2016/10/30/%E8%AF%91-Emacs-Lisp-%E9%80%9F%E6%88%90/</url>
      <content type="html"><![CDATA[<p>原文见 『<a href="http://steve-yegge.blogspot.com/2008/01/emergency-elisp.html" target="_blank" rel="external">Emergency Elisp</a>』。</p>
<p>你用着 Emacs 却不懂 Lisp 吧？欢迎阅读这篇 Emacs Lisp 入门教程！它应该能够助你搞定 Emacs Lisp，从而更加自如的驾驭 Emacs。</p>
<p>有很多种学习 Lisp 的方式，其中有一些方式要比其他方式更为 Lisp。我喜欢的方式是，基于 C++ 或 Java 的编程经验来学习 Lisp。</p>
<p>本文重点放在 Emacs Lisp 语言本身，因为它才是最难的部分，至于成吨的 Emacs 的 API 的用法，你可以通过阅读 Emacs Lisp 文档来学习。</p>
<p>有些事（例如编写生成代码的代码）是 Lisp 擅长的，而有些事（例如算数表达式）是它不擅长的。我不打算谈论 Lisp 是好还是坏，只关心如何用它编程。Emacs Lisp 跟其他语言差不多，最终你会习惯它的。</p>
<p>许多介绍 Lisp 的文章或书籍尝试给你展现 Lisp 之『道』，饱含着奉承、赞颂以及瑜伽之类的东西。事实上，一开始我真正想要的是一本简单的 cookbook，它讲述的是如何用 Lisp 来做一些我日常生活中的事。本文便立意于此，它讲述的是大致是如何用 Emacs Lisp 来写 C，Java 或 JavaScript 就能写的那些代码。</p>
<p>我们开始吧，看看我能够将这篇文章写的多么短小。我要从挺无聊的词法标记、运算符开始，然后讲述如何实现一些众所周知的语句、声明以及一些程序结构。</p>
<h1 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h1><p>Lisp 代码是像 <code>(+ 2 3)</code> 的嵌套的括号表达式。这些表达式有时被称为 form（块）。</p>
<p>也有些不带括号的代码，譬如字符串、数字、符号（必须以单引号为前缀，例如 ‘foo）、向量等，它们被称为原子（基本上可理解为叶结点）。</p>
<p>注释只能是单行的，分号是注释符。</p>
<p>要将一个名为 <code>foo</code> 的变量的值设置为 <code>&quot;bar&quot;</code>，只需：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="name">setq</span> foo <span class="string">"bar"</span>) <span class="comment">; setq means "set quoted"</span></div></pre></td></tr></table></figure>
<p>要以 <code>&quot;flim&quot;</code> 与 <code>&quot;flam&quot;</code> 作为参数值调用一个名为 <code>foo-bar</code> 的函数，只需：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="name">foo-bar</span> <span class="string">"flim"</span> <span class="string">"flam"</span>)</div></pre></td></tr></table></figure>
<p>要进行算 <code>(0x15 * (8.2 + (7 &lt;&lt; 3))) % 2</code>，只需：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(% (<span class="name">*</span> <span class="number">#x15</span> (<span class="name">+</span> <span class="number">8.2</span> (<span class="name">lsh</span> <span class="number">7</span> <span class="number">3</span>))) <span class="number">2</span>)</div></pre></td></tr></table></figure>
<p>也就是说，Lisp 的算数运算用的是前缀表达式，与 Lisp 函数调用方式一致。</p>
<p>Lisp 没有静态类型系统；你可以在程序运行时判断数据的类型。在 Emacs Lisp 中，谓词函数通常以 <code>p</code> 作为后缀，其含义下文有讲。</p>
<p><strong>重点</strong>：可以在 Emacs 的 <code>*scratch*</code> 缓冲区中对 Emacs Lisp 表达式进行求值试验，有以下几种基本的求值方式：</p>
<ul>
<li>将光标移到表达式最后一个封闭的括号的后面，然后执行 <code>C-j</code>（即 Ctrl + j 键）；</li>
<li>将光标移到表达式内部，然后执行 <code>M-C-x</code>（即 Alt + Ctrl + x 键）；</li>
<li>将光标放到表达式最后一个封闭的括号的后面，然后执行 <code>C-x C-e</code>。</li>
</ul>
<p>第一种求值方式会将求值结果显示于 <code>*scratch*</code> 缓冲区，其他两种方式会将求值结果显示于 Emacs 的小缓冲区（Minibuffer）。这些求值方式也适用于 Lisp 的原子——数字、字符串、字符以及符号。</p>
<h1 id="词法"><a href="#词法" class="headerlink" title="词法"></a>词法</h1><p>Lisp 的词法标记（原子级别的程序元素）屈指可数。</p>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>注释是单行的，由分号领起：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="name">blah</span> blah blah) <span class="comment">; I am a comment</span></div></pre></td></tr></table></figure>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>带双引号的就是字符串：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="string">"He's said: \"Emacs Rules\" one time too many."</span></div></pre></td></tr></table></figure>
<p>要让字符串含有换行符，只需：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">"Oh Argentina!</div><div class="line">Your little tin of pink meat</div><div class="line">Soars o'er the Pampas"</div></pre></td></tr></table></figure>
<h2 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h2><ul>
<li><code>?</code>x 可以获得字符 x 的 ASCII 码，这里的 x 可以是任意 ASCII 编码的字符。例如 <code>?a</code> 的求值结果是 ASCII 码 <code>97</code>，而 <code>?</code>（问号后面是一个空格）的求知结果是 32。</li>
<li><code>?</code> 后面尾随的字符，有些需要逃逸，例如 <code>?\(</code>，<code>?\)</code> 以及 <code>?\\</code>。</li>
<li>Emacs 22+ 支持 Unicode，这超出了本文范围。</li>
</ul>
<p>字符本质上只是整型数值，因此你可以对它们做算术运算（例如，从 <code>?a</code> 迭代到 <code>?z</code>）。</p>
<h2 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h2><ul>
<li>整型数的位数是 29 位（并非大家习惯的 32 位）；</li>
<li>二进制数，前缀是 <code>#b</code>，例如 <code>#b10010110</code>；</li>
<li>八进制数：<code>#o[0-7]+</code>，例如 <code>#o377</code>；</li>
<li>十六进制数，前缀是 <code>#x</code>，例如 <code>#xabcd</code>，<code>xDEADBEE</code>；</li>
<li>浮点数：位数是 64；</li>
<li>科学计数，例如 <code>5e-10</code>，<code>6.02e23</code>。</li>
</ul>
<p>在不支持大整数的 Emacs Lisp 中，变量 <code>most-positive-fixnum</code> 与 <code>most-negative-fixnum</code> 分别是最大的与最小的整型数。Emacs 22+ 提供了一个叫做 <code>calc</code> 的大整数/数学库，以备不时之需。也就是说，Emas Lisp 的算数运算会发生上溢和下溢，如同你在 C 或 Java 中遇到的情况相似。</p>
<h2 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h2><p>符号 <code>t</code> 是 <code>true</code>，符号 <code>nil</code> 是 <code>false</code>（与 <code>null</code> 同义）。</p>
<p>在 Emacs Lisp 中，<code>nil</code> 是唯一的『假』值，其他非 <code>nil</code> 值皆为『真』值，也就是说像空字串、0、<code>&#39;false</code> 符号以及空向量之类，都是真值。不过，空的列表 <code>&#39;()</code> 与 <code>nil</code> 等价。</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>Emacs Lisp 有定长数组，名曰『向量』(Vector)。可使用方括号来构建预先初始化的字面向量，例如：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[-2 0 2 4 6 8 10]</div><div class="line">["No" "Sir" "I" "am" "a" "real" "horse"]</div><div class="line">["hi" 22 120 89.6 2748 [3 "a"]]</div></pre></td></tr></table></figure>
<p>注意，要使用空白字符来隔离数组中的元素，不要使用逗号。</p>
<p>向量中存储的数据可以是混合类型，也能够对向量进行嵌套。通常是使用 <code>make-vector</code> 来构建向量，因为字面向量是单例，对此不要惊讶。</p>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>Lisp 重度依赖链表，因此专门为它提供了词法标记。圆括号里的任何东西都是列表，除非你引用了它，否则 Lisp 解释器就会像函数调用那样对其进行求值。在 Lisp 中有以下几种列表引用形式：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">(<span class="name">quote</span> (<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>)) <span class="comment">;  产生列表 (1 2 3)，并且不会对列表元素进行求值</span></div><div class="line"></div><div class="line">'(<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>)  <span class="comment">; 单引号是 (quote (...)) 形式的简写，注意它在左括号之外</span></div><div class="line"></div><div class="line">(<span class="name">list</span> <span class="number">1</span> (<span class="name">+</span> <span class="number">1</span> <span class="number">1</span>) <span class="number">3</span>) <span class="comment">; 也可以产生列表 (1 2 3)，因为 Lisp 解释器会首先对列表元素进行求值</span></div><div class="line"></div><div class="line">`(<span class="number">1</span> ,(+ <span class="number">1</span> <span class="number">1</span>) <span class="number">3</span>)  <span class="comment">; 也可以产生列表 (1 2 3)，这是经过『反引号』模板系统产生的</span></div></pre></td></tr></table></figure>
<p>关于列表还有很多东西可说，但是其他人已经都说过了。</p>
<h2 id="序对"><a href="#序对" class="headerlink" title="序对"></a>序对</h2><p>你可以直接设定 Lisp 列表的首部与尾部，将其作为 2 个元素的无类型结构来使用。语法是 <code>(head-val . tail-value)</code>，不过必须是引用的形式（见上文）。</p>
<p>对于较小的数据集，检索表的数据结构通常设计为关联列表（即所谓的 <code>alist</code>），这只不过是带点的序对所构成的列表而已，例如：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">'( (apple . <span class="string">"red"</span>)</div><div class="line">   (banana . <span class="string">"yellow"</span>)</div><div class="line">   (orange . <span class="string">"orange"</span>) )</div></pre></td></tr></table></figure>
<p>Emacs Lisp 有内建的哈希表，位向量等数据结构，但是它们并没有语法，你只能通过函数来创建它们。</p>
<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><p>有些运算，在其他语言中体现为运算符的形式，而在 Emacs Lisp 中体现为函数的调用。</p>
<h2 id="等号"><a href="#等号" class="headerlink" title="等号"></a>等号</h2><p>数值相等判断：<code>(= 2 (+ 1 1))</code>，单个等号，求值结果为 <code>t</code> 或 <code>nil</code>，也能用于浮点数比较。</p>
<p>数值不相等判断：<code>(/= 2 3)</code>，看上去像相除后赋值，但并不是。</p>
<p>值相等判断：<code>(eq &#39;foo 2)</code>，类似于 Java 的 <code>==</code>，适用于整型、符号、限定字串（Interned String）以及对象引用的相等比较。对于浮点数，可使用 <code>eql</code>（或者 <code>=</code>）。</p>
<p>结构的深度相等比较：使用 <code>equal</code>，例如：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="name">equal</span> '(<span class="number">1</span> <span class="number">2</span> (<span class="number">3</span> <span class="number">4</span>)) (<span class="name">list</span> <span class="number">1</span> <span class="number">2</span> (<span class="name">list</span> <span class="number">3</span> (<span class="name">*</span> <span class="number">2</span> <span class="number">2</span>)))) <span class="comment">; 求值结果为 t</span></div></pre></td></tr></table></figure>
<p><code>equal</code> 函数类似于 Java 的 <code>Object.equals()</code>，适用于列表、向量、字符串等类型。</p>
<h2 id="字符串-1"><a href="#字符串-1" class="headerlink" title="字符串"></a>字符串</h2><p>字符串没有任何运算符，只是有很多字符串操作函数，下面是几个常用的函数：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">(<span class="name">concat</span> <span class="string">"foo"</span> <span class="string">"bar"</span> <span class="string">"baz"</span>)  <span class="comment">; 求值结果为 "foobarbaz"</span></div><div class="line"></div><div class="line">(<span class="name">string=</span> <span class="string">"foo"</span> <span class="string">"baz"</span>)  <span class="comment">; 求值结果为 nil (false)，也可以用 equal</span></div><div class="line"></div><div class="line">(<span class="name">substring</span> <span class="string">"foobar"</span> <span class="number">0</span> <span class="number">3</span>) <span class="comment">; 求值结果为 "foo"</span></div><div class="line"></div><div class="line">(<span class="name">upcase</span> <span class="string">"foobar"</span>)  <span class="comment">; 求值结果为 "FOOBAR"</span></div></pre></td></tr></table></figure>
<p>使用 <code>M-x apropos RET \bstring\b RET</code> 可查看所有与字符串操作相关的函数说明。</p>
<h2 id="算术"><a href="#算术" class="headerlink" title="算术"></a>算术</h2><p>还是画个表容易看……</p>
<p><img src="https://segmentfault.com/img/bVuLDO" alt="img"></p>
<h1 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h1><p>这一节会给出一些类似 Java 语句的代码片段。它不复杂，仅仅是让你能够上手的方子。</p>
<h2 id="if-else"><a href="#if-else" class="headerlink" title="if/else"></a>if/else</h2><p>情况 1：无 <code>else</code> 从句（<code>(if test-expr expr)</code>）</p>
<p>示例：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(<span class="name">if</span> (<span class="name">&gt;=</span> <span class="number">3</span> <span class="number">2</span>)</div><div class="line">  (<span class="name">message</span> <span class="string">"hello there"</span>))</div></pre></td></tr></table></figure>
<p>情况 2：<code>else</code> 从句（<code>(if test-expr then-expr else-expr)</code>）</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(<span class="name">if</span> (<span class="name">today-is-friday</span>)         <span class="comment">; test-expr</span></div><div class="line">    (<span class="name">message</span> <span class="string">"yay, friday"</span>)   <span class="comment">; then-expr</span></div><div class="line">  (<span class="name">message</span> <span class="string">"boo, other day"</span>)) <span class="comment">; else-expr</span></div></pre></td></tr></table></figure>
<p>如果你需要在 <code>then-expr</code> 中存在多条表达式，可使用 <code>progn</code>——类似于 C 或 Java 的花括号，对这些表达式进行封装：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(<span class="name">if</span> (<span class="name">zerop</span> <span class="number">0</span>)</div><div class="line">    (<span class="name">progn</span></div><div class="line">      (<span class="name">do-something</span>)</div><div class="line">      (<span class="name">do-something-else</span>)</div><div class="line">      (<span class="name">etc-etc-etc</span>)))</div></pre></td></tr></table></figure>
<p>在 <code>else-expr</code> 中没必要使用 <code>progn</code>，因为 <code>then-expr</code> 之后的所有东西都被视为 <code>else-expr</code> 的一部分，例如：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(<span class="name">if</span> (<span class="name">today-is-friday</span>)</div><div class="line">    (<span class="name">message</span> <span class="string">"yay, friday"</span>)</div><div class="line">  (<span class="name">message</span> <span class="string">"not friday!"</span>)</div><div class="line">  (<span class="name">non-friday-stuff</span>)</div><div class="line">  (<span class="name">more-non-friday-stuff</span>))</div></pre></td></tr></table></figure>
<p>情况 3： 通过 <code>if</code> 语句的嵌套可实现 <code>else-if</code> 从句，也可以用 <code>cond</code>（下文有讲）：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(<span class="name">if</span> 'sunday</div><div class="line">    (<span class="name">message</span> <span class="string">"sunday!"</span>)      <span class="comment">; then-expr</span></div><div class="line">  (<span class="name">if</span> 'saturday              <span class="comment">; else-if</span></div><div class="line">      (<span class="name">message</span> <span class="string">"saturday!"</span>)  <span class="comment">; next then-expr</span></div><div class="line">    (<span class="name">message</span> (<span class="string">"weekday!"</span>)))) <span class="comment">; final else</span></div></pre></td></tr></table></figure>
<p>情况 4：无 <code>else-if</code> 的多分支表达式——使用 <code>when</code>：</p>
<p>如果没有 <code>else</code> 从句，可以使用 <code>when</code>，这是一个宏，它提供了隐式的 <code>progn</code>：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(<span class="name">when</span> (<span class="name">&gt;</span> <span class="number">5</span> <span class="number">1</span>)</div><div class="line">  (<span class="name">blah</span>)</div><div class="line">  (<span class="name">blah-blah</span>)</div><div class="line">  (<span class="name">blah</span> blah blah))</div></pre></td></tr></table></figure>
<p>也可以用 <code>unless</code>，它的测试表达式与 <code>when</code> 反义：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(<span class="name">unless</span> (<span class="name">weekend-p</span>)</div><div class="line">  (<span class="name">message</span> <span class="string">"another day at work"</span>)</div><div class="line">  (<span class="name">get-back-to-work</span>))</div></pre></td></tr></table></figure>
<h2 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h2><p>经典的 <code>switch</code> 语句，Emacs Lisp 有两个版本：<code>cond</code> 与 <code>case</code>。</p>
<p>Emacs Lisp 的 <code>cond</code> 与 <code>case</code> 不具备 <code>switch</code> 的查表优化功能，它们本质上是嵌套的 <code>if-then-else</code> 从句。不过，如果你有多重嵌套，用 <code>cond</code> 或 <code>case</code> 要比 <code>if</code> 表达式更美观一些。<code>cond</code> 的语法如下：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">(<span class="name">cond</span></div><div class="line">  (<span class="name">test-1</span></div><div class="line">    do-stuff-1)</div><div class="line">  (<span class="name">test-2</span></div><div class="line">    do-stuff-2)</div><div class="line">  ...</div><div class="line">  (<span class="name">t</span></div><div class="line">    do-default-stuff))</div></pre></td></tr></table></figure>
<p><code>do-stuff</code> 部分可以是任意数量的语句，无需用 <code>progn</code> 封装。</p>
<p>与经典的 <code>switch</code> 不同，<code>cond</code> 可以处理任何测试表达式（它只是依序检验这些表达式），并非仅限于数字。这样所带来的负面影响是，<code>cond</code> 对数字不进行任何特定的转换，因此你不得不将它们与某种东西进行比较。下面是字符串比较的示例：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">(<span class="name">cond</span></div><div class="line"> ((<span class="name">equal</span> value <span class="string">"foo"</span>)  <span class="comment">; case #1 – notice it's a function call to `equal' so it's in parens</span></div><div class="line">  (<span class="name">message</span> <span class="string">"got foo"</span>)  <span class="comment">; action 1</span></div><div class="line">  (<span class="name">+</span> <span class="number">2</span> <span class="number">2</span>))             <span class="comment">; return value for case 1</span></div><div class="line"> ((<span class="name">equal</span> value <span class="string">"bar"</span>)  <span class="comment">; case #2 – also a function call (to `+')</span></div><div class="line">  <span class="literal">nil</span>)                 <span class="comment">; return value for case 2</span></div><div class="line"> (<span class="name">t</span>                    <span class="comment">; default case – not a function call, just literal true</span></div><div class="line">  'hello))             <span class="comment">; return symbol 'hello</span></div></pre></td></tr></table></figure>
<p>末尾的 <code>t</code> 从句是可选的。若某个从句匹配成功，那么这个从句的求值结果便是整个 <code>cond</code> 表达式的求值结果。</p>
<p>Emacs <code>&#39;cl</code>（Common Lisp）包（译注：Emacs Lisp 手册推荐使用 <code>&#39;cl-lib</code> ，因为 <code>&#39;cl</code> 过时了），提供了 <code>case</code>，它能够进行数值或符号比较，因此它看上去比较像标准的 <code>switch</code>：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">(<span class="name">case</span> <span class="number">12</span></div><div class="line">  (<span class="number">5</span> <span class="string">"five"</span>)</div><div class="line">  (<span class="number">1</span> <span class="string">"one"</span>)</div><div class="line">  (<span class="number">12</span> <span class="string">"twelve"</span>)</div><div class="line">  (<span class="name">otherwise</span></div><div class="line">   <span class="string">"I only know five, one and twelve."</span>))  <span class="comment">; result:  "twelve"</span></div></pre></td></tr></table></figure>
<p>使用 <code>case</code>，默认从句可以用 <code>t</code>，也可以用 <code>otherwise</code>，但它必须最后出现。</p>
<p>使用 <code>case</code> 更干净一些，但是 <code>cond</code> 更通用。</p>
<h2 id="while"><a href="#while" class="headerlink" title="while"></a>while</h2><p>Emacs Lisp 的 <code>while</code> 函数相对正常一些，其语法为 <code>(while test body-forms)</code>。</p>
<p>例如，可在 <code>*scratch*</code> 缓冲区中执行以下代码：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(<span class="name">setq</span> x <span class="number">10</span></div><div class="line">      total <span class="number">0</span>)</div><div class="line">(<span class="name">while</span> (<span class="name">plusp</span> x)  <span class="comment">; 只要 x 是正数</span></div><div class="line">  (<span class="name">incf</span> total x)  <span class="comment">; total += x</span></div><div class="line">  (<span class="name">decf</span> x))       <span class="comment">; x -= 1</span></div></pre></td></tr></table></figure>
<p>在上述代码中，我们首先设置了两个全局变量 <code>x=10</code> 与 <code>total=0</code>，然后执行循环。循环结束后，可对 <code>total</code> 进行求值，结果为 55（从 1 到 10 求和结果）。</p>
<h2 id="break-continue"><a href="#break-continue" class="headerlink" title="break/continue"></a>break/continue</h2><p>Lisp 的 <code>cache/throw</code> 能够实现控制流的向上级转移，它与 Java 或 C++ 的异常处理相似，尽管功能上要弱一些。</p>
<p>在 Emacs Lisp 中要 <code>break</code> 一个循环，可以将 <code>(cache &#39;break ...)</code> 置于循环外部，然后在循环内部需要中断的地方放置 <code>(throw &#39;break value)</code>，例如：</p>
<p><img src="https://segmentfault.com/img/bVuLDP" alt="img"></p>
<p>符号 <code>&#39;break</code> 不是 Lisp 语法，而是自己取的名字——要取容易理解的名字，譬如对于多重循环，可在 <code>cache</code> 表达式中用 <code>&#39;break-outer</code> 与 <code>&#39;break-inner</code> 之类的名字。</p>
<p>如果你不关心 <code>while</code> 循环的『返回值』，可以 <code>(throw &#39;break nil)</code>。</p>
<p>要实现循环中的 <code>continue</code>，可将 <code>cache</code> 置入循环内部之首。例如，对从 1 到 99 的整数求和，并且在该过程中避开能被 5 整除的数（这是个蹩脚的例子，只是为了演示 <code>continue</code> 的用法）:</p>
<p><img src="https://segmentfault.com/img/bVuLDQ" alt="img"></p>
<p>可将这些示例组合起来，在同一个循环内实现 <code>break</code> 与 <code>continue</code>：</p>
<p><img src="https://segmentfault.com/img/bVuLDS" alt="img"></p>
<p>上面的循环的计算结果为 4000，即 <code>total</code> 的值。要得到这个结果，还有更好的计算方式，不过我需要足够简单的东西来讲述如何在 Lisp 中实现 <code>break</code> 与 <code>continue</code>。</p>
<p><code>catch/throw</code> 机制能够像异常那样跨函数使用。不过，它的设计并非真的是面向异常或错误处理——Emacs Lisp 另外有一套机制来做这些事，也就是后文的 <code>try/catch</code> 这一节所讨论东西。你应该习惯在 Emacs Lisp 代码中使用 <code>catch/throw</code> 进行控制流转移。</p>
<h2 id="do-while"><a href="#do-while" class="headerlink" title="do/while"></a>do/while</h2><p>Emacs Lisp 中最容易使用的循环机制是 Common Lisp 包提供的 <code>loop</code> 宏。要使用这个宏，需要加载 <code>cl-lib</code> 包：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="name">require</span> 'cl-lib) <span class="comment">; 获取大量的 Common Lisp 里的好东西</span></div></pre></td></tr></table></figure>
<p><code>loop</code> 宏是带有大量特征的微语言，值得好好观摩一番。我主要用它来演示如何构造一些基本的循环。</p>
<p>基于 <code>loop</code> 所实现的 <code>do/while</code> 机制如下：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(<span class="name">loop</span> do</div><div class="line">  (<span class="name">setq</span> x (<span class="number">1</span>+ x))</div><div class="line">  while</div><div class="line">  (<span class="name">&lt;</span> x <span class="number">10</span>))</div></pre></td></tr></table></figure>
<p>在 <code>do</code> 与 <code>while</code> 之间可以有任意数量的 Lisp 表达式。</p>
<h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><p>C 风格的 <code>for</code> 循环由四种成分构成：变量初始化，循环体，条件测试以及自增。用 <code>loop</code> 宏也能模拟出这种循环结构。例如，像下面的 JavaScript 的循环结构：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var result = [];</div><div class="line">for (var i = 10, j = 0; j &lt;= 10; i--, j += 2) &#123;</div><div class="line">  result.push(i+j);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于这样的循环结构，基于 Emacs Lisp 的 <code>loop</code> 可将其模拟为：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">(<span class="name">loop</span> with result = '()         <span class="comment">; 初始化：只被执行一次</span></div><div class="line">      for i downfrom <span class="number">10</span>         <span class="comment">; i 从 10 递减</span></div><div class="line">      for j from <span class="number">0</span> by <span class="number">2</span>         <span class="comment">; j 从 0 开始自增 2</span></div><div class="line">      while (<span class="name">&lt;</span> j <span class="number">10</span>)            <span class="comment">; j &gt;= 10 时循环终止</span></div><div class="line">      do</div><div class="line">      (<span class="name">push</span> (<span class="name">+</span> i j) result)     <span class="comment">; 将 i + j 的求值结果入栈</span></div><div class="line">      finally</div><div class="line">      return (<span class="name">nreverse</span> result)) <span class="comment">; 将 result 中存储的数据次序逆转，然后作为求值结果</span></div></pre></td></tr></table></figure>
<p>由于 <code>loop</code> 表达式有很多选项，这样写虽然繁琐，但是容易理解。</p>
<p>注意，上述代码中，<code>loop</code> 声明了一个数组 result，然后将它作为『返回』值。事实上，<code>loop</code>　也能处理循环之外的变量，这种情况下就不需要　<code>finally return</code>　从句了。</p>
<p><code>loop</code>　宏出人意料的灵活。有关它的全面介绍超出了本文范畴，但是如果你想驾驭　Emacs Lisp，那么你有必要花一些时间揣摩一下它。</p>
<h2 id="for-in"><a href="#for-in" class="headerlink" title="for .. in"></a>for .. in</h2><p>如果你迭代访问一个集合，Java　提供了『智能』的　<code>for</code>　循环，JavaScript　提供了　<code>for .. in</code> 与　<code>for each .. in</code>。这些，在 Lisp 里也能做到，但是你可能需要对 <code>loop</code> 宏有很好的理解，它可以为迭代过程提供一站式服务。</p>
<p>最基本的方式是 <code>loop for var in sequence</code>，然后针对特定结果做一些处理。例如，你可以将 <code>sequence</code> 中的东西收集起来（或者将一个函数作用与它们）：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(<span class="name">loop</span> for i in '(<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span>)</div><div class="line">    collect (<span class="name">*</span> i i))            <span class="comment">;  结果为 (1 4 9 16 25 36)</span></div></pre></td></tr></table></figure>
<p><code>loop</code> 宏能够迭代列表元素、列表单元、向量、哈希键序列、哈希值序列、缓冲区、窗口、窗框、符号以及你想遍历的任何东西。请参阅 Emacs 手册获得更多信息。</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>用 <code>defun</code>（<strong>de</strong>fine <strong>fun</strong>ction）定义函数。</p>
<p>语法：<code>(defun 函数名 参数列表 [可选的文档化注释] 函数体)</code></p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(<span class="name">defun</span> square (<span class="name">x</span>)</div><div class="line">  <span class="string">"Return X squared."</span></div><div class="line">  (<span class="name">*</span> x x))</div></pre></td></tr></table></figure>
<p>对于无参函数，只需让参数列表为空即可：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(<span class="name">defun</span> hello ()</div><div class="line">  <span class="string">"Print the string `hello' to the minibuffer."</span></div><div class="line">  (<span class="name">message</span> <span class="string">"hello!"</span>))</div></pre></td></tr></table></figure>
<p>函数体可由任意数量的表达式构成，函数的返回值是最后那个表达式的求值结果。由于函数的返回类型没有声明，因此有必要在文档化注释中注明函数的返回类型。对函数进行求值之后，其文档化注释可通过 <code>M-x describe-function</code> 查看。</p>
<p>Emacs Lisp 不支持函数/方法的重载，但是它支持 Python 和 Ruby 所提供的那种可选参数与 rest 参数。你可以使用 Common Lisp 化的参数列表，在使用 <code>defun*</code> 宏代替 <code>defun</code> 时，可支持关键字参数（keyword arguments，见后文的 <code>defstruct</code> 一节）。<code>defun*</code> 宏也允许使用 <code>(return &quot;foo&quot;)</code> 这种控制流转移方式来代替 <code>catch/throw</code> 机制。</p>
<p>如果你像让自己定义的函数能够作为 <code>M-x</code> 命令来执行，只需将 <code>(interactive)</code> 作为函数体内的第一个表达式，亦即位于文档化注释字串之后。</p>
<h2 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h2><p>在函数中要声明局部变量，可使用 <code>let</code> 表达式。基本语法是 <code>(let var-decl var-decl)</code>：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">(<span class="name">let</span> ((<span class="name">name1</span> value1)</div><div class="line">      (<span class="name">name2</span> value2)</div><div class="line">      name3</div><div class="line">      name4</div><div class="line">      (<span class="name">name5</span> value5)</div><div class="line">      name6</div><div class="line">      ...))</div></pre></td></tr></table></figure>
<p>每个 <code>var-decl</code> 要么仅仅是变量名，要么就是 <code>(变量名 初始值)</code> 形式。初始化的变量与未初始化的变量出现的次序是任意的。未初始化的变量，其值为 <code>nil</code>。</p>
<p>在一个函数中可以有多条 <code>let</code> 表达式，但是为了性能起见，通常是将变量声明都放到开始的 <code>let</code> 表达式中，这样会快一点。不过，你应该写清晰的代码。</p>
<h2 id="引用参数"><a href="#引用参数" class="headerlink" title="引用参数"></a>引用参数</h2><p>C++ 有引用参数，函数可以修改调用者堆栈中的变量。Java 没有这个功能，因此有时你不得不迂回的向函数传递单元素数组，或一个对象，或别的什么东西来模拟这个功能。</p>
<p>Emacs Lisp 也没有真正的向函数传递引用的机制，但是它有动态域（Dynamic Scope），这意味着你可以用任何方式修改位于调用者堆栈中的变量。看下面这两个函数：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">(<span class="name">defun</span> foo ()</div><div class="line">  (<span class="name">let</span> ((<span class="name">x</span> <span class="number">6</span>))  <span class="comment">; 定义了一个（栈中的）局部变量 x，将其初始化为 6</span></div><div class="line">    (<span class="name">bar</span>)       <span class="comment">; 调用 bar 函数</span></div><div class="line">    x))         <span class="comment">; 返回 x</span></div><div class="line"></div><div class="line">(<span class="name">defun</span> bar ()</div><div class="line">  (<span class="name">setq</span> x <span class="number">7</span>))   <span class="comment">; 在调用者的栈中搜索 x 并修改它的值</span></div></pre></td></tr></table></figure>
<p>如果你调用了 <code>(foo)</code>，返回值为 7。</p>
<p>动态域通常被认为是近乎邪恶的坏设计，但是它有时也能派上用场。即使它真的很糟糕，通过它也能了解一些 Emacs 的内幕。</p>
<blockquote>
<p>译注：Emacs 24 对词法域（Lexical Scope）提供了支持，但是 Emacs Lisp 默认依然是动态域。要开启词法域功能，可在 .el 文件的第一行添加以下信息：</p>
</blockquote>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment">;; -*- lexical-binding: t -*-</span></div></pre></td></tr></table></figure>
<h2 id="return"><a href="#return" class="headerlink" title="return"></a>return</h2><p>Lisp 函数默认是返回最后一个被求值的表达式的结果。通过一些构造技巧，也可以让每个可能的返回结果安排在函数的尾部位置。例如：</p>
<p><img src="https://segmentfault.com/img/bVuLDT" alt="img"></p>
<p>上述 Lisp 函数 <code>day-name</code> 的返回值是最后一个表达式的求值结果，因此无论我们怎么嵌套 <code>if</code>，都能自动产生一个结果返回，因此这里不需要显式的 <code>return</code> 语句。</p>
<p>不过，有时用 <code>if</code> 嵌套的方式来重构函数的返回形式会不太方便，它较适合一些小的函数。对于一些规模较大并且嵌套较深的函数，你可能希望函数能够在较早的时机返回。在 Emacs Lisp 中，这一需求可基于 <code>break</code> 与 <code>continue</code> 来实现。上文中的 <code>day-name</code> 可重构为：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">(<span class="name">defun</span> day-name ()</div><div class="line">  (<span class="name">let</span> ((<span class="name">date</span> (<span class="name">calendar-day-of-week</span></div><div class="line">               (<span class="name">calendar-current-date</span>))))  <span class="comment">; 0-6</span></div><div class="line">    (<span class="name">catch</span> 'return</div><div class="line">      (<span class="name">case</span> date</div><div class="line">        (<span class="number">0</span></div><div class="line">         (<span class="name">throw</span> 'return <span class="string">"Sunday"</span>))</div><div class="line">        (<span class="number">6</span></div><div class="line">         (<span class="name">throw</span> 'return <span class="string">"Saturday"</span>))</div><div class="line">        (<span class="name">t</span></div><div class="line">         (<span class="name">throw</span> 'return <span class="string">"weekday"</span>))))))</div></pre></td></tr></table></figure>
<p>显然，使用 <code>catch/throw</code> 会降低程序性能，但是有时你会需要用它来消除太深的嵌套结构。</p>
<h2 id="try-catch"><a href="#try-catch" class="headerlink" title="try/catch"></a>try/catch</h2><p>前文已经讲了 <code>catch/throw</code>，它类似于异常，可用于控制流转移。</p>
<p>Emacs 真正的错误处理机制叫做『条件』系统，本文不打算对此予以全面介绍，仅涉及如何捕捉异常以及如何忽略它们。</p>
<p>下面是一个一般化的 <code>condition-case</code> 结构，而且我也给出了 Java 的等价描述。</p>
<p><img src="https://segmentfault.com/img/bVuLDX" alt="img"></p>
<p>如果你想让 <code>cache</code> 块为空，可使用 <code>ignore-errorse</code>：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(<span class="name">ignore-errors</span></div><div class="line">  (<span class="name">do-something</span>)</div><div class="line">  (<span class="name">do-something-else</span>))</div></pre></td></tr></table></figure>
<p>有时你的启动文件（译注：可能是 .emacs 或init.el文件）可能不是总是正确工作。可以使用 <code>ignore-errors</code> 来封装 Emacs Lisp 代码，这样即使被封装的代码出错，也不会导致 Emacs 启动失败。</p>
<p><code>condition-case nil</code> 的意思是『错误信息不赋给已命名的变量』。Emacs Lisp 允许你捕获不同的错误类别并对错误信息进行排查。这方面的知识请从 Emacs Lisp 手册获取。</p>
<p>在 <code>condition-case</code> 块内如果存在多条表达式需要求值，必须用 <code>progn</code> 将它们封装起来。</p>
<p><code>condition-case</code> 不会捕捉 <code>throw</code> 扔出来的值——这两个系统是彼此独立的。</p>
<h2 id="try-finally"><a href="#try-finally" class="headerlink" title="try/finally"></a>try/finally</h2><p>Emacs Lisp 提供了类似 finally 的功能 <code>unwind-protect</code>：</p>
<p><img src="https://segmentfault.com/img/bVuLDZ" alt="img"></p>
<p>与 <code>condition-case</code> 相似，<code>unwind-protect</code> 接受单个体块（body-form，译注：try 部分），后面跟随着一条或多条善后的表达式，因此你需要用 <code>progn</code> 将体块内的表达式封装起来。</p>
<h2 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try/catch/finally"></a>try/catch/finally</h2><p>如果让 <code>condition-case</code>（等价于 <code>try/catch</code>）成为 <code>unwind-protect</code>（等价于 <code>try/finally</code>）的体块，那么就可以得到 <code>try/catch/finally</code> 的效果：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">(<span class="name">unwind-protect</span>                 <span class="comment">; finally</span></div><div class="line">    (<span class="name">condition-case</span> <span class="literal">nil</span>         <span class="comment">; try</span></div><div class="line">        (<span class="name">progn</span>                  <span class="comment">; &#123;</span></div><div class="line">          (<span class="name">do-something</span>)        <span class="comment">;   body-1</span></div><div class="line">          (<span class="name">do-something-else</span>))  <span class="comment">;   body-2 &#125;</span></div><div class="line">      (<span class="name">error</span>                    <span class="comment">; catch</span></div><div class="line">       (<span class="name">message</span> <span class="string">"oh no!"</span>)       <span class="comment">; &#123; catch 1</span></div><div class="line">       (<span class="name">poop-pants</span>)))           <span class="comment">;   catch 2 &#125;</span></div><div class="line">  (<span class="name">first-finally-expr</span>)          <span class="comment">; &#123; finally 1</span></div><div class="line">  (<span class="name">second-finally-expr</span>))        <span class="comment">;   finally 2 &#125;</span></div></pre></td></tr></table></figure>
<h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><p>Emacs Lisp 不是标准意义上的面向对象编程语言，它没有类、继承以及多态等语法。Emacs 的 Common Lisp 包（现在的 <code>cl-lib</code>）提供了一个有用的特性 <code>defstruct</code>，通过它可以实现简单的 OOP 支持。下面我会给出一个简单的示例。</p>
<p>下面的 Emacs Lisp 代码与 Java 代码本质上是等价的：</p>
<p><img src="https://segmentfault.com/img/bVuLD0" alt="img"></p>
<p><code>defstruct</code> 宏提供了一个灵活的默认构造器，但是你也可以根据自己的需要来定义相适的构造器。</p>
<p><code>defstruct</code> 宏在创建对象实例时，也创建了一组判定函数，它们的用法如下：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">(<span class="name">person-p</span> (<span class="name">make-person</span>))</div><div class="line"><span class="literal">t</span></div><div class="line">(<span class="name">employee-p</span> (<span class="name">make-person</span>))</div><div class="line"><span class="literal">nil</span></div><div class="line">(<span class="name">employee-p</span> (<span class="name">make-employee</span>))</div><div class="line"><span class="literal">t</span></div><div class="line">(<span class="name">person-p</span> (<span class="name">make-employee</span>))  <span class="comment">; yes, it inherits from person</span></div><div class="line"><span class="literal">t</span></div></pre></td></tr></table></figure>
<p>Java 在对象构造器方面可能挺糟糕，不过 Emacs 在域（类成员）的设置方面挺糟糕。要设置类（结构体）的域，必须使用 <code>setf</code> 函数，然后将类名作为域名的前缀：</p>
<p><img src="https://segmentfault.com/img/bVuLD2" alt="img"></p>
<p>这样看上去，Lisp 并不是太糟糕，但是在实践中（因为 Emacs Lisp 不支持命名空间，并且也没有 <code>with-slots</code> 宏），你会被卷入很长的类名与域名中的，例如：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(<span class="name">setf</span> (<span class="name">js2-compiler-data-current-script-or-function</span> compiler-data) current-script</div><div class="line">      (<span class="name">js2-compiler-data-line-number</span> compiler-data) current-line</div><div class="line">      (<span class="name">js2-compiler-data-allow-member-expr-as-function-name</span> compiler-data) allow</div><div class="line">      (<span class="name">js2-compiler-data-language-version</span> compiler-data) language-version)</div></pre></td></tr></table></figure>
<p>要获取域的值，需要将类名与域名连接起来，然后作为函数来用：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="name">person-name</span> steve) <span class="comment">; yields "Steve"</span></div></pre></td></tr></table></figure>
<p><code>defstruct</code> 还能做很多事——它的功能非常得体，该考虑的事都考虑了，尽管它没能形成一个完善的面向对象系统。</p>
<h2 id="缓冲区即类"><a href="#缓冲区即类" class="headerlink" title="缓冲区即类"></a>缓冲区即类</h2><p>在 Emacs Lisp 编程中，将缓冲区视为类的实例往往很有用。因为 Emacs 支持缓冲区级别的局部变量的概念——无论变量以那种方式设置（译注，例如通过 <code>setq</code> 设置的变量），它们都会自动变成缓冲区内部的局部变量。因此，这些变量的行为就像是被封装在实例中的变量。</p>
<p>可以用 <code>make-variable-buffer-local</code> 函数将一个变量声明为缓冲区级别的局部变量，通常这个函数会在 <code>devar</code> 或 <code>defconst</code>之后出现（见下文）。</p>
<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>在 Emacs Lisp 中，可以用 <code>defvar</code> 或 <code>defconst</code> 声明变量，也可以为变量提供文档化注释：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="name">defconst</span> pi <span class="number">3.14159</span> <span class="string">"A gross approximation of pi."</span>)</div></pre></td></tr></table></figure>
<p>语法为 <code>(defvar 变量名 值 [文档化注释])</code>。</p>
<p>不过，会让你大跌眼镜的是，<code>defconst</code> 定义的是变量，而 <code>defvar</code> 定义的是常量，至少在重新求值时是这样。要改变 <code>defvar</code> 变量的值，需要使用 <code>makeunbound</code> 来解除变量的绑定。不过，总是可以使用 <code>setq</code> 来修改 <code>defvar</code> 或 <code>defconst</code> 变量的值。这两种变量形式，仅有的区别是，<code>defconst</code> 可以表达一种意图：你定义的是一个常量。</p>
<p>可以使用 <code>setq</code> 来创建全新的变量，但是如果用 <code>defvar</code>，Emacs Lisp 的字节码编译器能捕捉到一些错误信息。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Emacs Lisp 是一种真正的编程语言。它有编译器、调试器、性能分析器、效果显示器、运行时文档、库、输入/输出、网络、进程控制等。无论 Emacs Lisp 有多么古怪和烦人，只要你上手了，它就能让你体验到编程的快乐。作为一种编程语言，它并不伟大，而且每个人都期望它是 Common Lisp 或 Scheme 或其他某种更好的 Lisp 方言。有些人甚至认为它根本不是 Lisp。</p>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> Emacs </tag>
            
            <tag> Lisp </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[常用排序算法总结（性能+代码）]]></title>
      <url>/2016/10/23/%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%EF%BC%88%E6%80%A7%E8%83%BD-%E4%BB%A3%E7%A0%81%EF%BC%89/</url>
      <content type="html"><![CDATA[<h2 id="1-插入排序"><a href="#1-插入排序" class="headerlink" title="1. 插入排序"></a>1. 插入排序</h2><h3 id="1-1-性能分析"><a href="#1-1-性能分析" class="headerlink" title="1.1 性能分析"></a>1.1 性能分析</h3><p>时间复杂度<code>O(n^2)</code>, 空间复杂度<code>O(1)</code><br>排序时间与输入有关：输入的元素个数；元素已排序的程度。<br>最佳情况，输入数组是已经排好序的数组，运行时间是<code>n</code>的线性函数； 最坏情况，输入数组是逆序，运行时间是<code>n</code>的二次函数。</p>
<h3 id="1-2-核心代码"><a href="#1-2-核心代码" class="headerlink" title="1.2 核心代码"></a>1.2 核心代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">()</span></span>&#123;</div><div class="line">      <span class="keyword">int</span> temp;</div><div class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;arraytoSort.length; i++)&#123;</div><div class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> j = i-<span class="number">1</span>; j&gt;=<span class="number">0</span>; j--)&#123;</div><div class="line">              <span class="keyword">if</span>( arraytoSort[j+<span class="number">1</span>] &lt; arraytoSort[j] )&#123;</div><div class="line">                  temp = arraytoSort[j+<span class="number">1</span>];</div><div class="line">                  arraytoSort[j+<span class="number">1</span>] = arraytoSort[j];</div><div class="line">                  arraytoSort[j] = temp;</div><div class="line">              &#125;   </div><div class="line">          &#125;   </div><div class="line">      &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h2 id="2-选择排序"><a href="#2-选择排序" class="headerlink" title="2.选择排序"></a>2.选择排序</h2><h3 id="2-1-性能分析"><a href="#2-1-性能分析" class="headerlink" title="2.1 性能分析"></a>2.1 性能分析</h3><p>时间复杂度<code>O(n^2)</code>, 空间复杂度<code>O(1)</code><br>排序时间与输入无关，最佳情况，最坏情况都是如此, 不稳定 如 <code>{5,5,2}</code>。</p>
<h3 id="2-2核心代码"><a href="#2-2核心代码" class="headerlink" title="2.2核心代码"></a>2.2核心代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">()</span></span>&#123; </div><div class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;arraytoSort.length-<span class="number">1</span>; i++)&#123;</div><div class="line">           <span class="keyword">int</span> min = i;</div><div class="line">           <span class="keyword">int</span> temp;</div><div class="line">           <span class="comment">//find min</span></div><div class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j&lt;arraytoSort.length ;j++)&#123;</div><div class="line">               <span class="keyword">if</span>(arraytoSort[j] &lt;arraytoSort[min])&#123;</div><div class="line">                   min = j;</div><div class="line">                   &#125;</div><div class="line">           &#125;</div><div class="line">           <span class="comment">//swap the min with the ith element</span></div><div class="line">           temp = arraytoSort[min];</div><div class="line">           arraytoSort[min] = arraytoSort[i];</div><div class="line">           arraytoSort[i] = temp;</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h2 id="3-归并排序"><a href="#3-归并排序" class="headerlink" title="3. 归并排序"></a>3. 归并排序</h2><h3 id="3-1-性能分析"><a href="#3-1-性能分析" class="headerlink" title="3.1 性能分析"></a>3.1 性能分析</h3><p>时间复杂度 <code>O(nlogn)</code>, 空间复杂度<code>O(n) +O(logn)</code><br>排序时间与输入无关，最佳情况，最坏情况都是如此, 稳定。</p>
<p>原理：</p>
<p>可以将数组分成二组。依次类推，当分出来的小组只有一个数据时，可以认为这个小组组内已经达到了有序，然后再合并相邻的二个小组就可以了。这样通过先递归的分解数列，再合并数列就完成了归并排序</p>
<p>归并排序的时间复杂度，合并耗费<code>O(n)</code>时间，而由完全二叉树的深度可知，整个归并排序需要进行<code>log_2n</code>次，因此，总的时间复杂度为 <code>O(nlogn)</code>，而且这是归并排序算法中最好、最坏、平均的时间性能。</p>
<p>由于归并排序在归并过程中需要与原始记录序列同样数量的存储空间存放归并结果 以及 递归时深度为 <code>log_2n</code> 的栈空间，因此空间复杂度为<code>O(n+logn)</code>。</p>
<p>另外，对代码进行仔细研究，发现 Merge 函数中有`if (L[i] 语句，这就说明它需要两两比较，不存在跳跃，因此归并排序是一种稳定的排序算法。</p>
<p>也就是说，归并排序是一种比较占用内存，但却效率高且稳定的算法。</p>
<h3 id="3-2-核心代码"><a href="#3-2-核心代码" class="headerlink" title="3.2 核心代码"></a>3.2 核心代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">merge</span><span class="params">( <span class="keyword">int</span> p, <span class="keyword">int</span> q, <span class="keyword">int</span> r )</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span>[] right = assignlist(p,q); </div><div class="line">        <span class="comment">//赋值左半部分数组（赋值就是用for循环，还有一个哨兵：最后一个元素设置为maxvalue）</span></div><div class="line">        <span class="keyword">int</span>[] left = assignlist(q+<span class="number">1</span>,r); <span class="comment">//赋值有半部分数组</span></div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = p; k&lt;=r; k++)&#123;</div><div class="line">            <span class="keyword">if</span>(right[i] &lt;= left[j])&#123;    </div><div class="line">                arraytoSort[k] = right[i];</div><div class="line">                i++;    </div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(right[i] &gt; left[j])&#123;</div><div class="line">                arraytoSort[k] = left[j];</div><div class="line">                j++;</div><div class="line">                count = count + (q - p + <span class="number">1</span>) -i;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> count;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(<span class="keyword">int</span> arry[],<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span></div><div class="line"> &#123;</div><div class="line">    <span class="keyword">if</span>(start&lt;end)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> mid=(start+end)/<span class="number">2</span>;<span class="comment">//数组重点</span></div><div class="line">        MergeSort(arry,start,mid);<span class="comment">//递归调用，排序前半段arry[start...mid]</span></div><div class="line">        MergeSort(arry,mid+<span class="number">1</span>,end);<span class="comment">//递归调用，排序后半段arry[mid+1,end]</span></div><div class="line">        MergeArry(arry,start,mid,end);<span class="comment">//归并上述两段有序数组。</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-3-延伸"><a href="#3-3-延伸" class="headerlink" title="3.3 延伸"></a>3.3 延伸</h3><p>求逆序对</p>
<h2 id="4冒泡排序"><a href="#4冒泡排序" class="headerlink" title="4冒泡排序"></a>4冒泡排序</h2><h3 id="4-1-性能分析"><a href="#4-1-性能分析" class="headerlink" title="4.1 性能分析"></a>4.1 性能分析</h3><p>时间复杂度<code>O(n^2)</code>, 空间复杂度<code>O(1)</code>， 稳定，因为存在两两比较，不存在跳跃。<br>排序时间与输入无关，最好，最差，平均都是<code>O(n^2)</code></p>
<h3 id="4-2-核心代码"><a href="#4-2-核心代码" class="headerlink" title="4.2 核心代码"></a>4.2 核心代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arraytoSort.length-<span class="number">1</span>;i++)&#123;    </div><div class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> j=arraytoSort.length-<span class="number">1</span>;j&gt;=i+<span class="number">1</span>;j--)&#123;</div><div class="line">           <span class="keyword">int</span> temp;</div><div class="line">           <span class="keyword">if</span>(arraytoSort[j]&lt;arraytoSort[j-<span class="number">1</span>])</div><div class="line">           &#123;</div><div class="line">               temp = arraytoSort[j];</div><div class="line">               arraytoSort[j] = arraytoSort[j-<span class="number">1</span>];</div><div class="line">               arraytoSort[j-<span class="number">1</span>] = temp;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h3 id="4-3-延伸"><a href="#4-3-延伸" class="headerlink" title="4.3 延伸"></a>4.3 延伸</h3><p>冒泡排序缺陷：</p>
<ol>
<li>在排序过程中，执行完当前的第i趟排序后，可能数据已全部排序完备，但是程序无法判断是否完成排序，会继续执行剩下的<code>(n-1-i)</code>趟排序。解决方法： 设置一个<code>flag</code>位, 如果一趟无元素交换，则 <code>flag = 0</code>; 以后再也不进入第二层循环。</li>
<li>当排序的数据比较多时排序的时间会明显延长，因为会比较 <code>n*(n-1)/2</code>次。</li>
</ol>
<h2 id="5-堆排序"><a href="#5-堆排序" class="headerlink" title="5. 堆排序"></a>5. 堆排序</h2><h3 id="5-1-性能分析"><a href="#5-1-性能分析" class="headerlink" title="5.1 性能分析"></a>5.1 性能分析</h3><p>时间复杂度 <code>O(nlogn)</code>, 空间复杂度<code>O(1)</code>. 从这一点就可以看出，堆排序在时间上类似归并，但是它又是一种原地排序，时间复杂度小于归并的<code>O(n+logn)</code><br>排序时间与输入无关，最好，最差，平均都是<code>O(nlogn)</code>. 不稳定</p>
<p>堆排序借助了堆这个数据结构，堆类似二叉树，又具有堆积的性质（子节点的关键值总小于（大于）父节点） 堆排序包括两个主要操作:</p>
<ol>
<li>保持堆的性质heapify(A,i)<br>时间复杂度<code>O(logn)</code></li>
<li>建堆 buildmaxheap(A)<br>时间复杂度<code>O(n)</code>线性时间建堆</li>
</ol>
<p><strong>对于大数据的处理</strong>： 如果对100亿条数据选择Topk数据，选择快速排序好还是堆排序好？ 答案是只能用堆排序。 堆排序只需要维护一个k大小的空间，即在内存开辟k大小的空间。而快速排序需要开辟能存储100亿条数据的空间，which is impossible.</p>
<h3 id="5-2-核心代码"><a href="#5-2-核心代码" class="headerlink" title="5.2 核心代码"></a>5.2 核心代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildheap</span><span class="params">(<span class="keyword">int</span> array[])</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> length = array.length;</div><div class="line">        <span class="keyword">int</span> heapsize = length;</div><div class="line">        <span class="keyword">int</span> nonleaf = length / <span class="number">2</span> - <span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = nonleaf; i&gt;=<span class="number">0</span>;i--)&#123;</div><div class="line">            heapify(array,i,heapsize);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span> array[], <span class="keyword">int</span> i,<span class="keyword">int</span> heapsize)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> smallest = i;</div><div class="line">        <span class="keyword">int</span> left = <span class="number">2</span>*i+<span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> right = <span class="number">2</span>*i+<span class="number">2</span>;</div><div class="line">        <span class="keyword">if</span>(left&lt;heapsize)&#123;</div><div class="line">            <span class="keyword">if</span>(array[i]&gt;array[left])&#123;</div><div class="line">                smallest = left;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> smallest = i;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(right&lt;heapsize)&#123;</div><div class="line">            <span class="keyword">if</span>(array[smallest]&gt;array[right])&#123;</div><div class="line">                smallest = right;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(smallest != i)&#123;</div><div class="line">            <span class="keyword">int</span> temp;</div><div class="line">            temp = array[i];</div><div class="line">            array[i] = array[smallest];</div><div class="line">            array[smallest] = temp;</div><div class="line">            heapify(array,smallest,heapsize);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">heapsort</span><span class="params">(<span class="keyword">int</span> array[])</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> heapsize = array.length;</div><div class="line">        buildheap(array);</div><div class="line"></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.length-<span class="number">1</span>;i++)&#123;</div><div class="line">            <span class="comment">// swap the first and the last</span></div><div class="line">            <span class="keyword">int</span> temp;</div><div class="line">            temp = array[<span class="number">0</span>];</div><div class="line">            array[<span class="number">0</span>] = array[heapsize-<span class="number">1</span>];</div><div class="line">            array[heapsize-<span class="number">1</span>] = temp;</div><div class="line">            <span class="comment">// heapify the array</span></div><div class="line">            heapsize = heapsize - <span class="number">1</span>;</div><div class="line">            heapify(array,<span class="number">0</span>,heapsize);</div><div class="line"></div><div class="line">        &#125;   </div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="5-3-延伸"><a href="#5-3-延伸" class="headerlink" title="5.3 延伸"></a>5.3 延伸</h3><p>堆这种数据结构的很好的应用是 优先级队列，如作业调度。</p>
<h2 id="6-快速排序"><a href="#6-快速排序" class="headerlink" title="6 快速排序"></a>6 快速排序</h2><h3 id="6-1-性能分析"><a href="#6-1-性能分析" class="headerlink" title="6.1 性能分析"></a>6.1 性能分析</h3><p>时间复杂度 <code>O(nlogn)</code> 空间复杂度<code>O（logn）</code> 不稳定 【两个时间复杂度<code>O(nlogn)</code> 的排序算法都不稳定】</p>
<p>时间复杂度：<br>最坏<code>O（n^2）</code> 当<strong>划分不均匀</strong>时候 逆序and排好序都是最坏情况<br>最好<code>O（n）</code> 当划分均匀<br><code>partition</code>的时间复杂度: <code>O（n）</code>一共需要<code>logn</code>次<code>partition</code></p>
<p>空间复杂度：递归造成的栈空间的使用，最好情况，递归树的深度<code>logn</code> 空间复杂的<code>logn</code>，最坏情况，需要进行<code>n‐1</code> 递归调用，其空间复杂度为 <code>O(n)</code>，平均情况，空间复杂度也为<code>O(log2n)</code>。<br>由于关键字的比较和交换是跳跃进行的，因此，快速排序是一种不稳定的排序方法。</p>
<p>快速排序的每一轮就是将这一轮的基准数归位，直到所有的数都归为为止，排序结束。（类似冒泡）. partition是返回一个基准值的index, index 左边都小于该index的数，右边都大于该index的数。</p>
<p>快速排序之所比较快，因为相比冒泡排序，每次交换是跳跃式的。每次排序的时候设置一个基准点，将小于等于基准点的数全部放到基准点的左边，将大于等于基准点的数全部放到基准点的右边。这样在每次交换的时候就不会像冒泡排序一样每次只能在相邻的数之间进行交换，交换的距离就大的多了。因此总的比较和交换次数就少了，速度自然就提高了。当然在最坏的情况下，仍可能是相邻的两个数进行了交换。因此快速排序的最差时间复杂度和冒泡排序是一样的都是 <code>O(n^2)</code>，它的平均时间复杂度为 <code>O(nlogn)</code>。其实快速排序是基于 “二分” 的思想。</p>
<h3 id="6-2-核心代码"><a href="#6-2-核心代码" class="headerlink" title="6.2 核心代码"></a>6.2 核心代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Quicksort</span> </span>&#123;</div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span></span>&#123;</div><div class="line">             <span class="keyword">int</span> i = begin;</div><div class="line">             <span class="keyword">int</span> j = end;</div><div class="line">             <span class="keyword">int</span> q;</div><div class="line">             <span class="keyword">int</span> pivot = begin;</div><div class="line">             <span class="keyword">int</span> pivotnumber = A[pivot];</div><div class="line">             <span class="keyword">while</span>(i!=j)&#123;</div><div class="line">                   <span class="keyword">int</span> temp;</div><div class="line">                   <span class="keyword">while</span>(A[j]&gt;pivotnumber &amp;&amp; i&lt;j)&#123;</div><div class="line">                        j--;</div><div class="line"></div><div class="line">                  &#125;</div><div class="line">                   <span class="keyword">while</span>(A[i]&lt;=pivotnumber &amp;&amp; i&lt;j)</div><div class="line">                  &#123;</div><div class="line">                        i++;</div><div class="line">                  &#125;</div><div class="line">                  temp = A[i];</div><div class="line">                  A[i] = A[j];</div><div class="line">                  A[j] = temp;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">             <span class="keyword">if</span>(i == j)&#123;</div><div class="line">                   <span class="keyword">int</span> temp;</div><div class="line">                  temp =A[pivot];</div><div class="line">                  A[pivot] = A[i];</div><div class="line">                  A[i] = temp;      </div><div class="line">            &#125;</div><div class="line">             <span class="keyword">return</span> i;</div><div class="line">      &#125;</div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> begin,<span class="keyword">int</span> end)</span></span>&#123;</div><div class="line">             <span class="keyword">if</span>(begin&lt;end)&#123;</div><div class="line">                   <span class="keyword">int</span> q;</div><div class="line">                  q = partition(A,begin, end);</div><div class="line">                  sort(A,begin, q-<span class="number">1</span>);</div><div class="line">                  sort(A,q+<span class="number">1</span>,end);</div><div class="line">            &#125;     </div><div class="line">      &#125;</div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">             <span class="keyword">int</span> array[] = &#123;<span class="number">8</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>&#125;;</div><div class="line">            Quicksort s = <span class="keyword">new</span> Quicksort();</div><div class="line">            s.sort(array, <span class="number">0</span>, <span class="number">7</span>);</div><div class="line">             <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.length;i++)&#123;</div><div class="line">                  System. out.println(<span class="string">"output "</span> + array[i]);</div><div class="line">            &#125;</div><div class="line">      &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>非比较排序</strong>： ，计数排序，基数排序，桶排序，时间复杂度能够达到<code>O(n)</code>. 这些排序为了达到不比较的目的，对数据做了一些基本假设（限制）。如计数排序假设数据都<code>[0,n]</code> 范围内，且范围较小；基数排序假设数据都<code>[0,n]</code> 范围内；也是桶排序假设数据均匀独立的分布。</p>
<p>而且，非比较排序的空间要求比较高，用空间换取时间吧。当我们的待排序数组具备一些基数排序与桶排序要求的特性，且空间上又比较富裕时，桶排序与基数排序不失为最佳选择。</p>
<h2 id="7-计数排序"><a href="#7-计数排序" class="headerlink" title="7. 计数排序"></a>7. 计数排序</h2><p>我们希望能线性的时间复杂度排序，如果一个一个比较，显然是不实际的，书上也在决策树模型中论证了，比较排序的情况为<code>nlogn</code>的复杂度。既然不能一个一个比较，我们想到一个办法，就是如果<strong>在排序的时候就知道他的位置，那不就是扫描一遍，把他放入他应该的位置</strong>不就可以了。 要知道<strong>他的位置，我们只需要知道有多少不大于他不就可以了</strong>吗？</p>
<h3 id="7-1-性能分析"><a href="#7-1-性能分析" class="headerlink" title="7.1 性能分析"></a>7.1 性能分析</h3><p>最好，最坏，平均的时间复杂度<code>O(n+k)</code>, 天了噜， 线性时间完成排序，且稳定。</p>
<p>优点：不需要比较函数，利用地址偏移，对范围固定在[0,k]的整数排序的最佳选择。是排序字节串最快的排序算法。</p>
<p>缺点：由于用来计数的数组的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。</p>
<h3 id="7-2-核心代码"><a href="#7-2-核心代码" class="headerlink" title="7.2 核心代码"></a>7.2 核心代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] countsort(<span class="keyword">int</span> A[])&#123;</div><div class="line">    <span class="keyword">int</span>[] B = <span class="keyword">new</span> <span class="keyword">int</span>[A.length]; <span class="comment">//to store result after sorting</span></div><div class="line">    <span class="keyword">int</span> k = max(A);</div><div class="line">    <span class="keyword">int</span> [] C = <span class="keyword">new</span> <span class="keyword">int</span>[k+<span class="number">1</span>]; <span class="comment">// to store temp</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;A.length;i++)&#123;    </div><div class="line">        C[A[i]] = C[A[i]] + <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 小于等于A[i]的数的有多少个, 存入数组C</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;C.length;i++)&#123;</div><div class="line">        C[i] = C[i] + C[i-<span class="number">1</span>];</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//逆序输出确保稳定-相同元素相对顺序不变</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=A.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</div><div class="line"></div><div class="line">        B[C[A[i]]-<span class="number">1</span>] = A[i]; </div><div class="line">        C[A[i]] = C[A[i]]-<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> B;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="7-3-扩展"><a href="#7-3-扩展" class="headerlink" title="7.3 扩展"></a>7.3 扩展</h3><p>请给出一个算法，使之对给定的介于 <code>0</code>到 <code>k</code> 之间的 <code>n</code>个整数进行预处理，并能在<code>O(1)</code> 时间内回答出输入的整数中有多少个落在 <code>[a...b]</code> 区间内。你给出的算法的预处理时间为<code>O(n+k)</code>。</p>
<p>分析：就是用计数排序中的预处理方法，获得数组 <code>C[0...k</code>]，使得<code>C[i]</code>为不大于 <code>i</code>的元素的个数。这样落入 <code>[a...b]</code> 区间内的元素个数有 <code>C[b]-C[a-1]</code>。</p>
<p>计数排序的重要性质是他是<strong>稳定</strong>的。一般而言，仅当卫星数据随着被排序的元素一起移动时，稳定性才显得比较重要。而这也是计数排序作为基数排序的子过程的重要原因</p>
<h2 id="8-基数排序"><a href="#8-基数排序" class="headerlink" title="8 基数排序"></a>8 基数排序</h2><p>为什么要用基数排序 ？</p>
<p>计数排序和桶排序都只是在研究一个关键字的排序，现在我们来讨论有多个关键字的排序问题。</p>
<p>假设我们有一些二元组<code>(a,b)</code>，要对它们进行以<code>a</code> 为首要关键字，<code>b</code>的次要关键字的排序。我们可以先把它们先按照首要关键字排序，分成首要关键字相同的若干堆。然后，在按照次要关键值分别对每一堆进行单独排序。最后再把这些堆串连到一起，使首要关键字较小的一堆排在上面。按这种方式的基数排序称为 <strong>MSD(Most Significant Dight) 排序</strong>。</p>
<p>第二种方式是从最低有效关键字开始排序，称为 <strong>LSD(Least Significant Dight)排序</strong> 。首先对所有的数据按照次要关键字排序，然后对所有的数据按照首要关键字排序。要注意的是，使用的排序算法必须是稳定的，否则就会取消前一次排序的结果。由于不需要分堆对每堆单独排序，LSD 方法往往比 MSD 简单而开销小。下文介绍的方法全部是基于 LSD 的。</p>
<p>通常，基数排序要用到计数排序或者桶排序。使用计数排序时，需要的是Order数组。使用桶排序时，可以用链表的方法直接求出排序后的顺序。</p>
<p><img src="https://segmentfault.com/image?src=http://img.blog.csdn.net/20150312165029654&amp;objectId=1190000002595152&amp;token=995123acf45c3cbc9f8dd6929e68bc5e" alt="img"></p>
<h3 id="8-1-性能分析"><a href="#8-1-性能分析" class="headerlink" title="8.1 性能分析"></a>8.1 性能分析</h3><p>时间复杂度<code>O（n）</code> (实际上是<code>O(d(n+k))</code> d是位数)</p>
<h3 id="8-2-核心代码"><a href="#8-2-核心代码" class="headerlink" title="8.2 核心代码"></a>8.2 核心代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">RADIX-SORT(A,d)</div><div class="line">    <span class="keyword">for</span> i = <span class="number">1</span> to d</div><div class="line">        <span class="keyword">do</span> use a stable sort to sort array A on digit i</div></pre></td></tr></table></figure>
<h3 id="8-3扩展"><a href="#8-3扩展" class="headerlink" title="8.3扩展"></a>8.3扩展</h3><p>问题：对<code>[0,n^2-1]</code>的<code>n</code> 个整数进行线性时间排序。<br>思路 ： 把整数转换为n进制再排序，每个数有两位，每位的取值范围是<code>[0..n-1]</code>，再进行基数排序</p>
<p><a href="http://blog.csdn.net/mishifangxiangdefeng/article/details/7685839" target="_blank" rel="external">http://blog.csdn.net/mishifangxiangdefeng/article/details/7685839</a></p>
<p>问题： 给定一个字符串数组，其中不同的串包含的字符数可能不同，但所有串中总的字符个数为 n。说明如何在 O(n) 时间内对该数组进行排序</p>
<h2 id="9-桶排序"><a href="#9-桶排序" class="headerlink" title="9. 桶排序"></a>9. 桶排序</h2><p>桶排序的思想近乎彻底的分治思想。</p>
<p>桶排序假设待排序的一组数<strong>均匀独立</strong>的分布在一个范围中，并将这一范围划分成几个子范围（桶）。</p>
<p>然后基于某种映射函数<code>f</code> ，将待排序列的关键字 <code>k</code> 映射到第<code>i</code>个桶中 (即桶数组<code>B</code> 的下标<code>i</code>) ，那么该关键字<code>k</code> 就作为 <code>B[i]</code>中的元素 (每个桶<code>B[i]</code>都是一组大小为<code>N/M</code> 的序列 )。</p>
<p>接着将各个桶中的数据有序的合并起来 : 对每个桶<code>B[i]</code> 中的所有元素进行比较排序 (可以使用快排)。然后依次枚举输出 <code>B[0]....B[M]</code> 中的全部内容即是一个有序序列。</p>
<p>补充： 映射函数一般是 <code>f = array[i] / k</code>; <code>k^2 = n</code>; <code>n</code>是所有元素个数</p>
<p><img src="https://segmentfault.com/image?src=http://img.blog.csdn.net/20150312112052264&amp;objectId=1190000002595152&amp;token=46912f7eb9fc0b2de830a20e710b0bbe" alt="img"></p>
<h3 id="9-1-性能分析"><a href="#9-1-性能分析" class="headerlink" title="9.1 性能分析"></a>9.1 性能分析</h3><p>平均时间复杂度为线性的 <code>O(n+C)</code> 最优情形下，桶排序的时间复杂度为<code>O(n)</code>。<br>桶排序的空间复杂度通常是比较高的，额外开销为<code>O(n+m)</code>（因为要维护 M 个数组的引用）。<br>就是桶越多，时间效率就越高，而桶越多，空间却就越大，由此可见时间和空间是一个矛盾的两个方面。</p>
<p>算法稳定性 : 桶排序的稳定性依赖于桶内排序。如果我们使用了快排，显然，算法是不稳定的。<br><a href="http://hxraid.iteye.com/blog/647759" target="_blank" rel="external">一个讲bucket排序非常好的文章</a><br>桶排序利用函数的映射关系，减少了几乎所有的比较工作。实际上，桶排序的 f(k) 值的计算，其作用就相当于快排中划分，已经把大量数据分割成了基本有序的数据块 (桶)。然后只需要对桶中的少量数据做先进的比较排序即可。</p>
<p>对 N 个关键字进行桶排序的时间复杂度分为两个部分：<br>(1) 循环计算每个关键字的桶映射函数，这个时间复杂度是 <code>O(n)</code>。<br>(2) 利用先进的比较排序算法对每个桶内的所有数据进行排序，其时间复杂度为 <code>∑ O(ni*logni)</code> 。其中 <code>ni</code> 为第 <code>i</code>个桶的数据量。</p>
<p>很显然，第 (2) 部分是桶排序性能好坏的决定因素。这就是一个时间代价和空间代价的权衡问题了。</p>
<h3 id="9-2-核心代码"><a href="#9-2-核心代码" class="headerlink" title="9.2 核心代码"></a>9.2 核心代码</h3><h3 id="9-3扩展"><a href="#9-3扩展" class="headerlink" title="9.3扩展"></a>9.3扩展</h3><h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://sf-static.b0.upaiyun.com/v-583541b4/global/img/squares.svg" alt="img"></h2><h2 id="in-summary"><a href="#in-summary" class="headerlink" title="in summary"></a>in summary</h2><p><img src="https://segmentfault.com/img/bVlf9S" alt="img"></p>
<p>关于稳定性：</p>
<ul>
<li>选择排序、快速排序、希尔排序、堆排序不是稳定的排序算法，</li>
<li>冒泡排序、插入排序、归并排序和基数排序是稳定的排序算法。</li>
<li>常用时间复杂度的大小关系：`O(1)</li>
</ul>
<p>注：该文章转载自：<a href="http://segmentfault.com/blog/exploring/" target="_blank" rel="external">http://segmentfault.com/blog/exploring/</a></p>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[21分钟MySQL基础入门]]></title>
      <url>/2016/10/19/21%E5%88%86%E9%92%9FMySQL%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/</url>
      <content type="html"><![CDATA[<h2 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h2><p>我下面所有的SQL语句是基于MySQL 5.6+运行。</p>
<p>MySQL 为关系型数据库(Relational Database Management System)，一个关系型数据库由一个或数个表格组成, 如图所示的一个表格：</p>
<p><img src="https://segmentfault.com/img/bVC86a?w=327&amp;h=138" alt="img"></p>
<ul>
<li><code>表头(header)</code>: 每一列的名称;</li>
<li><code>列(row)</code>: 具有相同数据类型的数据的集合;</li>
<li><code>行(col)</code>: 每一行用来描述某个人/物的具体信息;</li>
<li><code>值(value)</code>: 行的具体信息, 每个值必须与该列的数据类型相同;</li>
<li><code>键(key)</code>: 表中用来识别某个特定的人物的方法, 键的值在当前列中具有唯一性。</li>
</ul>
<h3 id="登录MySQL"><a href="#登录MySQL" class="headerlink" title="登录MySQL"></a>登录MySQL</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">mysql -h 127.0.0.1 -u 用户名 -p</div><div class="line">mysql -D 所选择的数据库名 -h 主机名 -u 用户名 -p</div><div class="line">mysql&gt; exit # 退出 使用 “quit;” 或 “\q;” 一样的效果</div><div class="line">mysql&gt; status;  # 显示当前mysql的version的各种信息</div><div class="line">mysql&gt; select version(); # 显示当前mysql的version信息</div><div class="line">mysql&gt; show global variables like &apos;port&apos;; # 查看MySQL端口号</div></pre></td></tr></table></figure>
<h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><p>对于表的操作需要先进入库<code>use 库名;</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">-- 创建一个名为 samp_db 的数据库，数据库字符编码指定为 gbk</div><div class="line">create database samp_db character set gbk;</div><div class="line">drop database samp_db; -- 删除 库名为samp_db的库</div><div class="line">show databases;        -- 显示数据库列表。</div><div class="line">use samp_db;     -- 选择创建的数据库samp_db</div><div class="line">show tables;     -- 显示samp_db下面所有的表名字</div><div class="line">describe 表名;    -- 显示数据表的结构</div><div class="line">delete from 表名; -- 清空表中记录</div></pre></td></tr></table></figure>
<h3 id="创建数据库表"><a href="#创建数据库表" class="headerlink" title="创建数据库表"></a>创建数据库表</h3><blockquote>
<p>使用 create table 语句可完成对表的创建, create table 的常见形式:语法：create table 表名称(列声明);</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE `user_accounts` (</div><div class="line">  `id`             int(100) unsigned NOT NULL AUTO_INCREMENT primary key,</div><div class="line">  `password`       varchar(32)       NOT NULL DEFAULT &apos;&apos; COMMENT &apos;用户密码&apos;,</div><div class="line">  `reset_password` tinyint(32)       NOT NULL DEFAULT 0 COMMENT &apos;用户类型：0－不需要重置密码；1-需要重置密码&apos;,</div><div class="line">  `mobile`         varchar(20)       NOT NULL DEFAULT &apos;&apos; COMMENT &apos;手机&apos;,</div><div class="line">  `create_at`      timestamp(6)      NOT NULL DEFAULT CURRENT_TIMESTAMP(6),</div><div class="line">  `update_at`      timestamp(6)      NOT NULL DEFAULT CURRENT_TIMESTAMP(6) ON UPDATE CURRENT_TIMESTAMP(6),</div><div class="line">  -- 创建唯一索引，不允许重复</div><div class="line">  UNIQUE INDEX idx_user_mobile(`mobile`)</div><div class="line">)</div><div class="line">ENGINE=InnoDB DEFAULT CHARSET=utf8</div><div class="line">COMMENT=&apos;用户表信息&apos;;</div></pre></td></tr></table></figure>
<p>数据类型的属性解释</p>
<ul>
<li><code>NULL</code>：数据列可包含NULL值；</li>
<li><code>NOT NULL</code>：数据列不允许包含NULL值；</li>
<li><code>DEFAULT</code>：默认值；</li>
<li><code>PRIMARY</code>：KEY 主键；</li>
<li><code>AUTO_INCREMENT</code>：自动递增，适用于整数类型；</li>
<li><code>UNSIGNED</code>：是指数值类型只能为正数；</li>
<li><code>CHARACTER SET name</code>：指定一个字符集；</li>
<li><code>COMMENT</code>：对表或者字段说明；</li>
</ul>
<h2 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h2><h3 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT"></a>SELECT</h3><blockquote>
<p>SELECT 语句用于从表中选取数据。<br>语法：<code>SELECT 列名称 FROM 表名称</code><br>语法：<code>SELECT * FROM 表名称</code></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">-- 表station 两个 id  表station中不包含 字段a=b 的 查询出来，只显示id</div><div class="line">SELECT s.id from station s WHERE id in (13,14) and user_id not in (4);</div><div class="line"></div><div class="line">-- 从表 Persons 选取 LastName 列的数据</div><div class="line">SELECT LastName FROM Persons</div><div class="line"></div><div class="line">-- 结果集中会自动去重复数据</div><div class="line">SELECT DISTINCT Company FROM Orders </div><div class="line">-- 表 Persons 字段 Id_P 等于 Orders 字段 Id_P 的值，</div><div class="line">-- 结果集显示 Persons表的 LastName、FirstName字段，Orders表的OrderNo字段</div><div class="line">SELECT p.LastName, p.FirstName, o.OrderNo FROM Persons p, Orders o WHERE p.Id_P = o.Id_P</div></pre></td></tr></table></figure>
<h3 id="UPDATE"><a href="#UPDATE" class="headerlink" title="UPDATE"></a>UPDATE</h3><blockquote>
<p>Update 语句用于修改表中的数据。<br>语法：<code>UPDATE 表名称 SET 列名称 = 新值 WHERE 列名称 = 某值</code></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">-- update语句设置字段值为另一个结果取出来的字段</div><div class="line">update user set name = (select name from user1 where user1 .id = 1 )</div><div class="line">where id = (select id from user2 where user2 .name=&apos;小苏&apos;);</div><div class="line">-- 更新表 orders 中 id=1 的那一行数据更新它的 title 字段</div><div class="line">UPDATE `orders` set title=&apos;这里是标题&apos; WHERE id=1;</div></pre></td></tr></table></figure>
<h3 id="INSERT"><a href="#INSERT" class="headerlink" title="INSERT"></a>INSERT</h3><blockquote>
<p>INSERT INTO 语句用于向表格中插入新的行。<br>语法：<code>INSERT INTO 表名称 VALUES (值1, 值2,....)</code><br>语法：<code>INSERT INTO 表名称 (列1, 列2,...) VALUES (值1, 值2,....)</code></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">-- 向表 Persons 插入一条字段 LastName = JSLite 字段 Address = shanghai</div><div class="line">INSERT INTO Persons (LastName, Address) VALUES (&apos;JSLite&apos;, &apos;shanghai&apos;);</div><div class="line">-- 向表 meeting 插入 字段 a=1 和字段 b=2</div><div class="line">INSERT INTO meeting SET a=1,b=2;</div><div class="line">-- </div><div class="line">-- SQL实现将一个表的数据插入到另外一个表的代码</div><div class="line">-- 如果只希望导入指定字段，可以用这种方法：</div><div class="line">-- INSERT INTO 目标表 (字段1, 字段2, ...) SELECT 字段1, 字段2, ... FROM 来源表;</div><div class="line">INSERT INTO orders (user_account_id, title) SELECT m.user_id, m.title FROM meeting m where m.id=1;</div></pre></td></tr></table></figure>
<h3 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h3><blockquote>
<p>DELETE 语句用于删除表中的行。<br>语法：<code>DELETE FROM 表名称 WHERE 列名称 = 值</code></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">-- 在不删除table_name表的情况下删除所有的行，清空表。</div><div class="line">DELETE FROM table_name</div><div class="line">-- 或者</div><div class="line">DELETE * FROM table_name</div><div class="line">-- 删除 Person表字段 LastName = &apos;JSLite&apos; </div><div class="line">DELETE FROM Person WHERE LastName = &apos;JSLite&apos; </div><div class="line">-- 删除 表meeting id 为2和3的两条数据</div><div class="line">DELETE from meeting where id in (2,3);</div></pre></td></tr></table></figure>
<h2 id="WHERE"><a href="#WHERE" class="headerlink" title="WHERE"></a>WHERE</h2><blockquote>
<p>WHERE 子句用于规定选择的标准。<br>语法：<code>SELECT 列名称 FROM 表名称 WHERE 列 运算符 值</code></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">-- 从表 Persons 中选出 Year 字段大于 1965 的数据</div><div class="line">SELECT * FROM Persons WHERE Year&gt;1965</div></pre></td></tr></table></figure>
<h2 id="AND-和-OR"><a href="#AND-和-OR" class="headerlink" title="AND 和 OR"></a>AND 和 OR</h2><blockquote>
<p>AND - 如果第一个条件和第二个条件都成立； OR - 如果第一个条件和第二个条件中只要有一个成立；</p>
</blockquote>
<h3 id="AND"><a href="#AND" class="headerlink" title="AND"></a>AND</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">-- 删除 meeting 表字段 </div><div class="line">-- id=2 并且 user_id=5 的数据  和</div><div class="line">-- id=3 并且 user_id=6 的数据 </div><div class="line">DELETE from meeting where id in (2,3) and user_id in (5,6);</div><div class="line"></div><div class="line">-- 使用 AND 来显示所有姓为 &quot;Carter&quot; 并且名为 &quot;Thomas&quot; 的人：</div><div class="line">SELECT * FROM Persons WHERE FirstName=&apos;Thomas&apos; AND LastName=&apos;Carter&apos;;</div></pre></td></tr></table></figure>
<h3 id="OR"><a href="#OR" class="headerlink" title="OR"></a>OR</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">-- 使用 OR 来显示所有姓为 &quot;Carter&quot; 或者名为 &quot;Thomas&quot; 的人：</div><div class="line">SELECT * FROM Persons WHERE firstname=&apos;Thomas&apos; OR lastname=&apos;Carter&apos;</div></pre></td></tr></table></figure>
<h2 id="ORDER-BY"><a href="#ORDER-BY" class="headerlink" title="ORDER BY"></a>ORDER BY</h2><blockquote>
<p>语句默认按照升序对记录进行排序。<br><code>ORDER BY</code> - 语句用于根据指定的列对结果集进行排序。<br><code>DESC</code> - 按照降序对记录进行排序。<br><code>ASC</code> - 按照顺序对记录进行排序。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">-- Company在表Orders中为字母，则会以字母顺序显示公司名称</div><div class="line">SELECT Company, OrderNumber FROM Orders ORDER BY Company</div><div class="line"></div><div class="line">-- 后面跟上 DESC 则为降序显示</div><div class="line">SELECT Company, OrderNumber FROM Orders ORDER BY Company DESC</div><div class="line"></div><div class="line">-- Company以降序显示公司名称，并OrderNumber以顺序显示</div><div class="line">SELECT Company, OrderNumber FROM Orders ORDER BY Company DESC, OrderNumber ASC</div></pre></td></tr></table></figure>
<h2 id="IN"><a href="#IN" class="headerlink" title="IN"></a>IN</h2><blockquote>
<p>IN - 操作符允许我们在 WHERE 子句中规定多个值。<br>IN - 操作符用来指定范围，范围中的每一条，都进行匹配。IN取值规律，由逗号分割，全部放置括号中。<br>语法：<code>SELECT &quot;字段名&quot;FROM &quot;表格名&quot;WHERE &quot;字段名&quot; IN (&#39;值一&#39;, &#39;值二&#39;, ...);</code></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">-- 从表 Persons 选取 字段 LastName 等于 Adams、Carter</div><div class="line">SELECT * FROM Persons WHERE LastName IN (&apos;Adams&apos;,&apos;Carter&apos;)</div></pre></td></tr></table></figure>
<h2 id="NOT"><a href="#NOT" class="headerlink" title="NOT"></a>NOT</h2><blockquote>
<p>NOT - 操作符总是与其他操作符一起使用，用在要过滤的前面。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SELECT vend_id, prod_name FROM Products WHERE NOT vend_id = &apos;DLL01&apos; ORDER BY prod_name;</div></pre></td></tr></table></figure>
<h2 id="AS"><a href="#AS" class="headerlink" title="AS"></a>AS</h2><blockquote>
<p>as - 可理解为：用作、当成，作为；别名<br>一般是重命名列名或者表名。<br>语法：<code>select column_1 as 列1,column_2 as 列2 from table as 表</code></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">SELECT * FROM Employee AS emp</div><div class="line">-- 这句意思是查找所有Employee 表里面的数据，并把Employee表格命名为 emp。</div><div class="line">-- 当你命名一个表之后，你可以在下面用 emp 代替 Employee.</div><div class="line">-- 例如 SELECT * FROM emp.</div><div class="line"></div><div class="line">SELECT MAX(OrderPrice) AS LargestOrderPrice FROM Orders</div><div class="line">-- 列出表 Orders 字段 OrderPrice 列最大值，</div><div class="line">-- 结果集列不显示 OrderPrice 显示 LargestOrderPrice</div><div class="line"></div><div class="line">-- 显示表 users_profile 中的 name 列</div><div class="line">SELECT t.name from (SELECT * from users_profile a) AS t;</div><div class="line"></div><div class="line">-- 表 user_accounts 命名别名 ua，表 users_profile 命名别名 up</div><div class="line">-- 满足条件 表 user_accounts 字段 id 等于 表 users_profile 字段 user_id</div><div class="line">-- 结果集只显示mobile、name两列</div><div class="line">SELECT ua.mobile,up.name FROM user_accounts as ua INNER JOIN users_profile as up ON ua.id = up.user_id;</div></pre></td></tr></table></figure>
<h2 id="JOIN"><a href="#JOIN" class="headerlink" title="JOIN"></a>JOIN</h2><blockquote>
<p>用于根据两个或多个表中的列之间的关系，从这些表中查询数据。</p>
</blockquote>
<ul>
<li><code>JOIN</code>: 如果表中有至少一个匹配，则返回行</li>
<li><code>INNER JOIN</code>:在表中存在至少一个匹配时，INNER JOIN 关键字返回行。</li>
<li><code>LEFT JOIN</code>: 即使右表中没有匹配，也从左表返回所有的行</li>
<li><code>RIGHT JOIN</code>: 即使左表中没有匹配，也从右表返回所有的行</li>
<li><code>FULL JOIN</code>: 只要其中一个表中存在匹配，就返回行</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">SELECT Persons.LastName, Persons.FirstName, Orders.OrderNo</div><div class="line">FROM Persons</div><div class="line">INNER JOIN Orders</div><div class="line">ON Persons.Id_P = Orders.Id_P</div><div class="line">ORDER BY Persons.LastName;</div></pre></td></tr></table></figure>
<h2 id="SQL-函数"><a href="#SQL-函数" class="headerlink" title="SQL 函数"></a>SQL 函数</h2><h3 id="COUNT"><a href="#COUNT" class="headerlink" title="COUNT"></a>COUNT</h3><blockquote>
<p>COUNT 让我们能够数出在表格中有多少笔资料被选出来。<br>语法：<code>SELECT COUNT(&quot;字段名&quot;) FROM &quot;表格名&quot;;</code></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">-- 表 Store_Information 有几笔 store_name 栏不是空白的资料。</div><div class="line">-- &quot;IS NOT NULL&quot; 是 &quot;这个栏位不是空白&quot; 的意思。</div><div class="line">SELECT COUNT (Store_Name) FROM Store_Information WHERE Store_Name IS NOT NULL; </div><div class="line">-- 获取 Persons 表的总数</div><div class="line">SELECT COUNT(1) AS totals FROM Persons;</div><div class="line">-- 获取表 station 字段 user_id 相同的总数</div><div class="line">select user_id, count(*) as totals from station group by user_id;</div></pre></td></tr></table></figure>
<h3 id="MAX"><a href="#MAX" class="headerlink" title="MAX"></a>MAX</h3><blockquote>
<p>MAX 函数返回一列中的最大值。NULL 值不包括在计算中。<br>语法：<code>SELECT MAX(&quot;字段名&quot;) FROM &quot;表格名&quot;</code></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">-- 列出表 Orders 字段 OrderPrice 列最大值，</div><div class="line">-- 结果集列不显示 OrderPrice 显示 LargestOrderPrice</div><div class="line">SELECT MAX(OrderPrice) AS LargestOrderPrice FROM Orders</div></pre></td></tr></table></figure>
<h2 id="添加索引"><a href="#添加索引" class="headerlink" title="添加索引"></a>添加索引</h2><h3 id="普通索引-INDEX"><a href="#普通索引-INDEX" class="headerlink" title="普通索引(INDEX)"></a>普通索引(INDEX)</h3><blockquote>
<p>语法：ALTER TABLE <code>表名字</code> ADD INDEX 索引名字 ( <code>字段名字</code> )</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">-- –直接创建索引</div><div class="line">CREATE INDEX index_user ON user(title)</div><div class="line">-- –修改表结构的方式添加索引</div><div class="line">ALTER TABLE table_name ADD INDEX index_name ON (column(length))</div><div class="line">-- 给 user 表中的 name字段 添加普通索引(INDEX)</div><div class="line">ALTER TABLE `table` ADD INDEX index_name (name)</div><div class="line">-- –创建表的时候同时创建索引</div><div class="line">CREATE TABLE `table` (</div><div class="line">    `id` int(11) NOT NULL AUTO_INCREMENT ,</div><div class="line">    `title` char(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL ,</div><div class="line">    `content` text CHARACTER SET utf8 COLLATE utf8_general_ci NULL ,</div><div class="line">    `time` int(10) NULL DEFAULT NULL ,</div><div class="line">    PRIMARY KEY (`id`),</div><div class="line">    INDEX index_name (title(length))</div><div class="line">)</div><div class="line">-- –删除索引</div><div class="line">DROP INDEX index_name ON table</div></pre></td></tr></table></figure>
<h3 id="主键索引-PRIMARY-key"><a href="#主键索引-PRIMARY-key" class="headerlink" title="主键索引(PRIMARY key)"></a>主键索引(PRIMARY key)</h3><blockquote>
<p>语法：ALTER TABLE <code>表名字</code> ADD PRIMARY KEY ( <code>字段名字</code> )</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">-- 给 user 表中的 id字段 添加主键索引(PRIMARY key)</div><div class="line">ALTER TABLE `user` ADD PRIMARY key (id);</div></pre></td></tr></table></figure>
<h3 id="唯一索引-UNIQUE"><a href="#唯一索引-UNIQUE" class="headerlink" title="唯一索引(UNIQUE)"></a>唯一索引(UNIQUE)</h3><blockquote>
<p>语法：ALTER TABLE <code>表名字</code> ADD UNIQUE (<code>字段名字</code>)</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">-- 给 user 表中的 creattime 字段添加唯一索引(UNIQUE)</div><div class="line">ALTER TABLE `user` ADD UNIQUE (creattime);</div></pre></td></tr></table></figure>
<h3 id="全文索引-FULLTEXT"><a href="#全文索引-FULLTEXT" class="headerlink" title="全文索引(FULLTEXT)"></a>全文索引(FULLTEXT)</h3><blockquote>
<p>语法：ALTER TABLE <code>表名字</code> ADD FULLTEXT (<code>字段名字</code>)</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">-- 给 user 表中的 description 字段添加全文索引(FULLTEXT)</div><div class="line">ALTER TABLE `user` ADD FULLTEXT (description);</div></pre></td></tr></table></figure>
<h3 id="添加多列索引"><a href="#添加多列索引" class="headerlink" title="添加多列索引"></a>添加多列索引</h3><blockquote>
<p>语法：</p>
</blockquote>
<p>ALTER TABLE <code>table_name</code> ADD INDEX index_name ( <code>column1</code>, <code>column2</code>, <code>column3</code>)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">-- 给 user 表中的 name、city、age 字段添加名字为name_city_age的普通索引(INDEX)</div><div class="line">ALTER TABLE user ADD INDEX name_city_age (name(10),city,age);</div></pre></td></tr></table></figure>
<h3 id="建立索引的时机"><a href="#建立索引的时机" class="headerlink" title="建立索引的时机"></a>建立索引的时机</h3><p>在<code>WHERE</code>和<code>JOIN</code>中出现的列需要建立索引，但也不完全如此：</p>
<ul>
<li>MySQL只对<code>&lt;</code>，<code>&lt;=</code>，<code>=</code>，<code>&gt;</code>，<code>&gt;=</code>，<code>BETWEEN</code>，<code>IN</code>使用索引</li>
<li>某些时候的<code>LIKE</code>也会使用索引。</li>
<li>在<code>LIKE</code>以通配符%和_开头作查询时，MySQL不会使用索引。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">-- 此时就需要对city和age建立索引，</div><div class="line">-- 由于mytable表的userame也出现在了JOIN子句中，也有对它建立索引的必要。</div><div class="line">SELECT t.Name  </div><div class="line">FROM mytable t LEFT JOIN mytable m ON t.Name=m.username </div><div class="line">WHERE m.age=20 AND m.city=&apos;上海&apos;;</div><div class="line"></div><div class="line">SELECT * FROM mytable WHERE username like&apos;admin%&apos;; -- 而下句就不会使用：</div><div class="line">SELECT * FROM mytable WHEREt Name like&apos;%admin&apos;; -- 因此，在使用LIKE时应注意以上的区别。</div></pre></td></tr></table></figure>
<p>索引的注意事项</p>
<ul>
<li>索引不会包含有NULL值的列</li>
<li>使用短索引</li>
<li>不要在列上进行运算 索引会失效</li>
</ul>
<h2 id="创建后表的修改"><a href="#创建后表的修改" class="headerlink" title="创建后表的修改"></a>创建后表的修改</h2><h3 id="添加列"><a href="#添加列" class="headerlink" title="添加列"></a>添加列</h3><blockquote>
<p>语法：<code>alter table 表名 add 列名 列数据类型 [after 插入位置];</code></p>
</blockquote>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">-- 在表students的最后追加列 address: </div><div class="line">alter table students add address char(60);</div><div class="line">-- 在名为 age 的列后插入列 birthday: </div><div class="line">alter table students add birthday date after age;</div><div class="line">-- 在名为 number_people 的列后插入列 weeks: </div><div class="line">alter table students add column `weeks` varchar(5) not null default &quot;&quot; after `number_people`;</div></pre></td></tr></table></figure>
<h3 id="修改列"><a href="#修改列" class="headerlink" title="修改列"></a>修改列</h3><blockquote>
<p>语法：<code>alter table 表名 change 列名称 列新名称 新数据类型;</code></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">-- 将表 tel 列改名为 telphone: </div><div class="line">alter table students change tel telphone char(13) default &quot;-&quot;;</div><div class="line">-- 将 name 列的数据类型改为 char(16): </div><div class="line">alter table students change name name char(16) not null;</div><div class="line">-- 修改 COMMENT 前面必须得有类型属性</div><div class="line">alter table students change name name char(16) COMMENT &apos;这里是名字&apos;;</div><div class="line">-- 修改列属性的时候 建议使用modify,不需要重建表</div><div class="line">-- change用于修改列名字，这个需要重建表</div><div class="line">alter table meeting modify `weeks` varchar(20) NOT NULL DEFAULT &quot;&quot; COMMENT &quot;开放日期 周一到周日：0~6，间隔用英文逗号隔开&quot;;</div></pre></td></tr></table></figure>
<h3 id="删除列"><a href="#删除列" class="headerlink" title="删除列"></a>删除列</h3><blockquote>
<p>语法：<code>alter table 表名 drop 列名称;</code></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">-- 删除表students中的 birthday 列: </div><div class="line">alter table students drop birthday;</div></pre></td></tr></table></figure>
<h3 id="重命名表"><a href="#重命名表" class="headerlink" title="重命名表"></a>重命名表</h3><blockquote>
<p>语法：<code>alter table 表名 rename 新表名;</code></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">-- 重命名 students 表为 workmates: </div><div class="line">alter table students rename workmates;</div></pre></td></tr></table></figure>
<h3 id="清空表数据"><a href="#清空表数据" class="headerlink" title="清空表数据"></a>清空表数据</h3><blockquote>
<p>方法一：<code>delete from 表名;</code><br>方法二：<code>truncate from &quot;表名&quot;;</code></p>
</blockquote>
<ul>
<li><code>DELETE:</code>1. DML语言;2. 可以回退;3. 可以有条件的删除;</li>
<li><code>TRUNCATE:</code>1. DDL语言;2. 无法回退;3. 默认所有的表内容都删除;4. 删除速度比delete快。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">-- 清空表为 workmates 里面的数据，不删除表。 </div><div class="line">delete from workmates;</div><div class="line">-- 删除workmates表中的所有数据，且无法恢复</div><div class="line">truncate from workmates;</div></pre></td></tr></table></figure>
<h3 id="删除整张表"><a href="#删除整张表" class="headerlink" title="删除整张表"></a>删除整张表</h3><blockquote>
<p>语法：<code>drop table 表名;</code></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">-- 删除 workmates 表: </div><div class="line">drop table workmates;</div></pre></td></tr></table></figure>
<h3 id="删除整个数据库"><a href="#删除整个数据库" class="headerlink" title="删除整个数据库"></a>删除整个数据库</h3><blockquote>
<p>语法：<code>drop database 数据库名;</code></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">-- 删除 samp_db 数据库: </div><div class="line">drop database samp_db;</div></pre></td></tr></table></figure>
<h2 id="参考手册"><a href="#参考手册" class="headerlink" title="参考手册"></a>参考手册</h2><ul>
<li><p><a href="http://www.w3school.com.cn/sql/index.asp" target="_blank" rel="external">http://www.w3school.com.cn/sq…</a></p>
</li>
<li><p><a href="http://www.1keydata.com/cn/sql/sql-count.php" target="_blank" rel="external">http://www.1keydata.com/cn/sq…</a></p>
<p>​</p>
</li>
</ul>
<p>注：该文章转载自：<a href="https://segmentfault.com/u/jslite/articles" target="_blank" rel="external">https://segmentfault.com/u/jslite/articles</a></p>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 网络 </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MySQL 数据库操作基础总结]]></title>
      <url>/2016/10/18/Mysql-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>数据库：存储数据的仓库。</p>
<ul>
<li>数据结构化</li>
<li>实现数据共享<ul>
<li>可以减少冗余数据</li>
</ul>
</li>
<li>数据独立性高</li>
<li>数据统一管理与控制</li>
</ul>
<h2 id="数据库介绍"><a href="#数据库介绍" class="headerlink" title="数据库介绍"></a>数据库介绍</h2><ul>
<li>MySQL 数据库</li>
<li>Oracle<ul>
<li>Orcale数据库管理系统由甲骨文公司开发，在数据库领域一直处于领先地位</li>
<li>商业收费，大型系统，淘宝、京东就使用了 Oracle 数据库</li>
</ul>
</li>
<li>SqlServer 数据库<ul>
<li>由微软公司开发，只能在Windows上运行。.net开发程序员</li>
</ul>
</li>
<li>DB2<ul>
<li>由IBM公司开发，在金融行业中使用的比较多。IBM的服务器，买服务器送数据库</li>
<li>商业收费</li>
</ul>
</li>
<li>MS SQL Server<ul>
<li>以上这些数据库都是使用 SQL 语言进行操作</li>
<li>SQL 语言就是用于 关系型数据库 的一个操作语言</li>
<li>利用这个 SQL 语言可以增删改查库和表，以及增删改查表数据</li>
<li>表 就是 关系</li>
<li>表与表之间就是关系</li>
</ul>
</li>
<li>MongoDB<ul>
<li>非关系型数据库</li>
<li>没有表，这个数据库中存储的数据都在集合中，类似于 JavaScript 对象，其实就是 json 格式的数据</li>
<li>集合没有结构，集合就是一个数组</li>
<li>也可以往集合中插入数据</li>
</ul>
</li>
</ul>
<p>MongoDB是由10gen公司开发的一个介于关系型数据库和非关系型数据库之间的产品，是非关系型数据库中功能最丰富，最像关系型数据库的。他支持的数据结构非常松散，是类似json的格式，所以可以存储比较复杂的数据结构类型。MongoDB数据库管理系统最大的特点就是它支持的查询语言非常强大，语法类似于面向对象的查询语言。它还是一个开源的数据库，对于大数据量、高并发的互联网应用，支持非常不错。操作非关系型数据库不需要使用SQL语言。</p>
<ul>
<li>关系型数据库存储结构<ul>
<li>数据库服务器<ul>
<li>数据库管理系统</li>
</ul>
</li>
<li>数据库</li>
<li>数据表<ul>
<li>根据业务设计表结构</li>
</ul>
</li>
<li>记录<ul>
<li>根据表结构存储记录数据</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>oracle、sqlserver、DB2、MySQL 都是关系型数据库。</p>
<h2 id="安装和配置-MySQL-数据库"><a href="#安装和配置-MySQL-数据库" class="headerlink" title="安装和配置 MySQL 数据库"></a>安装和配置 MySQL 数据库</h2><p>官方网站：<a href="http://www.mysql.com/" target="_blank" rel="external">http://www.mysql.com/</a></p>
<p>启动 和 停止MySQL服务：</p>
<blockquote>
<p>通过Windows的运行，输入services.msc找到MySQL服务</p>
<p>通过DOS命令启动MySQL服务（使用管理员权限打开终端）</p>
</blockquote>
<p>登录MySQL数据库:</p>
<p><code>mysql -h localhost -P 3306 -u root -p</code></p>
<ul>
<li><code>-h：</code>主机名</li>
<li><code>-P：</code>端口</li>
<li><code>-u：</code>用户名</li>
<li><code>-p：</code>密码</li>
</ul>
<p>mysql默认连接localhost和3306，所以可以省略-h和-P:</p>
<p><code>mysql -u root -p</code></p>
<p>在命令行中输入“help;”或者“h”，就会显示出MySQL的帮助信息。</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>简写</th>
<th>具体含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>?</td>
<td>?</td>
<td>显示帮助信息</td>
</tr>
<tr>
<td>exit</td>
<td>q</td>
<td>退出MySQL</td>
</tr>
<tr>
<td>help</td>
<td>h</td>
<td>显示帮助信息</td>
</tr>
<tr>
<td>quit</td>
<td>q</td>
<td>退出MySQL</td>
</tr>
<tr>
<td>status</td>
<td>s</td>
<td>获取MySQL服务器状态信息</td>
</tr>
<tr>
<td>use</td>
<td>u</td>
<td>用来选择一个数据库，以一个数据库名作为参数</td>
</tr>
</tbody>
</table>
<h2 id="数据库的存储结构"><a href="#数据库的存储结构" class="headerlink" title="数据库的存储结构"></a>数据库的存储结构</h2><ul>
<li>一个数据库服务器上可以有多个数据库</li>
<li>一个数据库中可以有多个表<ul>
<li>一个表一定要有表结构</li>
<li>所有的数据存储在表中，所以有了数据库之后，要先设计你的表结构</li>
</ul>
</li>
<li>一张表中存储多条记录<ul>
<li>记录按照表结构的形式进行存储</li>
</ul>
</li>
</ul>
<h2 id="创建数据库和表"><a href="#创建数据库和表" class="headerlink" title="创建数据库和表"></a>创建数据库和表</h2><h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">CREATE DATABASE [IF NOT EXISTS] db_name</div></pre></td></tr></table></figure>
<h3 id="查看数据库"><a href="#查看数据库" class="headerlink" title="查看数据库"></a>查看数据库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SHOW DATABASES;</div></pre></td></tr></table></figure>
<p>显示数据库创建语句</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SHOW CREATE DATABASE db_name;</div></pre></td></tr></table></figure>
<h3 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">DROP DATABASE [IF EXISTS] db_name;</div></pre></td></tr></table></figure>
<h3 id="选择数据库"><a href="#选择数据库" class="headerlink" title="选择数据库"></a>选择数据库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">USE db_name;</div></pre></td></tr></table></figure>
<h3 id="查看当前使用的数据库"><a href="#查看当前使用的数据库" class="headerlink" title="查看当前使用的数据库"></a>查看当前使用的数据库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SELECT database();</div></pre></td></tr></table></figure>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h3><table>
<thead>
<tr>
<th>类型</th>
<th>大小</th>
<th>范围（有符号）</th>
<th>范围（无符号）</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>TINYINT</td>
<td>1 字节</td>
<td>(-128，127)</td>
<td>(0，255)</td>
<td>小整数值</td>
</tr>
<tr>
<td>SMALLINT</td>
<td>2 字节</td>
<td>(-32 768，32 767)</td>
<td>(0，65 535)</td>
<td>大整数值</td>
</tr>
<tr>
<td>MEDIUMINT</td>
<td>3 字节</td>
<td>(-8 388 608，8 388 607)</td>
<td>(0，16 777 215)</td>
<td>大整数值</td>
</tr>
<tr>
<td>INT或INTEGER</td>
<td>4 字节</td>
<td>(-2 147 483 648，2 147 483 647)</td>
<td>(0，4 294 967 295)</td>
<td>大整数值</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
</tbody>
</table>
<h3 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h3><p>在MySQL数据库中，存储小数都是使用浮点数和定点数来表示的。</p>
<p>浮点数有两种：</p>
<ul>
<li>单精度浮点数（FLOAT）</li>
<li>双精度浮点数(DOUBLE)</li>
</ul>
<p>定点数（DECIMAL）[ˈdesɪml]</p>
<h3 id="时间和日期类型"><a href="#时间和日期类型" class="headerlink" title="时间和日期类型"></a>时间和日期类型</h3><table>
<thead>
<tr>
<th>类型</th>
<th>大小(字节)</th>
<th>范围</th>
<th>格式</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>DATE</td>
<td>3</td>
<td>1000-01-01/9999-12-31</td>
<td>YYY-MM-DD</td>
<td>日期值</td>
</tr>
<tr>
<td>TIME</td>
<td>3</td>
<td>‘-838:59:59’/‘838:59:59’</td>
<td>H:MM:SS</td>
<td>时间值或持续时间</td>
</tr>
<tr>
<td>YEAR</td>
<td>1</td>
<td>1901/2155</td>
<td>YYY</td>
<td>年份值</td>
</tr>
<tr>
<td>DATETIME</td>
<td>8</td>
<td>1000-01-01 00:00:00/9999-12-31 23:59:59</td>
<td>YYY-MM-DD HH:MM:SS</td>
<td>混合日期和时间值</td>
</tr>
<tr>
<td>TIMESTAMP</td>
<td>8</td>
<td>1970-01-01 00:00:00/2037 年某时</td>
<td>YYYMMDD HHMMSS</td>
<td>混合日期和时间值，时间戳</td>
</tr>
</tbody>
</table>
<p>如果插入的数值不合法，系统会自动将对应的零值插入到数据库中。</p>
<ul>
<li>YEAR</li>
</ul>
<p>使用4位字符串或数字表示，范围为‘1901‘ ~ ‘2155’或1901~2155</p>
<p>例如，输入‘2016‘或者2016，插入到数据库的值均为2016</p>
<ul>
<li>DATE</li>
</ul>
<p>DATE类型用来表示日期值，不包含时间部分。</p>
<p>可以使用“YYYY-MM-DD“或‘YYYYMMDD‘字符串表示</p>
<p>例如，输入‘2016-10-01‘或’20161001‘插入到数据库的日期都是2016-10-01</p>
<ul>
<li>TIME</li>
</ul>
<p>TIME类型用于表示时间值，它的显示形式一般为HH:MM:SS,其中HH 表示小时，MM表示分，SS表示秒</p>
<p>可以使用下面三种方式指定时间的值：</p>
<ol>
<li>以“D HH：MM：SS“字符串格式表示。其中，D表示日，可以取0-34之间的值，插入数据时，小时的值等于（D*24+HH）</li>
</ol>
<ul>
<li>例如，输入‘2 11:30:50‘，插入数据库的日期为 59:30:50</li>
</ul>
<ol>
<li>以‘HHMMSS‘字符串格式或者HHMMSS数字格式表示</li>
</ol>
<ul>
<li>例如：输入‘345454‘或345454，插入数据库的日期为34:54:54</li>
</ul>
<ol>
<li>使用CURRENT_TIME或NOW()输入当前系统时间</li>
</ol>
<ul>
<li>DATETIME</li>
</ul>
<p>指定DATETIME类型的值：</p>
<ol>
<li>以‘YYYY-MM-DD HH:MM:SS‘或者’YYYYMMDDHHMMSS‘字符串或数字都可以。</li>
<li>使用NOW来输入当前系统的日期和时间</li>
</ol>
<ul>
<li>TIMESTAMP</li>
</ul>
<p>TIMESTAMP类型显示形式和DATETIME相同，但取值范围比DATETIME小。</p>
<ol>
<li>输入CURRENT_TIMESTAMP输入系统当前日期和时间</li>
<li>输入NULL时，系统会自动输入当前日期和时间</li>
<li>无任何输入时，系统会输入系统当前日期和时间</li>
</ol>
<p>标记。利用它可以保存表中某条记录的最后修改时间。自动维护。</p>
<h3 id="CHAR和VARCHAR"><a href="#CHAR和VARCHAR" class="headerlink" title="CHAR和VARCHAR"></a>CHAR和VARCHAR</h3><table>
<thead>
<tr>
<th>插入值</th>
<th>CHAR(4)</th>
<th>存储需求</th>
<th>VARCHAR(4)</th>
<th>存储需求</th>
</tr>
</thead>
<tbody>
<tr>
<td>‘’</td>
<td>‘’</td>
<td>4个字节</td>
<td>‘’</td>
<td>1个字节</td>
</tr>
<tr>
<td>‘ab’</td>
<td>‘ab’</td>
<td>4个字节</td>
<td>‘ab’</td>
<td>3个字节</td>
</tr>
<tr>
<td>‘abc’</td>
<td></td>
<td>4个字节</td>
<td>‘abc’</td>
<td>4个字节</td>
</tr>
<tr>
<td>‘abcd’</td>
<td></td>
<td>4个字节</td>
<td>‘abcd’</td>
<td>5个字节</td>
</tr>
<tr>
<td>‘abcde’</td>
<td>‘abcd’</td>
<td>4个字节</td>
<td>‘abcd’</td>
<td>5个字节</td>
</tr>
</tbody>
</table>
<p>当数据为CHAR(4)类型时，不管插入值的长度是多少，所占用的存储空间都是4个字节。而VARCHAR（4）所对应的数据所占用的字节数为实际长度加1.</p>
<p>总结：</p>
<ul>
<li>字符长度不固定的类型使用VARCHAR 查询的时候要计算字节的长度</li>
<li>字符串长度固定的使用CHAR 查询速度快。</li>
<li>VARCAHR比CHAR省空间</li>
<li>CHAR比VARCHAR省时间</li>
</ul>
<p>TEXT类型</p>
<p>表示大文本数据，例如：文章内容、评论等</p>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="查看表结构"><a href="#查看表结构" class="headerlink" title="查看表结构"></a>查看表结构</h3><p>查看当前数据库中的所有表： <code>show tables;</code></p>
<p>查看表结构: <code>desc table_name;</code></p>
<p>查看建表语句: <code>show create table table_name;</code></p>
<h3 id="修改数据表"><a href="#修改数据表" class="headerlink" title="修改数据表"></a>修改数据表</h3><p>增加列: <code>ALTER TABLE table_name ADD colum datatype;</code></p>
<p>修改列: <code>ALTER TABLE table_name MODIFY colum datatype;</code></p>
<p>删除列: <code>ALTER TABLE table_name DROP colum;</code></p>
<p>修改表名: <code>rename TABLE table_name to new_table_name;</code></p>
<p>修改列名: <code>ALTER TABLE table_name change colum_name new_colum_name datatype;</code></p>
<h3 id="删除数据表"><a href="#删除数据表" class="headerlink" title="删除数据表"></a>删除数据表</h3><p><code>DROP TABLE table_name;</code></p>
<h3 id="表的约束"><a href="#表的约束" class="headerlink" title="表的约束"></a>表的约束</h3><table>
<thead>
<tr>
<th>约束条件</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>PRIMARY KEY</td>
<td>主键约束，用于唯一标识对应的记录</td>
</tr>
<tr>
<td>FOREIGN KEY</td>
<td>外键约束</td>
</tr>
<tr>
<td>NOT NULL</td>
<td>非空约束</td>
</tr>
<tr>
<td>UNIQUE</td>
<td>唯一性约束</td>
</tr>
<tr>
<td>DEFAULT</td>
<td>默认值约束，用于设置字段的默认值</td>
</tr>
</tbody>
</table>
<p>表的约束条件都是针对表中字段进行限制，从而保证数据表中数据的正确性和唯一性。</p>
<h4 id="主键约束"><a href="#主键约束" class="headerlink" title="主键约束"></a>主键约束</h4><p>每个数据表中最多只能有一个主键约束，定义为PRIMARY KEY 的字段不能有重复值且不能为NULL值。也就是非空而且唯一</p>
<p>语法：<code>字段名 数据类型 PRIMARY KEY</code></p>
<h4 id="非空约束"><a href="#非空约束" class="headerlink" title="非空约束"></a>非空约束</h4><p>非空约束指的是字段的值不能为NULL，在MySQL中，非空约束是通过NOT NULL 定义的。</p>
<p>语法：<code>字段名 数据类型 NOT NULL;</code></p>
<h4 id="唯一约束"><a href="#唯一约束" class="headerlink" title="唯一约束"></a>唯一约束</h4><p>唯一约束用于保证数据表中字段的唯一性，即表中字段的值不能重复出现。</p>
<p>语法：<code>字段名 数据类型 UNIQUE;</code></p>
<h4 id="默认约束"><a href="#默认约束" class="headerlink" title="默认约束"></a>默认约束</h4><p>默认约束用于给数据库中的字段指定默认值，即当在表中插入一条记录时，如果没有给这个字段赋值，数据库系统会为这个字段插入默认值。</p>
<p>语法：<code>字段名 数据类型 DEFAULT 默认值;</code></p>
<h3 id="设置表的字段值自动增加"><a href="#设置表的字段值自动增加" class="headerlink" title="设置表的字段值自动增加"></a>设置表的字段值自动增加</h3><p>如果想为表中插入的新纪录自动生成唯一ID。可以使用AUTO_INCREMENT实现</p>
<p>语法：<code>字段名 数据类型 AUTO_INCREMENT;</code></p>
<h2 id="添加、更新与删除数据"><a href="#添加、更新与删除数据" class="headerlink" title="添加、更新与删除数据"></a>添加、更新与删除数据</h2><h3 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h3><h4 id="为表中所有字段添加数据"><a href="#为表中所有字段添加数据" class="headerlink" title="为表中所有字段添加数据"></a>为表中所有字段添加数据</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">INSERT INTO 表名</div><div class="line">VALUES(列1值,列2值,...)</div></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<ul>
<li>values中的值必须与表中的字段一一对应。</li>
<li>插入的数据应与字段中的数据类型相同</li>
<li>数据的大小应该在列的规定范围内，例如不能将一个长度为80的字符串插入到长度为40个列中</li>
<li>字符和日期型数据应该包含在单引号中</li>
<li>如果要插入一个空值，不指定或者使用NULL</li>
</ul>
<h4 id="按照指定列添加数据："><a href="#按照指定列添加数据：" class="headerlink" title="按照指定列添加数据："></a>按照指定列添加数据：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">INSERT INTO 表名(列1名, 列2名,...)</div><div class="line">VALUES(列1值, 列2值,...)</div></pre></td></tr></table></figure>
<p><strong>注意: values中的值必须与列声明中的列一一对应</strong></p>
<h4 id="同时添加多条记录"><a href="#同时添加多条记录" class="headerlink" title="同时添加多条记录"></a>同时添加多条记录</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">INSERT INTO employee</div><div class="line">VALUES (value1,value2,value3...),</div><div class="line">        (value1,value2,value3...),</div><div class="line">        (value1,value2,value3),</div><div class="line">        ...;</div></pre></td></tr></table></figure>
<h3 id="更新全部数据："><a href="#更新全部数据：" class="headerlink" title="更新全部数据："></a>更新全部数据：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">UPDATE 表名</div><div class="line">SET 列名=值, 列名=值[,列名=值]</div></pre></td></tr></table></figure>
<h4 id="按条件更新："><a href="#按条件更新：" class="headerlink" title="按条件更新："></a>按条件更新：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">UPDATE 表名</div><div class="line">SET 列名=值, 列名=值[,列名=值]</div><div class="line">WHERE 条件;</div></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>UPDATE语句可以用新值更新原有表中行的列。</li>
<li>SET字句指定要修改哪些列和要给与哪些值</li>
<li>WHERE需要给定一个条件，表示要更新符号该条件的行，没有WHERE字句，则更新所有行</li>
</ul>
<h4 id="条件可以使用的运算符："><a href="#条件可以使用的运算符：" class="headerlink" title="条件可以使用的运算符："></a>条件可以使用的运算符：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">-- 比较运算符 &gt; &lt; &lt;= &gt;= = &lt;&gt;  大于、小于、大于(小于等于)、不等于</div><div class="line">BETWEEN…AND -- 显示在某一区间的值</div><div class="line">IN(set) -- 显示在in列表中的值，例：in(100,200)</div><div class="line">LIKE -- ‘张pattern’ 模糊查询%</div><div class="line">IS NULL -- 判断是否为空</div><div class="line"></div><div class="line">-- 逻辑运算符 AND 多个条件同时成立</div><div class="line">OR  多个条件任一成立</div><div class="line">NOT 不成立，例：WHERE NOT(salary&gt;100)</div></pre></td></tr></table></figure>
<h3 id="删除数据："><a href="#删除数据：" class="headerlink" title="删除数据："></a>删除数据：</h3><h4 id="删除全部数据"><a href="#删除全部数据" class="headerlink" title="删除全部数据"></a>删除全部数据</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">DELETE FROM 表名;</div></pre></td></tr></table></figure>
<h4 id="根据条件删除："><a href="#根据条件删除：" class="headerlink" title="根据条件删除："></a>根据条件删除：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">DELETE FROM 表名</div><div class="line">WHERE 条件;</div></pre></td></tr></table></figure>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>runcate初始化数据表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">truncate table_name;</div></pre></td></tr></table></figure>
<p><strong>truncate和delete的区别：</strong></p>
<ul>
<li>delete会一条一条的删</li>
<li>truncate先摧毁整张表，再创建一张和原来的表结构一模一样的表</li>
<li>拿拆迁举例子</li>
<li>truncate在效率上比delete高</li>
<li>truncate只能删除整表的数据，也就是格式化。</li>
<li>truncate会把自增id截断恢复为1</li>
</ul>
<p>总结：</p>
<ul>
<li>如果不使用WHERE语句，将删除表中所有数据</li>
<li>DELETE不能删除某一列的值，（可使用UPDATE）</li>
<li>使用DELETE语句仅仅删除记录，不删除表本身，如果要删除表，使用DROP TABLE语句</li>
<li>删除表中所有数据也可以使用truncate table_name语句</li>
</ul>
<h3 id="单表查询"><a href="#单表查询" class="headerlink" title="单表查询"></a>单表查询</h3><h4 id="简单查询"><a href="#简单查询" class="headerlink" title="简单查询"></a>简单查询</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SELECT [DISTINCT] *|&#123;colum1, colum2, colum3...&#125; FROM table_name;</div></pre></td></tr></table></figure>
<ul>
<li>SELECT指定查询哪些列的数据</li>
<li>column指定列名</li>
<li><ul>
<li>号表示查询所有列</li>
</ul>
</li>
<li>FROM 指定查询哪种表</li>
<li>DISTINCT 可选，指查询结果时，是否去除重复数据</li>
</ul>
<h4 id="查询表中所有数据："><a href="#查询表中所有数据：" class="headerlink" title="查询表中所有数据："></a>查询表中所有数据：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SELECT * FROM 表名;</div></pre></td></tr></table></figure>
<h4 id="按照指定列查询表中所有数据："><a href="#按照指定列查询表中所有数据：" class="headerlink" title="按照指定列查询表中所有数据："></a>按照指定列查询表中所有数据：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SELECT 列名,列名[,列名] FROM 表名;</div></pre></td></tr></table></figure>
<h4 id="根据条件查询数据："><a href="#根据条件查询数据：" class="headerlink" title="根据条件查询数据："></a>根据条件查询数据：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">SELECT * FROM 表名</div><div class="line">WHERE 条件;</div></pre></td></tr></table></figure>
<p>在WHERE字句中经常使用的运算符</p>
<table>
<thead>
<tr>
<th>比较运算符</th>
<th>&gt; &lt; &lt;= &gt;= = &lt;&gt;</th>
<th>大于、小于、大于(小于等于)、不等于</th>
</tr>
</thead>
<tbody>
<tr>
<td>比较运算符</td>
<td>BETWEEN…AND</td>
<td>显示在某一区间的值</td>
</tr>
<tr>
<td>比较运算符</td>
<td>IN(set)</td>
<td>显示在in列表中的值，例：in(100,200)</td>
</tr>
<tr>
<td>比较运算符</td>
<td>LIKE</td>
<td>‘张pattern’ 模糊查询%</td>
</tr>
<tr>
<td>比较运算符</td>
<td>IS NULL</td>
<td>判断是否为空</td>
</tr>
<tr>
<td>逻辑运算符</td>
<td>AND</td>
<td>多个条件同时成立</td>
</tr>
<tr>
<td>逻辑运算符</td>
<td>OR</td>
<td>多个条件任一成立</td>
</tr>
<tr>
<td>逻辑运算符</td>
<td>NOT</td>
<td>不成立，例：WHERE NOT(salary&gt;100)</td>
</tr>
</tbody>
</table>
<p>LIKE语句中，<code>%</code> 代表零个或多个任意字符，<code>_</code>代表一个字符，例如：<code>name LIKE &#39;_a%&#39;</code>;</p>
<h4 id="多表查询："><a href="#多表查询：" class="headerlink" title="多表查询："></a>多表查询：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">-- 多表查询</div><div class="line">-- 找到表 articles 中 user_id 等于 users 表中 id 的</div><div class="line">-- 多表查询可以起别名</div><div class="line">SELECT a.id as article_id, a.title, a.time</div><div class="line">FROM articles as a</div><div class="line">INSERT JOIN users as u</div><div class="line">ON a.user_id=u.id</div></pre></td></tr></table></figure>
<h4 id="查询总记录数："><a href="#查询总记录数：" class="headerlink" title="查询总记录数："></a>查询总记录数：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">-- 查询表中的总记录数据</div><div class="line">SELECT COUNT(id) as count FROM articles;</div></pre></td></tr></table></figure>
<h4 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h4><blockquote>
<p>在实际开发中，经常需要对某些数据进行统计，例如统计某个字段的最大值，最小值，平均值等，为此，MySQL提供了一些函数来实现这些功能。</p>
</blockquote>
<table>
<thead>
<tr>
<th>函数名称</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>COUNT()</td>
<td>返回某行的列数</td>
</tr>
<tr>
<td>SUM()</td>
<td>返回某列值的和</td>
</tr>
<tr>
<td>AVG()</td>
<td>返回某列的平均值</td>
</tr>
<tr>
<td>MAX()</td>
<td>返回某列值的最大值</td>
</tr>
<tr>
<td>MIN()</td>
<td>返回某列的最小值</td>
</tr>
</tbody>
</table>
<ul>
<li>COUNT（列名）返回某一列，行的总数</li>
<li>COUNT（列名）返回某一列，行的总数</li>
<li>SUM()函数返回满足WHERE条件的行的和</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">SELECT SUM(列名) &#123;, SUM(列名)...&#125; FROM table_name</div><div class="line">  [WHERE where_definition]</div></pre></td></tr></table></figure>
<p>注意：SUM仅对数值起作用，否则报错; 对多列求和，“,”不能少。</p>
<ul>
<li>MAX()/MIN()函数返回满足WHERE条件的一列的最大/最小值</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">SELECT MAX(列名) FROM table_name</div><div class="line">  [WHERE where_definition];</div></pre></td></tr></table></figure>
<h4 id="对查询结果排序"><a href="#对查询结果排序" class="headerlink" title="对查询结果排序"></a>对查询结果排序</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">SELECT colum1, colum2, colum3..</div><div class="line">    FROM table_name</div><div class="line">    ORDER BY colum ASC|DESC;</div></pre></td></tr></table></figure>
<p>ORDER BY 指定排序的列，排序的列表即可以是表中的列名，也可以是SELECT语句后指定的列名.</p>
<ul>
<li>ASC 升序，DESC 降序</li>
<li>ORDER BY 字句应该位于SELECT 语句的结尾</li>
</ul>
<h4 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">SELECT colum1, colum2, ...</div><div class="line">  FROM 表名</div><div class="line">  LIMIT [OFFSET, ] 记录数</div></pre></td></tr></table></figure>
<p>LIMIT表示从哪一条记录开始往后【不包含该记录】，以及一共查询多少记录</p>
<p>OFFSET表示偏移量:</p>
<ul>
<li>如果为0则表示从第一条记录开始</li>
<li>如果为5则表示从第6条记录开始</li>
</ul>
<p>使用场景：分页查询</p>
<h4 id="分页查询一个例子"><a href="#分页查询一个例子" class="headerlink" title="分页查询一个例子"></a>分页查询一个例子</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">-- 仅仅取了前 10 条</div><div class="line">SELECET * FROM articles LIMIT 10</div><div class="line">-- 跳过一条取一条</div><div class="line">SELECET * FROM articles LIMIT 1, 1</div></pre></td></tr></table></figure>
<h3 id="为表和字段区别名"><a href="#为表和字段区别名" class="headerlink" title="为表和字段区别名"></a>为表和字段区别名</h3><h4 id="为表取别名"><a href="#为表取别名" class="headerlink" title="为表取别名"></a>为表取别名</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">SELECT 表别名.id,表别名.name... FROM 表名 AS 表别名</div><div class="line">  WHERE 表别名.id = 2..</div></pre></td></tr></table></figure>
<h4 id="为字段取别名"><a href="#为字段取别名" class="headerlink" title="为字段取别名"></a>为字段取别名</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SELECT 字段名 [AS] 别名 [,字段名 [AS] 别名,...] FROM 表名;</div></pre></td></tr></table></figure>
<h3 id="多表操作"><a href="#多表操作" class="headerlink" title="多表操作"></a>多表操作</h3><p>实际开发中业务逻辑比较复杂，可能有几十到几百张表不等，所以我们就需要对多张表来进行查询操作，对两张以上的表进行操作，就是多表操作。</p>
<h4 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h4><p>为了保证数据的完整性，将两张表之间的数据建立关系，因此就需要在成绩表中添加外键约束。</p>
<ul>
<li>外键是指引用另一个表中的一列或多列，被引用的列应该具有主键约束或唯一约束。</li>
<li>外键用于建立和加强两个表数据之间的链接。</li>
</ul>
<h4 id="为表添加外键约束"><a href="#为表添加外键约束" class="headerlink" title="为表添加外键约束"></a>为表添加外键约束</h4><p>创建表的时候添加外键:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE department(</div><div class="line">    id INT PRIMARY KEY auto_increment,</div><div class="line">    name VARCHAR(20) NOT NULL</div><div class="line">);</div><div class="line">CREATE TABLE employee(</div><div class="line">    id INT PRIMARY KEY auto_increment,</div><div class="line">    name VARCHAR(20) NOT NULL,</div><div class="line">    dept_id INT,</div><div class="line">    FOREIGN KEY (id) REFERENCES department(id)</div><div class="line">);</div></pre></td></tr></table></figure>
<p>表已经存在，通过修改表的语句增加外键:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ALTER TABLE 表名 ADD CONSTRAINT 外键名 FOREIGN KEY(外键字段名) REFERENCES 外表表名(主键字段名);</div></pre></td></tr></table></figure>
<h4 id="删除外键约束"><a href="#删除外键约束" class="headerlink" title="删除外键约束"></a>删除外键约束</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ALTER TABLE 表名 DROP FOREIGN KEY 外键名;</div></pre></td></tr></table></figure>
<h3 id="操作关联表"><a href="#操作关联表" class="headerlink" title="操作关联表"></a>操作关联表</h3><blockquote>
<p>关联关系:</p>
</blockquote>
<ul>
<li>多对一</li>
<li>多对多</li>
<li>一对一</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 网络 </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>/2016/10/14/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 编程 </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
